This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: tsconfig.tsbuildinfo
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
scripts/
  download-syncthing.js
src/
  app/
    globals.css
    layout.tsx
    page.tsx
  components/
    ui/
      badge.tsx
      button.tsx
      card.tsx
      motion.tsx
      skeleton.tsx
    add-device-dialog.tsx
    add-folder-dialog.tsx
    ai-search-bar.tsx
    conflict-resolver.tsx
    debug-panel.tsx
    device-list.tsx
    error-boundary.tsx
    file-browser.tsx
    file-indexer.tsx
    folder-list.tsx
    header.tsx
    ignore-patterns-dialog.tsx
    log-viewer.tsx
    logs-page.tsx
    main-content.tsx
    network-graph.tsx
    providers.tsx
    settings-page.tsx
    share-folder-dialog.tsx
    sidebar.tsx
    stats-overview.tsx
    syncthing-manager.tsx
  hooks/
    useAISearch.ts
    useErrorNotifications.ts
    useNotifications.ts
    useSyncthing.ts
    useSyncthingEnhanced.ts
  lib/
    __tests__/
      error-test-utils.ts
    auto-recovery.ts
    db.ts
    error-notifications.ts
    errors.ts
    health-monitor.ts
    logger.ts
    retry.ts
    utils.ts
  store/
    index.ts
  workers/
    ai.worker.ts
src-tauri/
  capabilities/
    default.json
  src/
    commands.rs
    lib.rs
    main.rs
  .gitignore
  build.rs
  Cargo.toml
  clippy.toml
  rustfmt.toml
  tauri.conf.json
.gitattributes
.gitignore
.prettierignore
.prettierrc
eslint.config.mjs
next-env.d.ts
next.config.mjs
package.json
postcss.config.mjs
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/ci.yml">
name: CI

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

env:
  CARGO_TERM_COLOR: always

jobs:
  # Frontend linting and formatting
  frontend-lint:
    name: Frontend Lint & Format
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run ESLint
        run: pnpm lint

      - name: Check Prettier formatting
        run: pnpm format:check

      - name: TypeScript type check
        run: pnpm type-check

  # Rust linting and formatting
  rust-lint:
    name: Rust Lint & Format
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf libssl-dev

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri

      - name: Check Rust formatting
        working-directory: src-tauri
        run: cargo fmt --all -- --check

      - name: Run Clippy
        working-directory: src-tauri
        run: cargo clippy --all-targets --all-features -- -D warnings

  # Build verification
  build:
    name: Build
    needs: [frontend-lint, rust-lint]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf libssl-dev

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build frontend
        run: pnpm build

      - name: Build Tauri (check only)
        working-directory: src-tauri
        run: cargo check --all-targets
</file>

<file path="src-tauri/capabilities/default.json">
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "Capability for the main window",
  "windows": ["main"],
  "permissions": [
    "core:default",
    "opener:default",
    "notification:default",
    "dialog:allow-open",
    {
      "identifier": "shell:allow-spawn",
      "allow": [
        {
          "name": "binaries/syncthing",
          "sidecar": true,
          "args": [
            "-no-browser",
            "-no-restart",
            {
              "validator": "\\S+"
            }
          ]
        }
      ]
    },
    "shell:allow-kill"
  ]
}
</file>

<file path="src-tauri/src/commands.rs">
use crate::{SyncthingError, SyncthingState};
use tauri::State;
use tauri::AppHandle;
use tauri_plugin_shell::ShellExt;
use serde::Serialize;

/// Information about Syncthing installation
#[derive(Debug, Serialize)]
pub struct SyncthingInfo {
    pub installed: bool,
    pub version: Option<String>,
    pub path: Option<String>,
    pub bundled: bool,
}

/// Check if Syncthing is installed and get version info
#[tauri::command]
pub fn check_syncthing_installation() -> SyncthingInfo {
    // Check for system-installed syncthing
    use std::process::Command;
    match Command::new("syncthing").arg("--version").output() {
        Ok(output) => {
            let version_str = String::from_utf8_lossy(&output.stdout);
            let version = version_str
                .lines()
                .next()
                .map(|s| s.to_string());
            
            // Try to get the path
            let path = Command::new("which")
                .arg("syncthing")
                .output()
                .ok()
                .and_then(|o| {
                    let p = String::from_utf8_lossy(&o.stdout).trim().to_string();
                    if p.is_empty() { None } else { Some(p) }
                });
            
            SyncthingInfo {
                installed: true,
                version,
                path,
                bundled: false,
            }
        }
        Err(_) => SyncthingInfo {
            installed: true, // Bundled sidecar is always available
            version: Some("bundled".to_string()),
            path: Some("bundled sidecar".to_string()),
            bundled: true,
        },
    }
}

/// Start the Syncthing sidecar process
#[tauri::command]
pub async fn start_syncthing_sidecar(
    app: AppHandle,
    state: State<'_, SyncthingState>,
) -> Result<String, SyncthingError> {
    let mut child_guard = state.sidecar_child.lock().map_err(|e| {
        SyncthingError::ProcessError(format!("Failed to acquire lock: {}", e))
    })?;

    if child_guard.is_some() {
        return Ok("Syncthing already running".into());
    }

    // Use the bundled sidecar
    let sidecar_command = app.shell()
        .sidecar("syncthing")
        .map_err(|e| SyncthingError::ProcessError(format!("Failed to create sidecar command: {}", e)))?
        .args([
            "-no-browser",
            "-no-restart",
            &format!("-gui-apikey={}", state.config.api_key),
            &format!("-gui-address={}:{}", state.config.host, state.config.port),
        ]);

    let (_rx, child) = sidecar_command
        .spawn()
        .map_err(|e| SyncthingError::ProcessError(format!("Failed to spawn syncthing sidecar: {}", e)))?;

    *child_guard = Some(child);
    Ok("Syncthing sidecar started successfully".into())
}

/// Stop the Syncthing sidecar process
#[tauri::command]
pub async fn stop_syncthing_sidecar(
    state: State<'_, SyncthingState>,
) -> Result<String, SyncthingError> {
    let mut child_guard = state.sidecar_child.lock().map_err(|e| {
        SyncthingError::ProcessError(format!("Failed to acquire lock: {}", e))
    })?;

    if let Some(child) = child_guard.take() {
        child.kill().map_err(|e| {
            SyncthingError::ProcessError(format!("Failed to kill sidecar process: {}", e))
        })?;
        Ok("Syncthing sidecar stopped".into())
    } else {
        Ok("Syncthing sidecar was not running".into())
    }
}

/// Get Syncthing system status
#[tauri::command]
pub async fn get_system_status(
    state: State<'_, SyncthingState>,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/system/status",
        state.config.host, state.config.port
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

/// Get Syncthing connections info
#[tauri::command]
pub async fn get_connections(
    state: State<'_, SyncthingState>,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/system/connections",
        state.config.host, state.config.port
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

/// Get Syncthing configuration
#[tauri::command]
pub async fn get_config(
    state: State<'_, SyncthingState>,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config",
        state.config.host, state.config.port
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

/// Update global Syncthing options
#[tauri::command]
pub async fn update_options(
    state: State<'_, SyncthingState>,
    options: serde_json::Value,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    
    // First get the current config
    let get_url = format!(
        "http://{}:{}/rest/config",
        state.config.host, state.config.port
    );

    let current_config: serde_json::Value = client
        .get(&get_url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Merge options into current config
    let mut updated_config = current_config.clone();
    if let (Some(config_obj), Some(current_options)) = (
        updated_config.as_object_mut(),
        current_config.get("options"),
    ) {
        let mut new_options = current_options.clone();
        if let (Some(opts_obj), Some(updates_obj)) = (
            new_options.as_object_mut(),
            options.as_object(),
        ) {
            for (key, value) in updates_obj {
                opts_obj.insert(key.clone(), value.clone());
            }
        }
        config_obj.insert("options".to_string(), new_options);
    }

    // Save the updated config
    let put_url = format!(
        "http://{}:{}/rest/config",
        state.config.host, state.config.port
    );

    let res = client
        .put(&put_url)
        .header("X-API-Key", &state.config.api_key)
        .json(&updated_config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    if !res.status().is_success() {
        return Err(SyncthingError::HttpError(format!(
            "Failed to update options: {}",
            res.status()
        )));
    }

    Ok(())
}

/// Get folder status
#[tauri::command]
pub async fn get_folder_status(
    state: State<'_, SyncthingState>,
    folder_id: String,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/db/status?folder={}",
        state.config.host, state.config.port, folder_id
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

/// Pause a folder
#[tauri::command]
pub async fn pause_folder(
    state: State<'_, SyncthingState>,
    folder_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/folders/{}",
        state.config.host, state.config.port, folder_id
    );

    // Get current config
    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Update paused status
    config["paused"] = serde_json::Value::Bool(true);

    // Put updated config
    client
        .put(&url)
        .header("X-API-Key", &state.config.api_key)
        .json(&config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Resume a folder
#[tauri::command]
pub async fn resume_folder(
    state: State<'_, SyncthingState>,
    folder_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/folders/{}",
        state.config.host, state.config.port, folder_id
    );

    // Get current config
    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Update paused status
    config["paused"] = serde_json::Value::Bool(false);

    // Put updated config
    client
        .put(&url)
        .header("X-API-Key", &state.config.api_key)
        .json(&config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Force rescan of a folder
#[tauri::command]
pub async fn rescan_folder(
    state: State<'_, SyncthingState>,
    folder_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/db/scan?folder={}",
        state.config.host, state.config.port, folder_id
    );

    client
        .post(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Get the current API configuration (for debugging)
#[tauri::command]
pub fn get_api_config(state: State<'_, SyncthingState>) -> (String, u16) {
    (state.config.host.clone(), state.config.port)
}

/// Get this device's ID
#[tauri::command]
pub async fn get_device_id(
    state: State<'_, SyncthingState>,
) -> Result<String, SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/system/status",
        state.config.host, state.config.port
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    json["myID"]
        .as_str()
        .map(|s| s.to_string())
        .ok_or_else(|| SyncthingError::ParseError("No device ID found".into()))
}

/// Add a new device to Syncthing
#[tauri::command]
pub async fn add_device(
    state: State<'_, SyncthingState>,
    device_id: String,
    name: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    
    // First, get current config
    let config_url = format!(
        "http://{}:{}/rest/config",
        state.config.host, state.config.port
    );
    
    let res = client
        .get(&config_url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Check if device already exists
    if let Some(devices) = config["devices"].as_array() {
        for device in devices {
            if device["deviceID"].as_str() == Some(&device_id) {
                return Err(SyncthingError::ProcessError("Device already exists".into()));
            }
        }
    }

    // Create new device config
    let new_device = serde_json::json!({
        "deviceID": device_id,
        "name": name,
        "addresses": ["dynamic"],
        "compression": "metadata",
        "introducer": false,
        "paused": false,
        "autoAcceptFolders": false,
    });

    // Add to devices array
    if let Some(devices) = config["devices"].as_array_mut() {
        devices.push(new_device);
    }

    // Save updated config
    client
        .put(&config_url)
        .header("X-API-Key", &state.config.api_key)
        .json(&config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Remove a device from Syncthing
#[tauri::command]
pub async fn remove_device(
    state: State<'_, SyncthingState>,
    device_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/devices/{}",
        state.config.host, state.config.port, device_id
    );

    client
        .delete(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Add a new folder to Syncthing
#[tauri::command]
pub async fn add_folder(
    state: State<'_, SyncthingState>,
    folder_id: String,
    folder_label: String,
    folder_path: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    
    // First, get current config
    let config_url = format!(
        "http://{}:{}/rest/config",
        state.config.host, state.config.port
    );
    
    let res = client
        .get(&config_url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Check if folder already exists
    if let Some(folders) = config["folders"].as_array() {
        for folder in folders {
            if folder["id"].as_str() == Some(&folder_id) {
                return Err(SyncthingError::ProcessError("Folder already exists".into()));
            }
        }
    }

    // Create new folder config
    let new_folder = serde_json::json!({
        "id": folder_id,
        "label": folder_label,
        "path": folder_path,
        "type": "sendreceive",
        "rescanIntervalS": 3600,
        "fsWatcherEnabled": true,
        "fsWatcherDelayS": 10,
        "ignorePerms": false,
        "autoNormalize": true,
        "paused": false,
        "devices": [],
        "minDiskFree": {
            "value": 1,
            "unit": "%"
        },
        "versioning": {
            "type": "",
            "params": {},
            "cleanupIntervalS": 3600,
            "fsPath": "",
            "fsType": "basic"
        },
        "copiers": 0,
        "pullerMaxPendingKiB": 0,
        "hashers": 0,
        "order": "random",
        "ignoreDelete": false,
        "scanProgressIntervalS": 0,
        "pullerPauseS": 0,
        "maxConflicts": 10,
        "disableSparseFiles": false,
        "disableTempIndexes": false,
        "weakHashThresholdPct": 25,
        "markerName": ".stfolder",
        "copyOwnershipFromParent": false,
        "modTimeWindowS": 0,
        "maxConcurrentWrites": 2,
        "disableFsync": false,
        "blockPullOrder": "standard",
        "copyRangeMethod": "standard",
        "caseSensitiveFS": false,
        "junctionsAsDirs": false,
        "syncOwnership": false,
        "sendOwnership": false,
        "syncXattrs": false,
        "sendXattrs": false,
        "xattrFilter": {
            "entries": [],
            "maxSingleEntrySize": 1024,
            "maxTotalSize": 4096
        }
    });

    // Add to folders array
    if let Some(folders) = config["folders"].as_array_mut() {
        folders.push(new_folder);
    }

    // Save updated config
    client
        .put(&config_url)
        .header("X-API-Key", &state.config.api_key)
        .json(&config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Remove a folder from Syncthing
#[tauri::command]
pub async fn remove_folder(
    state: State<'_, SyncthingState>,
    folder_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/folders/{}",
        state.config.host, state.config.port, folder_id
    );

    client
        .delete(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Share a folder with a specific device
#[tauri::command]
pub async fn share_folder(
    state: State<'_, SyncthingState>,
    folder_id: String,
    device_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/folders/{}",
        state.config.host, state.config.port, folder_id
    );

    // 1. Get current folder config
    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut folder_config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // 2. Check if device is already added
    let mut device_exists = false;
    if let Some(devices) = folder_config["devices"].as_array() {
        for device in devices {
            if device["deviceID"].as_str() == Some(&device_id) {
                device_exists = true;
                break;
            }
        }
    }

    // 3. Add device if not exists
    if !device_exists {
        let new_device_entry = serde_json::json!({
            "deviceID": device_id,
            "introducedBy": ""
        });

        if let Some(devices) = folder_config["devices"].as_array_mut() {
            devices.push(new_device_entry);
        }

        // 4. Update config
        client
            .put(&url)
            .header("X-API-Key", &state.config.api_key)
            .json(&folder_config)
            .send()
            .await
            .map_err(|e| SyncthingError::HttpError(e.to_string()))?;
    }

    Ok(())
}

// ============================================================================
// Advanced Folder Configuration
// ============================================================================

/// Add a folder with advanced configuration options
#[tauri::command]
pub async fn add_folder_advanced(
    state: State<'_, SyncthingState>,
    folder_id: String,
    folder_label: String,
    folder_path: String,
    versioning_type: Option<String>,
    versioning_params: Option<serde_json::Value>,
    rescan_interval_s: Option<u32>,
    fs_watcher_enabled: Option<bool>,
    fs_watcher_delay_s: Option<u32>,
    ignore_perms: Option<bool>,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    
    let config_url = format!(
        "http://{}:{}/rest/config",
        state.config.host, state.config.port
    );
    
    let res = client
        .get(&config_url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Check if folder already exists
    if let Some(folders) = config["folders"].as_array() {
        for folder in folders {
            if folder["id"].as_str() == Some(&folder_id) {
                return Err(SyncthingError::ProcessError("Folder already exists".into()));
            }
        }
    }

    // Build versioning config
    let versioning = match versioning_type.as_deref() {
        Some("simple") => serde_json::json!({
            "type": "simple",
            "params": versioning_params.unwrap_or(serde_json::json!({
                "keep": "5"
            })),
            "cleanupIntervalS": 3600,
            "fsPath": "",
            "fsType": "basic"
        }),
        Some("staggered") => serde_json::json!({
            "type": "staggered",
            "params": versioning_params.unwrap_or(serde_json::json!({
                "cleanInterval": "3600",
                "maxAge": "31536000"
            })),
            "cleanupIntervalS": 3600,
            "fsPath": "",
            "fsType": "basic"
        }),
        Some("trashcan") => serde_json::json!({
            "type": "trashcan",
            "params": versioning_params.unwrap_or(serde_json::json!({
                "cleanoutDays": "0"
            })),
            "cleanupIntervalS": 3600,
            "fsPath": "",
            "fsType": "basic"
        }),
        Some("external") => serde_json::json!({
            "type": "external",
            "params": versioning_params.unwrap_or(serde_json::json!({
                "command": ""
            })),
            "cleanupIntervalS": 3600,
            "fsPath": "",
            "fsType": "basic"
        }),
        _ => serde_json::json!({
            "type": "",
            "params": {},
            "cleanupIntervalS": 3600,
            "fsPath": "",
            "fsType": "basic"
        }),
    };

    let new_folder = serde_json::json!({
        "id": folder_id,
        "label": folder_label,
        "path": folder_path,
        "type": "sendreceive",
        "rescanIntervalS": rescan_interval_s.unwrap_or(3600),
        "fsWatcherEnabled": fs_watcher_enabled.unwrap_or(true),
        "fsWatcherDelayS": fs_watcher_delay_s.unwrap_or(10),
        "ignorePerms": ignore_perms.unwrap_or(false),
        "autoNormalize": true,
        "paused": false,
        "devices": [],
        "minDiskFree": { "value": 1, "unit": "%" },
        "versioning": versioning,
        "copiers": 0,
        "pullerMaxPendingKiB": 0,
        "hashers": 0,
        "order": "random",
        "ignoreDelete": false,
        "scanProgressIntervalS": 0,
        "pullerPauseS": 0,
        "maxConflicts": 10,
        "disableSparseFiles": false,
        "disableTempIndexes": false,
        "weakHashThresholdPct": 25,
        "markerName": ".stfolder",
        "copyOwnershipFromParent": false,
        "modTimeWindowS": 0,
        "maxConcurrentWrites": 2,
        "disableFsync": false,
        "blockPullOrder": "standard",
        "copyRangeMethod": "standard",
        "caseSensitiveFS": false,
        "junctionsAsDirs": false,
        "syncOwnership": false,
        "sendOwnership": false,
        "syncXattrs": false,
        "sendXattrs": false,
        "xattrFilter": {
            "entries": [],
            "maxSingleEntrySize": 1024,
            "maxTotalSize": 4096
        }
    });

    if let Some(folders) = config["folders"].as_array_mut() {
        folders.push(new_folder);
    }

    client
        .put(&config_url)
        .header("X-API-Key", &state.config.api_key)
        .json(&config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Update folder configuration
#[tauri::command]
pub async fn update_folder_config(
    state: State<'_, SyncthingState>,
    folder_id: String,
    updates: serde_json::Value,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/folders/{}",
        state.config.host, state.config.port, folder_id
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut folder_config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Merge updates into folder config
    if let (Some(config_obj), Some(updates_obj)) = (folder_config.as_object_mut(), updates.as_object()) {
        for (key, value) in updates_obj {
            config_obj.insert(key.clone(), value.clone());
        }
    }

    client
        .put(&url)
        .header("X-API-Key", &state.config.api_key)
        .json(&folder_config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

// ============================================================================
// Ignore Patterns (.stignore)
// ============================================================================

/// Get ignore patterns for a folder
#[tauri::command]
pub async fn get_folder_ignores(
    state: State<'_, SyncthingState>,
    folder_id: String,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/db/ignores?folder={}",
        state.config.host, state.config.port, folder_id
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

/// Set ignore patterns for a folder
#[tauri::command]
pub async fn set_folder_ignores(
    state: State<'_, SyncthingState>,
    folder_id: String,
    ignore_patterns: Vec<String>,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/db/ignores?folder={}",
        state.config.host, state.config.port, folder_id
    );

    let body = serde_json::json!({
        "ignore": ignore_patterns
    });

    client
        .post(&url)
        .header("X-API-Key", &state.config.api_key)
        .json(&body)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

// ============================================================================
// System Logs
// ============================================================================

/// Get Syncthing logs
#[tauri::command]
pub async fn get_system_logs(
    state: State<'_, SyncthingState>,
    since: Option<String>,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let mut url = format!(
        "http://{}:{}/rest/system/log",
        state.config.host, state.config.port
    );

    if let Some(since_time) = since {
        url = format!("{}?since={}", url, since_time);
    }

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

// ============================================================================
// Event API
// ============================================================================

/// Get events from Syncthing (for real-time updates)
#[tauri::command]
pub async fn get_events(
    state: State<'_, SyncthingState>,
    since: Option<u64>,
    limit: Option<u32>,
    timeout: Option<u32>,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::builder()
        .timeout(std::time::Duration::from_secs(timeout.unwrap_or(60) as u64 + 5))
        .build()
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut url = format!(
        "http://{}:{}/rest/events",
        state.config.host, state.config.port
    );

    let mut params = Vec::new();
    if let Some(s) = since {
        params.push(format!("since={}", s));
    }
    if let Some(l) = limit {
        params.push(format!("limit={}", l));
    }
    if let Some(t) = timeout {
        params.push(format!("timeout={}", t));
    }

    if !params.is_empty() {
        url = format!("{}?{}", url, params.join("&"));
    }

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

// ============================================================================
// Advanced Device Settings
// ============================================================================

/// Add device with advanced options
#[tauri::command]
pub async fn add_device_advanced(
    state: State<'_, SyncthingState>,
    device_id: String,
    name: String,
    addresses: Option<Vec<String>>,
    compression: Option<String>,
    introducer: Option<bool>,
    auto_accept_folders: Option<bool>,
    max_send_kbps: Option<u32>,
    max_recv_kbps: Option<u32>,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    
    let config_url = format!(
        "http://{}:{}/rest/config",
        state.config.host, state.config.port
    );
    
    let res = client
        .get(&config_url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Check if device already exists
    if let Some(devices) = config["devices"].as_array() {
        for device in devices {
            if device["deviceID"].as_str() == Some(&device_id) {
                return Err(SyncthingError::ProcessError("Device already exists".into()));
            }
        }
    }

    let new_device = serde_json::json!({
        "deviceID": device_id,
        "name": name,
        "addresses": addresses.unwrap_or_else(|| vec!["dynamic".to_string()]),
        "compression": compression.unwrap_or_else(|| "metadata".to_string()),
        "introducer": introducer.unwrap_or(false),
        "paused": false,
        "autoAcceptFolders": auto_accept_folders.unwrap_or(false),
        "maxSendKbps": max_send_kbps.unwrap_or(0),
        "maxRecvKbps": max_recv_kbps.unwrap_or(0),
    });

    if let Some(devices) = config["devices"].as_array_mut() {
        devices.push(new_device);
    }

    client
        .put(&config_url)
        .header("X-API-Key", &state.config.api_key)
        .json(&config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Update device configuration
#[tauri::command]
pub async fn update_device_config(
    state: State<'_, SyncthingState>,
    device_id: String,
    updates: serde_json::Value,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/devices/{}",
        state.config.host, state.config.port, device_id
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut device_config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Merge updates
    if let (Some(config_obj), Some(updates_obj)) = (device_config.as_object_mut(), updates.as_object()) {
        for (key, value) in updates_obj {
            config_obj.insert(key.clone(), value.clone());
        }
    }

    client
        .put(&url)
        .header("X-API-Key", &state.config.api_key)
        .json(&device_config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Pause a device
#[tauri::command]
pub async fn pause_device(
    state: State<'_, SyncthingState>,
    device_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/devices/{}",
        state.config.host, state.config.port, device_id
    );

    // Get current config
    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Update paused status
    config["paused"] = serde_json::Value::Bool(true);

    // Put updated config
    client
        .put(&url)
        .header("X-API-Key", &state.config.api_key)
        .json(&config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Resume a device
#[tauri::command]
pub async fn resume_device(
    state: State<'_, SyncthingState>,
    device_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/devices/{}",
        state.config.host, state.config.port, device_id
    );

    // Get current config
    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Update paused status
    config["paused"] = serde_json::Value::Bool(false);

    // Put updated config
    client
        .put(&url)
        .header("X-API-Key", &state.config.api_key)
        .json(&config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Unshare a folder from a device
#[tauri::command]
pub async fn unshare_folder(
    state: State<'_, SyncthingState>,
    folder_id: String,
    device_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/folders/{}",
        state.config.host, state.config.port, folder_id
    );

    // Get current folder config
    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut folder_config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Remove device from the devices array
    if let Some(devices) = folder_config["devices"].as_array_mut() {
        devices.retain(|d| d["deviceID"].as_str() != Some(&device_id));
    }

    // Update config
    client
        .put(&url)
        .header("X-API-Key", &state.config.api_key)
        .json(&folder_config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

// ============================================================================
// System Management
// ============================================================================

/// Restart Syncthing
#[tauri::command]
pub async fn restart_syncthing(
    state: State<'_, SyncthingState>,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/system/restart",
        state.config.host, state.config.port
    );

    client
        .post(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Get detailed folder configuration
#[tauri::command]
pub async fn get_folder_config(
    state: State<'_, SyncthingState>,
    folder_id: String,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/folders/{}",
        state.config.host, state.config.port, folder_id
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

/// Get detailed device configuration
#[tauri::command]
pub async fn get_device_config(
    state: State<'_, SyncthingState>,
    device_id: String,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/devices/{}",
        state.config.host, state.config.port, device_id
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

/// Open folder in file explorer
#[tauri::command]
pub async fn open_folder_in_explorer(folder_path: String) -> Result<(), SyncthingError> {
    use std::process::Command;
    
    #[cfg(target_os = "linux")]
    {
        Command::new("xdg-open")
            .arg(&folder_path)
            .spawn()
            .map_err(|e| SyncthingError::ProcessError(format!("Failed to open folder: {}", e)))?;
    }

    #[cfg(target_os = "macos")]
    {
        Command::new("open")
            .arg(&folder_path)
            .spawn()
            .map_err(|e| SyncthingError::ProcessError(format!("Failed to open folder: {}", e)))?;
    }

    #[cfg(target_os = "windows")]
    {
        Command::new("explorer")
            .arg(&folder_path)
            .spawn()
            .map_err(|e| SyncthingError::ProcessError(format!("Failed to open folder: {}", e)))?;
    }

    Ok(())
}

/// Browse files in a folder (list directory contents)
/// This version returns immediate children only (for file browser UI)
#[tauri::command]
pub async fn browse_folder(
    state: State<'_, SyncthingState>,
    folder_id: String,
    prefix: Option<String>,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let mut url = format!(
        "http://{}:{}/rest/db/browse?folder={}&levels=0",
        state.config.host, state.config.port, folder_id
    );

    if let Some(p) = prefix {
        url = format!("{}&prefix={}", url, p);
    }

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

/// Browse all files in a folder recursively (for indexing)
/// Returns a flat list of all files with their full paths
#[tauri::command]
pub async fn browse_folder_recursive(
    state: State<'_, SyncthingState>,
    folder_id: String,
) -> Result<Vec<serde_json::Value>, SyncthingError> {
    let client = reqwest::Client::new();
    // Use a high levels value to get deep recursion
    let url = format!(
        "http://{}:{}/rest/db/browse?folder={}&levels=999",
        state.config.host, state.config.port, folder_id
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Flatten the hierarchical structure into a flat list
    let mut files = Vec::new();
    if let Some(arr) = json.as_array() {
        flatten_browse_response(arr, "", &mut files);
    }

    Ok(files)
}

/// Helper function to flatten the nested browse response
fn flatten_browse_response(items: &[serde_json::Value], parent_path: &str, result: &mut Vec<serde_json::Value>) {
    for item in items {
        if let Some(obj) = item.as_object() {
            let name = obj.get("name").and_then(|n| n.as_str()).unwrap_or("");
            let full_path = if parent_path.is_empty() {
                name.to_string()
            } else {
                format!("{}/{}", parent_path, name)
            };
            
            let item_type = obj.get("type").and_then(|t| t.as_str()).unwrap_or("");
            let is_directory = item_type == "FILE_INFO_TYPE_DIRECTORY";
            
            // Add the item with its full path
            let flat_item = serde_json::json!({
                "name": full_path,
                "size": obj.get("size").and_then(|s| s.as_i64()).unwrap_or(0),
                "modTime": obj.get("modTime").cloned().unwrap_or(serde_json::Value::Null),
                "type": if is_directory { "directory" } else { "file" }
            });
            
            result.push(flat_item);
            
            // Recursively process children
            if let Some(children) = obj.get("children").and_then(|c| c.as_array()) {
                flatten_browse_response(children, &full_path, result);
            }
        }
    }
}

// ============================================================================
// File Conflict Resolution
// ============================================================================

/// Get list of conflict files for a folder by scanning the filesystem
#[tauri::command]
pub async fn scan_for_conflicts(
    folder_path: String,
) -> Result<Vec<serde_json::Value>, SyncthingError> {
    let mut conflicts = Vec::new();
    
    fn scan_dir(dir: &std::path::Path, conflicts: &mut Vec<serde_json::Value>, base: &std::path::Path) {
        if let Ok(entries) = std::fs::read_dir(dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                if path.is_dir() {
                    // Skip hidden directories and .stversions
                    if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                        if !name.starts_with('.') && name != ".stversions" {
                            scan_dir(&path, conflicts, base);
                        }
                    }
                } else if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                    if name.contains(".sync-conflict-") {
                        let relative_path = path.strip_prefix(base).unwrap_or(&path);
                        if let Ok(metadata) = std::fs::metadata(&path) {
                            // Extract original filename from conflict pattern
                            // Pattern: filename.sync-conflict-YYYYMMDD-HHMMSS-DEVICEID.ext
                            let original = extract_original_filename(name);
                            conflicts.push(serde_json::json!({
                                "name": relative_path.to_string_lossy(),
                                "original": original,
                                "size": metadata.len(),
                                "modTime": metadata.modified().ok().map(|t| {
                                    let duration = t.duration_since(std::time::UNIX_EPOCH).unwrap_or_default();
                                    duration.as_secs()
                                }),
                            }));
                        }
                    }
                }
            }
        }
    }
    
    fn extract_original_filename(conflict_name: &str) -> String {
        // Pattern: file.sync-conflict-20231201-120000-ABCDEFG.txt
        // Should become: file.txt
        if let Some(pos) = conflict_name.find(".sync-conflict-") {
            let before = &conflict_name[..pos];
            // Find the extension after the conflict marker
            let after = &conflict_name[pos..];
            if let Some(ext_pos) = after.rfind('.') {
                let ext = &after[ext_pos..];
                return format!("{}{}", before, ext);
            }
            return before.to_string();
        }
        conflict_name.to_string()
    }

    let base = std::path::Path::new(&folder_path);
    if base.exists() {
        scan_dir(base, &mut conflicts, base);
    }

    Ok(conflicts)
}

/// Delete a conflict file (resolve by keeping the original)
#[tauri::command]
pub async fn delete_conflict_file(
    folder_path: String,
    conflict_file: String,
) -> Result<(), SyncthingError> {
    let full_path = std::path::Path::new(&folder_path).join(&conflict_file);
    
    if full_path.exists() {
        std::fs::remove_file(&full_path)
            .map_err(|e| SyncthingError::ProcessError(format!("Failed to delete conflict file: {}", e)))?;
    }

    Ok(())
}

/// Resolve conflict by replacing original with conflict file
#[tauri::command]
pub async fn resolve_conflict_keep_conflict(
    folder_path: String,
    original_file: String,
    conflict_file: String,
) -> Result<(), SyncthingError> {
    let base_path = std::path::Path::new(&folder_path);
    let original_path = base_path.join(&original_file);
    let conflict_path = base_path.join(&conflict_file);
    
    // Delete original if it exists
    if original_path.exists() {
        std::fs::remove_file(&original_path)
            .map_err(|e| SyncthingError::ProcessError(format!("Failed to delete original: {}", e)))?;
    }

    // Rename conflict to original
    if conflict_path.exists() {
        std::fs::rename(&conflict_path, &original_path)
            .map_err(|e| SyncthingError::ProcessError(format!("Failed to rename conflict file: {}", e)))?;
    }

    Ok(())
}

// ============================================================================
// File Versioning
// ============================================================================

/// Browse the .stversions folder for old file versions
#[tauri::command]
pub async fn browse_versions(
    folder_path: String,
    prefix: Option<String>,
) -> Result<Vec<serde_json::Value>, SyncthingError> {
    use std::path::Path;
    use std::fs;

    let versions_path = Path::new(&folder_path).join(".stversions");
    let browse_path = if let Some(ref p) = prefix {
        versions_path.join(p)
    } else {
        versions_path.clone()
    };

    if !browse_path.exists() {
        return Ok(Vec::new());
    }

    let mut entries = Vec::new();
    
    if let Ok(dir_entries) = fs::read_dir(&browse_path) {
        for entry in dir_entries.flatten() {
            let path = entry.path();
            let name = path.file_name()
                .and_then(|n| n.to_str())
                .unwrap_or("")
                .to_string();

            if let Ok(metadata) = entry.metadata() {
                let is_dir = metadata.is_dir();
                
                // Parse version timestamp from filename if it's a file
                // Pattern: filename~YYYYMMDD-HHMMSS.ext
                let (original_name, version_time) = if !is_dir {
                    parse_version_filename(&name)
                } else {
                    (name.clone(), None)
                };

                entries.push(serde_json::json!({
                    "name": name,
                    "originalName": original_name,
                    "type": if is_dir { "directory" } else { "file" },
                    "size": if is_dir { None::<u64> } else { Some(metadata.len()) },
                    "modTime": metadata.modified().ok().map(|t| {
                        t.duration_since(std::time::UNIX_EPOCH)
                            .map(|d| d.as_secs())
                            .unwrap_or(0)
                    }),
                    "versionTime": version_time,
                }));
            }
        }
    }

    // Sort: directories first, then by modification time (newest first)
    entries.sort_by(|a, b| {
        let a_is_dir = a["type"].as_str() == Some("directory");
        let b_is_dir = b["type"].as_str() == Some("directory");
        
        if a_is_dir != b_is_dir {
            return if a_is_dir { std::cmp::Ordering::Less } else { std::cmp::Ordering::Greater };
        }
        
        let a_time = a["modTime"].as_u64().unwrap_or(0);
        let b_time = b["modTime"].as_u64().unwrap_or(0);
        b_time.cmp(&a_time)
    });

    Ok(entries)
}

/// Parse versioned filename to extract original name and version timestamp
fn parse_version_filename(name: &str) -> (String, Option<String>) {
    // Pattern: filename~YYYYMMDD-HHMMSS.ext or filename~YYYYMMDD-HHMMSS
    // Example: document~20231215-143022.pdf -> (document.pdf, 2023-12-15 14:30:22)
    
    if let Some(tilde_pos) = name.rfind('~') {
        let before_tilde = &name[..tilde_pos];
        let after_tilde = &name[tilde_pos + 1..];
        
        // Check if after_tilde matches version pattern
        let version_part: String;
        let extension: &str;
        
        if let Some(dot_pos) = after_tilde.find('.') {
            version_part = after_tilde[..dot_pos].to_string();
            extension = &after_tilde[dot_pos..];
        } else {
            version_part = after_tilde.to_string();
            extension = "";
        }
        
        // Validate version format: YYYYMMDD-HHMMSS (15 chars)
        if version_part.len() == 15 && version_part.chars().nth(8) == Some('-') {
            let original = format!("{}{}", before_tilde, extension);
            
            // Format the timestamp nicely
            let formatted = format!(
                "{}-{}-{} {}:{}:{}",
                &version_part[0..4],   // Year
                &version_part[4..6],   // Month
                &version_part[6..8],   // Day
                &version_part[9..11],  // Hour
                &version_part[11..13], // Minute
                &version_part[13..15]  // Second
            );
            
            return (original, Some(formatted));
        }
    }
    
    (name.to_string(), None)
}

/// Restore a versioned file to its original location
#[tauri::command]
pub async fn restore_version(
    folder_path: String,
    version_path: String,
    original_name: String,
    overwrite: bool,
) -> Result<(), SyncthingError> {
    use std::path::Path;
    use std::fs;

    let source = Path::new(&folder_path).join(".stversions").join(&version_path);
    let dest = Path::new(&folder_path).join(&original_name);

    if !source.exists() {
        return Err(SyncthingError::ProcessError("Version file not found".to_string()));
    }

    if dest.exists() && !overwrite {
        return Err(SyncthingError::ProcessError(
            "Destination file exists. Set overwrite=true to replace.".to_string()
        ));
    }

    // Create parent directories if needed
    if let Some(parent) = dest.parent() {
        fs::create_dir_all(parent)
            .map_err(|e| SyncthingError::ProcessError(format!("Failed to create directories: {}", e)))?;
    }

    // Copy the version file to the original location
    fs::copy(&source, &dest)
        .map_err(|e| SyncthingError::ProcessError(format!("Failed to restore file: {}", e)))?;

    Ok(())
}

// ============================================================================
// Tray Status Update
// ============================================================================

/// Update the system tray tooltip with current status
#[tauri::command]
pub async fn update_tray_status(
    app: tauri::AppHandle,
    _status: String,
    tooltip: String,
) -> Result<(), SyncthingError> {
    // Update the tray tooltip
    if let Some(tray) = app.tray_by_id("main") {
        let _ = tray.set_tooltip(Some(&tooltip));
    }
    
    // Note: Tauri v2 menu items are immutable after creation,
    // so we update via the tooltip instead
    
    Ok(())
}
</file>

<file path="src-tauri/src/main.rs">
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
    eigen_lib::run()
}
</file>

<file path="src-tauri/.gitignore">
# Generated by Cargo
# will have compiled files and executables
/target/

# Generated by Tauri
# will have schema files for capabilities auto-completion
/gen/schemas
</file>

<file path="src-tauri/build.rs">
fn main() {
    tauri_build::build()
}
</file>

<file path="src-tauri/clippy.toml">
# Clippy configuration for the Tauri project
# This file configures Clippy lints for the project
# Run with: cargo clippy -- -D warnings

# Allow common patterns in Tauri apps
allow-dbg-in-tests = true

# Configure lint behavior
avoid-breaking-exported-api = true
cognitive-complexity-threshold = 25
msrv = "1.70.0"
</file>

<file path="src-tauri/rustfmt.toml">
# Rustfmt configuration for the Tauri project
# See https://rust-lang.github.io/rustfmt/

edition = "2021"
max_width = 100
tab_spaces = 4
use_small_heuristics = "Default"
newline_style = "Unix"

# Import formatting
imports_granularity = "Crate"
group_imports = "StdExternalCrate"
reorder_imports = true
reorder_modules = true

# Function/struct formatting
fn_args_layout = "Tall"
struct_lit_single_line = true
where_single_line = false

# Comments
wrap_comments = false
comment_width = 100
normalize_comments = false

# Chains and match arms
chain_width = 60
match_block_trailing_comma = true
match_arm_leading_pipes = "Never"

# Misc
use_field_init_shorthand = true
use_try_shorthand = true
force_multiline_blocks = false
format_strings = false
</file>

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path=".prettierignore">
# Dependencies
node_modules/
.pnpm-store/

# Build outputs
.next/
out/
dist/
build/

# Tauri
src-tauri/target/
src-tauri/gen/

# Package manager files
pnpm-lock.yaml
package-lock.json
yarn.lock

# IDE/Editor
.vscode/
.idea/

# Other
*.min.js
*.min.css
coverage/
</file>

<file path=".prettierrc">
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 100,
  "bracketSpacing": true,
  "arrowParens": "always",
  "endOfLine": "lf",
  "plugins": ["prettier-plugin-tailwindcss"]
}
</file>

<file path="eslint.config.mjs">
import js from '@eslint/js';
import nextPlugin from '@next/eslint-plugin-next';
import reactPlugin from 'eslint-plugin-react';
import reactHooksPlugin from 'eslint-plugin-react-hooks';
import typescriptPlugin from '@typescript-eslint/eslint-plugin';
import typescriptParser from '@typescript-eslint/parser';
import prettierConfig from 'eslint-config-prettier';
import prettierPlugin from 'eslint-plugin-prettier';
import globals from 'globals';

export default [
  // Ignore patterns
  {
    ignores: [
      'node_modules/**',
      '.next/**',
      'out/**',
      'dist/**',
      'build/**',
      'src-tauri/target/**',
      'src-tauri/gen/**',
      '*.min.js',
      'coverage/**',
      'public/**',
      'next-env.d.ts',
    ],
  },

  // Base JavaScript/TypeScript config
  js.configs.recommended,

  // TypeScript files
  {
    files: ['**/*.ts', '**/*.tsx'],
    languageOptions: {
      parser: typescriptParser,
      parserOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module',
        ecmaFeatures: {
          jsx: true,
        },
      },
      globals: {
        ...globals.browser,
        ...globals.node,
        React: 'readonly',
      },
    },
    plugins: {
      '@typescript-eslint': typescriptPlugin,
      react: reactPlugin,
      'react-hooks': reactHooksPlugin,
      '@next/next': nextPlugin,
      prettier: prettierPlugin,
    },
    rules: {
      // TypeScript rules
      ...typescriptPlugin.configs.recommended.rules,
      '@typescript-eslint/no-unused-vars': [
        'warn',
        {
          argsIgnorePattern: '^_',
          varsIgnorePattern: '^_',
        },
      ],
      '@typescript-eslint/no-explicit-any': 'warn',
      '@typescript-eslint/explicit-function-return-type': 'off',
      '@typescript-eslint/explicit-module-boundary-types': 'off',
      '@typescript-eslint/no-empty-object-type': 'off',

      // React rules
      ...reactPlugin.configs.recommended.rules,
      'react/react-in-jsx-scope': 'off',
      'react/prop-types': 'off',
      'react/no-unescaped-entities': 'warn',

      // React Hooks rules
      ...reactHooksPlugin.configs.recommended.rules,

      // Next.js rules
      ...nextPlugin.configs.recommended.rules,
      ...nextPlugin.configs['core-web-vitals'].rules,

      // Prettier
      'prettier/prettier': 'warn',

      // General rules
      'no-console': ['warn', { allow: ['warn', 'error'] }],
      'no-unused-vars': 'off', // Use TypeScript's version
    },
    settings: {
      react: {
        version: 'detect',
      },
    },
  },

  // JavaScript files
  {
    files: ['**/*.js', '**/*.mjs', '**/*.cjs'],
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.browser,
      },
    },
    plugins: {
      prettier: prettierPlugin,
    },
    rules: {
      'prettier/prettier': 'warn',
      'no-unused-vars': [
        'warn',
        {
          argsIgnorePattern: '^_',
          varsIgnorePattern: '^_',
        },
      ],
    },
  },

  // Prettier config (disables conflicting rules)
  prettierConfig,
];
</file>

<file path="postcss.config.mjs">
export default {
  plugins: {
    '@tailwindcss/postcss': {},
  },
};
</file>

<file path="scripts/download-syncthing.js">
#!/usr/bin/env node
/**
 * Downloads the Syncthing binary for the current platform
 * and places it in the src-tauri/binaries folder with the correct target triple name.
 */

import { execSync } from 'child_process';
import fs from 'fs';
import https from 'https';
import path from 'path';
import { fileURLToPath } from 'url';
import { createGunzip } from 'zlib';
import { pipeline } from 'stream/promises';
import { createWriteStream } from 'fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SYNCTHING_VERSION = 'v1.27.12';

// Map of Rust target triples to Syncthing release names
const PLATFORM_MAP = {
  'x86_64-unknown-linux-gnu': { os: 'linux', arch: 'amd64' },
  'aarch64-unknown-linux-gnu': { os: 'linux', arch: 'arm64' },
  'x86_64-apple-darwin': { os: 'macos', arch: 'amd64' },
  'aarch64-apple-darwin': { os: 'macos', arch: 'arm64' },
  'x86_64-pc-windows-msvc': { os: 'windows', arch: 'amd64' },
};

async function getTargetTriple() {
  const rustInfo = execSync('rustc -vV').toString();
  const match = /host: (\S+)/.exec(rustInfo);
  if (!match) {
    throw new Error('Failed to determine platform target triple');
  }
  return match[1];
}

async function downloadFile(url, destPath) {
  return new Promise((resolve, reject) => {
    const file = createWriteStream(destPath);
    https
      .get(url, (response) => {
        if (response.statusCode === 302 || response.statusCode === 301) {
          // Follow redirect
          https
            .get(response.headers.location, (redirectResponse) => {
              redirectResponse.pipe(file);
              file.on('finish', () => {
                file.close();
                resolve();
              });
            })
            .on('error', reject);
        } else {
          response.pipe(file);
          file.on('finish', () => {
            file.close();
            resolve();
          });
        }
      })
      .on('error', reject);
  });
}

async function extractTarGz(tarGzPath, destDir) {
  execSync(`tar -xzf "${tarGzPath}" -C "${destDir}"`);
}

async function extractZip(zipPath, destDir) {
  execSync(`unzip -o "${zipPath}" -d "${destDir}"`);
}

async function main() {
  try {
    const targetTriple = await getTargetTriple();
    console.log(`Target triple: ${targetTriple}`);

    const platformInfo = PLATFORM_MAP[targetTriple];
    if (!platformInfo) {
      throw new Error(`Unsupported platform: ${targetTriple}`);
    }

    const binariesDir = path.join(__dirname, '..', 'src-tauri', 'binaries');
    const tempDir = path.join(__dirname, '..', 'temp');

    // Create directories
    fs.mkdirSync(binariesDir, { recursive: true });
    fs.mkdirSync(tempDir, { recursive: true });

    const extension = platformInfo.os === 'windows' ? '.exe' : '';
    const archiveExt = platformInfo.os === 'windows' ? 'zip' : 'tar.gz';
    const archiveName = `syncthing-${platformInfo.os}-${platformInfo.arch}-${SYNCTHING_VERSION}`;
    const downloadUrl = `https://github.com/syncthing/syncthing/releases/download/${SYNCTHING_VERSION}/${archiveName}.${archiveExt}`;

    console.log(
      `Downloading Syncthing ${SYNCTHING_VERSION} for ${platformInfo.os}-${platformInfo.arch}...`
    );
    console.log(`URL: ${downloadUrl}`);

    const archivePath = path.join(tempDir, `${archiveName}.${archiveExt}`);

    // Download the archive
    await downloadFile(downloadUrl, archivePath);
    console.log('Download complete.');

    // Extract
    console.log('Extracting...');
    if (platformInfo.os === 'windows') {
      await extractZip(archivePath, tempDir);
    } else {
      await extractTarGz(archivePath, tempDir);
    }

    // Move binary to binaries folder with correct name
    const sourceBinary = path.join(tempDir, archiveName, `syncthing${extension}`);
    const destBinary = path.join(binariesDir, `syncthing-${targetTriple}${extension}`);

    console.log(`Moving binary to ${destBinary}`);
    fs.copyFileSync(sourceBinary, destBinary);

    // Make executable on Unix
    if (platformInfo.os !== 'windows') {
      fs.chmodSync(destBinary, 0o755);
    }

    // Cleanup
    fs.rmSync(tempDir, { recursive: true, force: true });

    console.log('Syncthing binary installed successfully!');
    console.log(`Binary location: ${destBinary}`);
  } catch (error) {
    console.error('Error:', error.message);
    process.exit(1);
  }
}

main();
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import { Providers } from '@/components/providers';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'Eigen - Modern Syncthing Manager',
  description: 'A beautiful, modern Syncthing manager built with Tauri and Next.js',
  icons: {
    icon: [
      { url: '/favicon.ico', sizes: '32x32' },
      { url: '/icon-192.png', sizes: '192x192', type: 'image/png' },
      { url: '/icon-512.png', sizes: '512x512', type: 'image/png' },
    ],
    apple: '/apple-touch-icon.png',
  },
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en" className="dark">
      <body className={`${inter.className} bg-slate-950 antialiased`}>
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
</file>

<file path="src/components/ui/motion.tsx">
'use client';

import { motion, Variants } from 'framer-motion';
import { ReactNode } from 'react';

// Animation variants for cards
export const cardVariants: Variants = {
  hidden: {
    opacity: 0,
    y: 20,
    scale: 0.95,
  },
  visible: {
    opacity: 1,
    y: 0,
    scale: 1,
    transition: {
      type: 'spring',
      stiffness: 300,
      damping: 30,
    },
  },
  exit: {
    opacity: 0,
    y: -10,
    scale: 0.95,
    transition: {
      duration: 0.2,
    },
  },
};

// Animation variants for list items with stagger
export const listContainerVariants: Variants = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: {
      staggerChildren: 0.08,
      delayChildren: 0.1,
    },
  },
};

export const listItemVariants: Variants = {
  hidden: {
    opacity: 0,
    x: -20,
  },
  visible: {
    opacity: 1,
    x: 0,
    transition: {
      type: 'spring',
      stiffness: 400,
      damping: 25,
    },
  },
};

// Animation variants for page transitions
export const pageVariants: Variants = {
  hidden: {
    opacity: 0,
    y: 10,
  },
  visible: {
    opacity: 1,
    y: 0,
    transition: {
      duration: 0.3,
      ease: 'easeOut',
    },
  },
  exit: {
    opacity: 0,
    y: -10,
    transition: {
      duration: 0.2,
    },
  },
};

// Fade in animation
export const fadeInVariants: Variants = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: {
      duration: 0.4,
    },
  },
};

// Scale animation for buttons and interactive elements
export const scaleVariants: Variants = {
  initial: { scale: 1 },
  hover: { scale: 1.02 },
  tap: { scale: 0.98 },
};

// Animated container component for lists
interface MotionListProps {
  children: ReactNode;
  className?: string;
}

export function MotionList({ children, className }: MotionListProps) {
  return (
    <motion.div
      variants={listContainerVariants}
      initial="hidden"
      animate="visible"
      className={className}
    >
      {children}
    </motion.div>
  );
}

// Animated item for list children
interface MotionItemProps {
  children: ReactNode;
  className?: string;
}

export function MotionItem({ children, className }: MotionItemProps) {
  return (
    <motion.div variants={listItemVariants} className={className}>
      {children}
    </motion.div>
  );
}

// Animated page wrapper
interface MotionPageProps {
  children: ReactNode;
  className?: string;
}

export function MotionPage({ children, className }: MotionPageProps) {
  return (
    <motion.div
      variants={pageVariants}
      initial="hidden"
      animate="visible"
      exit="exit"
      className={className}
    >
      {children}
    </motion.div>
  );
}

// Animated card wrapper
interface MotionCardProps {
  children: ReactNode;
  className?: string;
  layoutId?: string;
}

export function MotionCard({ children, className, layoutId }: MotionCardProps) {
  return (
    <motion.div
      variants={cardVariants}
      initial="hidden"
      animate="visible"
      exit="exit"
      layoutId={layoutId}
      whileHover={{
        y: -4,
        transition: { type: 'spring', stiffness: 400, damping: 25 },
      }}
      className={className}
    >
      {children}
    </motion.div>
  );
}

// Pulse animation for status indicators
export function PulseIndicator({
  color = 'bg-emerald-500',
  size = 'sm',
}: {
  color?: string;
  size?: 'sm' | 'md' | 'lg';
}) {
  const sizes = {
    sm: 'h-2 w-2',
    md: 'h-3 w-3',
    lg: 'h-4 w-4',
  };

  return (
    <span className="relative flex">
      <motion.span
        className={`absolute inline-flex h-full w-full rounded-full ${color} opacity-75`}
        animate={{
          scale: [1, 1.5, 1],
          opacity: [0.75, 0, 0.75],
        }}
        transition={{
          duration: 2,
          repeat: Infinity,
          ease: 'easeInOut',
        }}
      />
      <span className={`relative inline-flex rounded-full ${color} ${sizes[size]}`} />
    </span>
  );
}

// Export motion components for direct use
export { motion };
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from '@/lib/utils';

function Skeleton({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return <div className={cn('bg-primary/10 animate-pulse rounded-md', className)} {...props} />;
}

export { Skeleton };
</file>

<file path="src/components/device-list.tsx">
'use client';

import { useState } from 'react';
import {
  useConfig,
  useConnections,
  useRemoveDevice,
  usePauseDevice,
  useResumeDevice,
  useSystemStatus,
} from '@/hooks/useSyncthing';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Skeleton } from '@/components/ui/skeleton';
import {
  Laptop,
  Smartphone,
  Server,
  Wifi,
  WifiOff,
  Plus,
  Trash2,
  Loader2,
  Pause,
  Play,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { AddDeviceDialog, MyDeviceId } from './add-device-dialog';
import { toast } from 'sonner';

function DeviceCard({
  device,
  connectionInfo,
  isLocalDevice,
}: {
  device: { deviceID: string; name?: string; paused?: boolean };
  connectionInfo?: {
    connected?: boolean;
    address?: string;
    type?: string;
    clientVersion?: string;
  };
  isLocalDevice?: boolean;
}) {
  const removeDevice = useRemoveDevice();
  const pauseDevice = usePauseDevice();
  const resumeDevice = useResumeDevice();
  // Local device is always "connected" (it's this machine!)
  const isConnected = isLocalDevice ? true : connectionInfo?.connected;
  const isPaused = device.paused;

  const handleRemove = async () => {
    if (confirm(`Remove device "${device.name || device.deviceID.slice(0, 12)}"?`)) {
      try {
        await removeDevice.mutateAsync(device.deviceID);
        toast.success('Device removed');
      } catch {
        toast.error('Failed to remove device');
      }
    }
  };

  const handlePauseResume = async () => {
    try {
      if (isPaused) {
        await resumeDevice.mutateAsync(device.deviceID);
        toast.success(`Resumed syncing with ${device.name || 'device'}`);
      } else {
        await pauseDevice.mutateAsync(device.deviceID);
        toast.success(`Paused syncing with ${device.name || 'device'}`);
      }
    } catch {
      toast.error(`Failed to ${isPaused ? 'resume' : 'pause'} device`);
    }
  };

  const isPauseResumePending = pauseDevice.isPending || resumeDevice.isPending;

  const getDeviceIcon = () => {
    const type = connectionInfo?.type?.toLowerCase() || '';
    if (type.includes('mobile') || type.includes('phone')) {
      return Smartphone;
    }
    if (type.includes('server')) {
      return Server;
    }
    return Laptop;
  };

  const DeviceIcon = getDeviceIcon();

  return (
    <Card
      className={cn(
        'group border-slate-800 bg-slate-900/50 backdrop-blur-md transition-all',
        isPaused && 'opacity-60',
        isConnected && 'border-emerald-500/30'
      )}
    >
      <CardHeader className="pb-3">
        <div className="flex items-start justify-between">
          <div className="flex items-center gap-3">
            <div
              className={cn(
                'flex h-10 w-10 items-center justify-center rounded-lg',
                isConnected
                  ? 'bg-emerald-500/20'
                  : isLocalDevice
                    ? 'bg-violet-500/20'
                    : 'bg-slate-700/50'
              )}
            >
              <DeviceIcon
                className={cn(
                  'h-5 w-5',
                  isConnected
                    ? 'text-emerald-400'
                    : isLocalDevice
                      ? 'text-violet-400'
                      : 'text-slate-400'
                )}
              />
            </div>
            <div className="min-w-0 flex-1">
              <CardTitle className="flex items-center gap-2 truncate text-lg text-white">
                {device.name || 'Unknown Device'}
                {isLocalDevice && (
                  <Badge variant="outline" className="border-violet-500/50 text-xs text-violet-400">
                    This Device
                  </Badge>
                )}
              </CardTitle>
              <CardDescription className="font-mono text-xs text-slate-500">
                {device.deviceID.slice(0, 12)}...
              </CardDescription>
            </div>
          </div>
          <div className="flex items-center gap-2">
            {isPaused && <Badge variant="secondary">Paused</Badge>}
            {isConnected ? (
              <Wifi className="h-4 w-4 text-emerald-400" />
            ) : (
              <WifiOff className="h-4 w-4 text-slate-500" />
            )}
            {!isLocalDevice && (
              <>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={handlePauseResume}
                  disabled={isPauseResumePending}
                  className="h-8 w-8 text-slate-400 opacity-0 transition-opacity group-hover:opacity-100 hover:bg-amber-500/10 hover:text-amber-400"
                  title={isPaused ? 'Resume syncing' : 'Pause syncing'}
                >
                  {isPauseResumePending ? (
                    <Loader2 className="h-4 w-4 animate-spin" />
                  ) : isPaused ? (
                    <Play className="h-4 w-4" />
                  ) : (
                    <Pause className="h-4 w-4" />
                  )}
                </Button>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={handleRemove}
                  disabled={removeDevice.isPending}
                  className="h-8 w-8 text-slate-400 opacity-0 transition-opacity group-hover:opacity-100 hover:bg-red-500/10 hover:text-red-400"
                >
                  {removeDevice.isPending ? (
                    <Loader2 className="h-4 w-4 animate-spin" />
                  ) : (
                    <Trash2 className="h-4 w-4" />
                  )}
                </Button>
              </>
            )}
          </div>
        </div>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-2 gap-4 text-sm">
          <div>
            <p className="text-slate-400">Status</p>
            <p className="font-medium text-white">{isConnected ? 'Connected' : 'Disconnected'}</p>
          </div>
          {connectionInfo?.address && (
            <div>
              <p className="text-slate-400">Address</p>
              <p className="truncate font-mono text-xs text-white">{connectionInfo.address}</p>
            </div>
          )}
          {connectionInfo?.clientVersion && (
            <div>
              <p className="text-slate-400">Version</p>
              <p className="font-medium text-white">{connectionInfo.clientVersion}</p>
            </div>
          )}
          {connectionInfo?.type && (
            <div>
              <p className="text-slate-400">Connection</p>
              <p className="font-medium text-white">{connectionInfo.type}</p>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}

export function DeviceList() {
  const [showAddDialog, setShowAddDialog] = useState(false);
  const {
    data: config,
    isLoading: configLoading,
    isError: configError,
    isFetching: configFetching,
  } = useConfig();
  const { data: connections, isLoading: connectionsLoading } = useConnections();
  const { data: systemStatus } = useSystemStatus();

  // Only show skeleton on initial load, not on refetches
  const isInitialLoading = (configLoading || connectionsLoading) && !config;

  // Get local device ID from system status (this is the correct way)
  const localDeviceId = systemStatus?.myID;

  // Render content based on state
  const renderContent = () => {
    if (isInitialLoading) {
      return (
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {[1, 2, 3].map((i) => (
            <Card key={i} className="border-slate-800 bg-slate-900/50">
              <CardHeader>
                <div className="flex items-center gap-3">
                  <Skeleton className="h-10 w-10 rounded-lg" />
                  <div className="space-y-2">
                    <Skeleton className="h-5 w-32" />
                    <Skeleton className="h-3 w-24" />
                  </div>
                </div>
              </CardHeader>
              <CardContent>
                <div className="space-y-2">
                  <Skeleton className="h-4 w-full" />
                  <Skeleton className="h-4 w-3/4" />
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      );
    }

    if (configError || !config?.devices?.length) {
      return (
        <Card className="border-slate-800 bg-slate-900/50 backdrop-blur-md">
          <CardContent className="flex flex-col items-center justify-center py-12">
            <Laptop className="mb-4 h-12 w-12 text-slate-600" />
            <p className="text-lg font-medium text-slate-300">No devices configured</p>
            <p className="text-sm text-slate-500">Add devices to start syncing</p>
          </CardContent>
        </Card>
      );
    }

    return (
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {config.devices.map((device) => (
          <DeviceCard
            key={device.deviceID}
            device={device}
            connectionInfo={connections?.connections?.[device.deviceID]}
            isLocalDevice={device.deviceID === localDeviceId}
          />
        ))}
      </div>
    );
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-end gap-2">
        {configFetching && !isInitialLoading && (
          <Loader2 className="h-4 w-4 animate-spin text-slate-500" />
        )}
        <Button
          onClick={() => setShowAddDialog(true)}
          className="bg-violet-600 hover:bg-violet-700"
          disabled={isInitialLoading}
        >
          <Plus className="mr-2 h-4 w-4" />
          Add Device
        </Button>
      </div>
      {renderContent()}
      {/* Dialog is always rendered to preserve state */}
      <AddDeviceDialog open={showAddDialog} onClose={() => setShowAddDialog(false)} />
    </div>
  );
}
</file>

<file path="src/components/error-boundary.tsx">
'use client';

import React, { Component, ReactNode } from 'react';
import { logger } from '@/lib/logger';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { AlertTriangle, RefreshCw, Download } from 'lucide-react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: React.ErrorInfo) => void;
}

interface State {
  hasError: boolean;
  error: Error | null;
  errorInfo: React.ErrorInfo | null;
  errorCount: number;
}

export class ErrorBoundary extends Component<Props, State> {
  private autoRecoveryTimeout: ReturnType<typeof setTimeout> | null = null;

  constructor(props: Props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
      errorCount: 0,
    };
  }

  static getDerivedStateFromError(error: Error): Partial<State> {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // Log to our logger
    logger.error('React Error Boundary caught an error', {
      component: 'ErrorBoundary',
      error: {
        message: error.message,
        stack: error.stack,
        name: error.name,
      },
      componentStack: errorInfo.componentStack,
    });

    this.setState((prev) => ({
      errorInfo,
      errorCount: prev.errorCount + 1,
    }));

    // Call optional error handler
    this.props.onError?.(error, errorInfo);

    // Auto-recover if error count is low
    if (this.state.errorCount < 3) {
      this.autoRecoveryTimeout = setTimeout(() => {
        this.handleReset();
      }, 3000);
    }
  }

  componentWillUnmount() {
    if (this.autoRecoveryTimeout) {
      clearTimeout(this.autoRecoveryTimeout);
    }
  }

  handleReset = () => {
    if (this.autoRecoveryTimeout) {
      clearTimeout(this.autoRecoveryTimeout);
      this.autoRecoveryTimeout = null;
    }
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
    });
  };

  handleDownloadLogs = () => {
    logger.downloadLogs();
  };

  handleReload = () => {
    window.location.reload();
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="flex min-h-screen items-center justify-center bg-slate-950 p-4">
          <Card className="w-full max-w-2xl border-red-500/30 bg-slate-900">
            <CardHeader>
              <div className="flex items-center gap-3">
                <div className="flex h-12 w-12 items-center justify-center rounded-lg bg-red-500/20">
                  <AlertTriangle className="h-6 w-6 text-red-400" />
                </div>
                <div>
                  <CardTitle className="text-white">Something went wrong</CardTitle>
                  <p className="mt-1 text-sm text-slate-400">
                    The application encountered an unexpected error
                  </p>
                </div>
              </div>
            </CardHeader>
            <CardContent className="space-y-4">
              {/* Error Details */}
              <div className="rounded-lg bg-slate-800 p-4">
                <p className="mb-2 text-sm font-medium text-red-400">
                  {this.state.error?.name}: {this.state.error?.message}
                </p>
                <pre className="max-h-32 overflow-x-auto overflow-y-auto text-xs text-slate-400">
                  {this.state.error?.stack}
                </pre>
              </div>

              {/* Component Stack */}
              {this.state.errorInfo && (
                <details className="rounded-lg bg-slate-800 p-4">
                  <summary className="cursor-pointer text-sm font-medium text-slate-300 hover:text-slate-200">
                    Component Stack
                  </summary>
                  <pre className="mt-2 max-h-48 overflow-x-auto overflow-y-auto text-xs text-slate-400">
                    {this.state.errorInfo.componentStack}
                  </pre>
                </details>
              )}

              {/* Recovery count */}
              {this.state.errorCount > 0 && (
                <p className="text-xs text-slate-500">
                  Recovery attempt {this.state.errorCount} of 3
                  {this.state.errorCount < 3 && ' - Auto-recovering in 3s...'}
                </p>
              )}

              {/* Actions */}
              <div className="flex flex-wrap gap-2">
                <Button
                  onClick={this.handleReset}
                  className="flex-1 bg-indigo-600 hover:bg-indigo-700"
                >
                  <RefreshCw className="mr-2 h-4 w-4" />
                  Try Again
                </Button>
                <Button
                  onClick={this.handleDownloadLogs}
                  variant="outline"
                  className="border-slate-700 bg-slate-800 hover:bg-slate-700"
                >
                  <Download className="mr-2 h-4 w-4" />
                  Download Logs
                </Button>
                <Button
                  onClick={this.handleReload}
                  variant="outline"
                  className="border-slate-700 bg-slate-800 hover:bg-slate-700"
                >
                  Reload App
                </Button>
              </div>
            </CardContent>
          </Card>
        </div>
      );
    }

    return this.props.children;
  }
}

/**
 * HOC to wrap components with error boundary
 */
export function withErrorBoundary<P extends object>(
  WrappedComponent: React.ComponentType<P>,
  fallback?: ReactNode
) {
  return function WithErrorBoundary(props: P) {
    return (
      <ErrorBoundary fallback={fallback}>
        <WrappedComponent {...props} />
      </ErrorBoundary>
    );
  };
}
</file>

<file path="src/components/file-indexer.tsx">
'use client';

/**
 * FileIndexer - Component for indexing files into IndexedDB with AI embeddings
 */

import { useState, useCallback, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  Brain,
  RefreshCw,
  Loader2,
  CheckCircle2,
  AlertCircle,
  Database,
  Sparkles,
  Trash2,
} from 'lucide-react';
import { useConfig } from '@/hooks/useSyncthing';
import { useAISearch } from '@/hooks/useAISearch';
import { useAppStore } from '@/store';
import { invoke } from '@tauri-apps/api/core';
import {
  bulkUpsertFiles,
  getFileCount,
  clearFilesForFolder,
  getFilesWithoutEmbeddings,
  getAllEmbeddings,
  clearAllData,
  type FileMetadata,
} from '@/lib/db';
import { cn } from '@/lib/utils';

interface IndexingStatus {
  phase: 'idle' | 'scanning' | 'storing' | 'embedding' | 'complete' | 'error';
  message: string;
  folderId?: string;
  progress?: { current: number; total: number };
}

interface BrowseFile {
  name: string;
  size: number;
  modTime: string;
  type: string;
}

export function FileIndexer() {
  const [status, setStatus] = useState<IndexingStatus>({
    phase: 'idle',
    message: '',
  });
  const [totalFiles, setTotalFiles] = useState(0);
  const [totalEmbeddings, setTotalEmbeddings] = useState(0);

  const { data: config } = useConfig();
  const folders = config?.folders || [];

  const aiEnabled = useAppStore((state) => state.aiEnabled);
  const {
    status: aiStatus,
    statusMessage: aiStatusMessage,
    isReady,
    initialize,
    retry,
    indexFiles,
    progress: embeddingProgress,
  } = useAISearch({ enabled: aiEnabled });

  // Update stats on mount
  useEffect(() => {
    updateStats();
  }, []);

  // Update stats
  const updateStats = useCallback(async () => {
    try {
      const count = await getFileCount();
      setTotalFiles(count);
      const embeddings = await getAllEmbeddings();
      setTotalEmbeddings(embeddings.length);
    } catch (e) {
      console.error('Error updating stats:', e);
    }
  }, []);

  // Index a single folder
  const indexFolder = useCallback(
    async (folderId: string, folderLabel: string, folderPath: string) => {
      setStatus({
        phase: 'scanning',
        message: `Scanning ${folderLabel}...`,
        folderId,
      });

      try {
        // Get all files recursively from Syncthing using browse_folder_recursive command
        const files = await invoke<BrowseFile[]>('browse_folder_recursive', {
          folderId,
        });

        if (!files || files.length === 0) {
          return [];
        }

        setStatus({
          phase: 'storing',
          message: `Storing ${files.length} files from ${folderLabel}...`,
          folderId,
          progress: { current: 0, total: files.length },
        });

        // Clear existing files for this folder
        await clearFilesForFolder(folderId);

        // Transform to FileMetadata
        const fileMetadata: FileMetadata[] = files.map((f) => ({
          path: `${folderPath}/${f.name}`,
          name: f.name.split('/').pop() || f.name,
          folderId,
          folderPath,
          size: f.size || 0,
          modified: new Date(f.modTime || Date.now()).getTime(),
          isDirectory: f.type === 'directory' || f.name.endsWith('/'),
          extension: f.name.includes('.') ? f.name.split('.').pop() : undefined,
          indexed: Date.now(),
        }));

        // Store in IndexedDB
        await bulkUpsertFiles(fileMetadata);

        setStatus({
          phase: 'storing',
          message: `Stored ${files.length} files from ${folderLabel}`,
          folderId,
          progress: { current: files.length, total: files.length },
        });

        return fileMetadata.filter((f) => !f.isDirectory);
      } catch (error) {
        console.error(`Error indexing folder ${folderId}:`, error);
        throw error;
      }
    },
    []
  );

  // Index all folders
  const indexAllFolders = useCallback(async () => {
    if (!folders || folders.length === 0) {
      setStatus({ phase: 'error', message: 'No folders to index' });
      return;
    }

    const allFiles: { path: string; name: string }[] = [];

    try {
      for (const folder of folders) {
        if (!folder.path) continue;
        const files = await indexFolder(folder.id, folder.label || folder.id, folder.path);
        allFiles.push(...files.map((f) => ({ path: f.path, name: f.name })));
      }

      await updateStats();

      // Generate embeddings if AI is ready
      if (isReady && allFiles.length > 0) {
        setStatus({
          phase: 'embedding',
          message: `Generating embeddings for ${allFiles.length} files...`,
          progress: { current: 0, total: allFiles.length },
        });

        await indexFiles(allFiles);
        await updateStats();
      }

      setStatus({
        phase: 'complete',
        message: `Indexed ${allFiles.length} files from ${folders.length} folders`,
      });
    } catch (error) {
      setStatus({
        phase: 'error',
        message: error instanceof Error ? error.message : 'Indexing failed',
      });
    }
  }, [folders, indexFolder, isReady, indexFiles, updateStats]);

  // Generate embeddings for files without them
  const generateMissingEmbeddings = useCallback(async () => {
    if (!isReady) {
      await initialize();
      return;
    }

    try {
      const filesWithoutEmbeddings = await getFilesWithoutEmbeddings();

      if (filesWithoutEmbeddings.length === 0) {
        setStatus({
          phase: 'complete',
          message: 'All files already have embeddings',
        });
        return;
      }

      setStatus({
        phase: 'embedding',
        message: `Generating embeddings for ${filesWithoutEmbeddings.length} files...`,
        progress: { current: 0, total: filesWithoutEmbeddings.length },
      });

      await indexFiles(
        filesWithoutEmbeddings.map((f) => ({
          path: f.path,
          name: f.name,
        }))
      );
      await updateStats();

      setStatus({
        phase: 'complete',
        message: `Generated embeddings for ${filesWithoutEmbeddings.length} files`,
      });
    } catch (error) {
      setStatus({
        phase: 'error',
        message: error instanceof Error ? error.message : 'Embedding generation failed',
      });
    }
  }, [isReady, initialize, indexFiles, updateStats]);

  // Clear all indexed data
  const clearIndex = useCallback(async () => {
    try {
      await clearAllData();
      await updateStats();
      setStatus({
        phase: 'complete',
        message: 'Index cleared',
      });
    } catch (error) {
      setStatus({
        phase: 'error',
        message: 'Failed to clear index',
      });
    }
  }, [updateStats]);

  const isWorking =
    status.phase === 'scanning' || status.phase === 'storing' || status.phase === 'embedding';
  const currentProgress = status.phase === 'embedding' ? embeddingProgress : status.progress;

  return (
    <div className="bg-card border-border rounded-lg border p-4">
      <div className="mb-4 flex items-center gap-2">
        <Brain className="text-primary h-5 w-5" />
        <h3 className="font-semibold">AI File Index</h3>
      </div>

      {/* Stats */}
      <div className="mb-4 grid grid-cols-2 gap-3">
        <div className="bg-muted/50 rounded-lg p-3">
          <div className="text-muted-foreground mb-1 flex items-center gap-2 text-sm">
            <Database className="h-4 w-4" />
            <span>Indexed Files</span>
          </div>
          <p className="text-2xl font-bold">{totalFiles.toLocaleString()}</p>
        </div>
        <div className="bg-muted/50 rounded-lg p-3">
          <div className="text-muted-foreground mb-1 flex items-center gap-2 text-sm">
            <Sparkles className="h-4 w-4" />
            <span>Embeddings</span>
          </div>
          <p className="text-2xl font-bold">{totalEmbeddings.toLocaleString()}</p>
        </div>
      </div>

      {/* AI Status */}
      <div
        className={cn(
          'mb-4 rounded-lg p-2',
          aiStatus === 'ready'
            ? 'bg-green-500/10 text-green-600'
            : aiStatus === 'loading'
              ? 'bg-blue-500/10 text-blue-600'
              : aiStatus === 'error'
                ? 'bg-red-500/10 text-red-600'
                : 'bg-muted/50 text-muted-foreground'
        )}
      >
        <div className="flex items-center gap-2">
          {aiStatus === 'loading' && <Loader2 className="h-4 w-4 animate-spin" />}
          {aiStatus === 'ready' && <CheckCircle2 className="h-4 w-4" />}
          {aiStatus === 'error' && <AlertCircle className="h-4 w-4" />}
          {aiStatus === 'idle' && <Brain className="h-4 w-4" />}
          <span className="flex-1 text-sm">
            {aiStatus === 'ready'
              ? 'AI Model Ready'
              : aiStatus === 'loading'
                ? 'Loading AI Model...'
                : aiStatus === 'error'
                  ? 'AI Model Error'
                  : 'AI Model Idle'}
          </span>
          {aiStatus === 'error' && (
            <button
              onClick={retry}
              className="rounded bg-red-500/20 px-2 py-1 text-xs font-medium hover:bg-red-500/30"
            >
              Retry
            </button>
          )}
          {aiStatus === 'idle' && (
            <button
              onClick={initialize}
              className="text-primary rounded bg-blue-500/20 px-2 py-1 text-xs font-medium hover:bg-blue-500/30"
            >
              Load Model
            </button>
          )}
        </div>
        {aiStatus === 'error' && aiStatusMessage && (
          <p className="mt-1 text-xs opacity-80">{aiStatusMessage}</p>
        )}
      </div>

      {/* Status */}
      <AnimatePresence mode="wait">
        {status.phase !== 'idle' && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            className="mb-4"
          >
            <div
              className={cn(
                'flex items-center gap-2 rounded-lg p-3',
                status.phase === 'complete'
                  ? 'bg-green-500/10 text-green-600'
                  : status.phase === 'error'
                    ? 'bg-red-500/10 text-red-600'
                    : 'bg-blue-500/10 text-blue-600'
              )}
            >
              {isWorking && <Loader2 className="h-4 w-4 animate-spin" />}
              {status.phase === 'complete' && <CheckCircle2 className="h-4 w-4" />}
              {status.phase === 'error' && <AlertCircle className="h-4 w-4" />}
              <span className="flex-1 text-sm">{status.message}</span>
            </div>

            {currentProgress && (
              <div className="mt-2">
                <div className="text-muted-foreground mb-1 flex justify-between text-xs">
                  <span>Progress</span>
                  <span>
                    {currentProgress.current} / {currentProgress.total}
                  </span>
                </div>
                <div className="bg-muted h-2 overflow-hidden rounded-full">
                  <motion.div
                    className="bg-primary h-full"
                    initial={{ width: 0 }}
                    animate={{
                      width: `${(currentProgress.current / currentProgress.total) * 100}%`,
                    }}
                  />
                </div>
              </div>
            )}
          </motion.div>
        )}
      </AnimatePresence>

      {/* Actions */}
      <div className="flex flex-wrap gap-2">
        <button
          onClick={indexAllFolders}
          disabled={isWorking || !folders?.length}
          className={cn(
            'flex items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium',
            'bg-primary text-primary-foreground',
            'hover:bg-primary/90 transition-colors',
            'disabled:cursor-not-allowed disabled:opacity-50'
          )}
        >
          {isWorking ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <RefreshCw className="h-4 w-4" />
          )}
          Reindex All Folders
        </button>

        <button
          onClick={generateMissingEmbeddings}
          disabled={isWorking || !isReady}
          className={cn(
            'flex items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium',
            'bg-secondary text-secondary-foreground',
            'hover:bg-secondary/80 transition-colors',
            'disabled:cursor-not-allowed disabled:opacity-50'
          )}
        >
          <Sparkles className="h-4 w-4" />
          Generate Embeddings
        </button>

        <button
          onClick={clearIndex}
          disabled={isWorking}
          className={cn(
            'flex items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium',
            'bg-destructive/10 text-destructive',
            'hover:bg-destructive/20 transition-colors',
            'disabled:cursor-not-allowed disabled:opacity-50'
          )}
        >
          <Trash2 className="h-4 w-4" />
          Clear Index
        </button>
      </div>

      {/* Help text */}
      <p className="text-muted-foreground mt-4 text-xs">
        Index your synced folders to enable AI-powered semantic file search. The AI model runs
        locally in your browser for privacy.
      </p>
    </div>
  );
}
</file>

<file path="src/components/folder-list.tsx">
'use client';

import { useState } from 'react';
import {
  useConfig,
  useFolderStatus,
  usePauseFolder,
  useResumeFolder,
  useRescanFolder,
  useRemoveFolder,
  useOpenFolderInExplorer,
  useUnshareFolder,
  useSystemStatus,
} from '@/hooks/useSyncthing';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Skeleton } from '@/components/ui/skeleton';
import { formatBytes } from '@/lib/utils';
import {
  Folder,
  Pause,
  Play,
  RefreshCw,
  Trash2,
  Plus,
  Share2,
  FileX,
  FolderOpen,
  ExternalLink,
  AlertTriangle,
  Users,
  X,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { AddFolderDialog } from '@/components/add-folder-dialog';
import { ShareFolderDialog } from '@/components/share-folder-dialog';
import { IgnorePatternsDialog } from '@/components/ignore-patterns-dialog';
import { FileBrowser } from '@/components/file-browser';
import { ConflictResolver } from '@/components/conflict-resolver';
import { toast } from 'sonner';

function FolderCard({
  folder,
  devices,
  localDeviceId,
  onShare,
  onIgnorePatterns,
  onBrowse,
  onConflicts,
}: {
  folder: {
    id: string;
    label?: string;
    path?: string;
    paused?: boolean;
    devices?: { deviceID: string }[];
  };
  devices: { deviceID: string; name?: string }[];
  localDeviceId?: string;
  onShare: (id: string, label?: string) => void;
  onIgnorePatterns: (id: string, label?: string) => void;
  onBrowse: (id: string, path: string, label?: string) => void;
  onConflicts: (id: string, path: string, label?: string) => void;
}) {
  const { data: status, isLoading } = useFolderStatus(folder.id);
  const pauseFolder = usePauseFolder();
  const resumeFolder = useResumeFolder();
  const rescanFolder = useRescanFolder();
  const removeFolder = useRemoveFolder();
  const openInExplorer = useOpenFolderInExplorer();
  const unshareFolder = useUnshareFolder();

  const isPaused = folder.paused;
  const isSyncing = status?.state === 'syncing';
  const needsSync = (status?.needFiles || 0) > 0;

  // Get list of shared devices (excluding local device)
  const sharedDevices = (folder.devices || [])
    .filter((fd) => fd.deviceID !== localDeviceId)
    .map((fd) => {
      const device = devices.find((d) => d.deviceID === fd.deviceID);
      return {
        deviceID: fd.deviceID,
        name: device?.name || fd.deviceID.slice(0, 8) + '...',
      };
    });

  const handleUnshare = async (deviceId: string, deviceName: string) => {
    if (confirm(`Stop sharing "${folder.label || folder.id}" with "${deviceName}"?`)) {
      try {
        await unshareFolder.mutateAsync({
          folderId: folder.id,
          deviceId,
        });
        toast.success(`Stopped sharing with ${deviceName}`);
      } catch {
        toast.error('Failed to unshare folder');
      }
    }
  };

  const getStatusBadge = () => {
    if (isPaused) return <Badge variant="secondary">Paused</Badge>;
    if (isSyncing) return <Badge variant="warning">Syncing</Badge>;
    if (needsSync) return <Badge variant="warning">Needs Sync</Badge>;
    return <Badge variant="success">Up to Date</Badge>;
  };

  const handleTogglePause = () => {
    if (isPaused) {
      resumeFolder.mutate(folder.id);
    } else {
      pauseFolder.mutate(folder.id);
    }
  };

  const handleRescan = () => {
    rescanFolder.mutate(folder.id);
  };

  const handleRemove = async () => {
    if (
      confirm(
        `Remove folder "${folder.label || folder.id}"? This will not delete the files on disk.`
      )
    ) {
      try {
        await removeFolder.mutateAsync(folder.id);
        toast.success('Folder removed');
      } catch {
        toast.error('Failed to remove folder');
      }
    }
  };

  const handleOpenInExplorer = async () => {
    if (folder.path) {
      try {
        await openInExplorer.mutateAsync(folder.path);
        toast.success('Opened in file explorer');
      } catch {
        toast.error('Failed to open folder');
      }
    }
  };

  return (
    <Card
      className={cn(
        'border-slate-800 bg-slate-900/50 backdrop-blur-md transition-all',
        isPaused && 'opacity-60'
      )}
    >
      <CardHeader className="pb-3">
        <div className="flex items-start justify-between">
          <div className="flex items-center gap-3">
            <div className="flex h-10 w-10 items-center justify-center rounded-lg bg-indigo-500/20">
              <Folder className="h-5 w-5 text-indigo-400" />
            </div>
            <div>
              <CardTitle className="text-lg text-white">{folder.label || folder.id}</CardTitle>
              <CardDescription className="font-mono text-xs text-slate-500">
                {folder.path}
              </CardDescription>
            </div>
          </div>
          {getStatusBadge()}
        </div>
      </CardHeader>
      <CardContent>
        {isLoading ? (
          <div className="space-y-2">
            <Skeleton className="h-4 w-full" />
            <Skeleton className="h-4 w-3/4" />
          </div>
        ) : (
          <>
            <div className="mb-4 grid grid-cols-2 gap-4 text-sm">
              <div>
                <p className="text-slate-400">Local Files</p>
                <p className="font-medium text-white">
                  {status?.localFiles?.toLocaleString() || 0}
                </p>
              </div>
              <div>
                <p className="text-slate-400">Local Size</p>
                <p className="font-medium text-white">{formatBytes(status?.localBytes || 0)}</p>
              </div>
              <div>
                <p className="text-slate-400">Global Files</p>
                <p className="font-medium text-white">
                  {status?.globalFiles?.toLocaleString() || 0}
                </p>
              </div>
              <div>
                <p className="text-slate-400">Need Sync</p>
                <p className="font-medium text-white">
                  {status?.needFiles?.toLocaleString() || 0} files
                </p>
              </div>
            </div>

            {/* Shared Devices */}
            {sharedDevices.length > 0 && (
              <div className="mb-4">
                <div className="mb-2 flex items-center gap-2 text-sm text-slate-400">
                  <Users className="h-4 w-4" />
                  <span>Shared with</span>
                </div>
                <div className="flex flex-wrap gap-1.5">
                  {sharedDevices.map((device) => (
                    <Badge
                      key={device.deviceID}
                      variant="secondary"
                      className="group/badge flex items-center gap-1 pr-1 hover:bg-slate-600"
                    >
                      <span className="max-w-[100px] truncate">{device.name}</span>
                      <button
                        onClick={() => handleUnshare(device.deviceID, device.name)}
                        disabled={unshareFolder.isPending}
                        className="ml-0.5 rounded-full p-0.5 opacity-0 transition-opacity group-hover/badge:opacity-100 hover:bg-red-500/20 hover:text-red-400"
                        title="Stop sharing"
                      >
                        <X className="h-3 w-3" />
                      </button>
                    </Badge>
                  ))}
                </div>
              </div>
            )}

            {/* Primary Actions */}
            <div className="mb-2 flex gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={handleTogglePause}
                disabled={pauseFolder.isPending || resumeFolder.isPending}
                className="flex-1"
              >
                {isPaused ? (
                  <>
                    <Play className="mr-1 h-4 w-4" /> Resume
                  </>
                ) : (
                  <>
                    <Pause className="mr-1 h-4 w-4" /> Pause
                  </>
                )}
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={() => onShare(folder.id, folder.label)}
                className="text-indigo-400 hover:bg-indigo-500/10 hover:text-indigo-300"
                title="Share folder"
              >
                <Share2 className="h-4 w-4" />
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={handleRescan}
                disabled={rescanFolder.isPending || isPaused}
                title="Rescan"
              >
                <RefreshCw className={cn('h-4 w-4', rescanFolder.isPending && 'animate-spin')} />
              </Button>
            </div>

            {/* Secondary Actions */}
            <div className="flex gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={handleOpenInExplorer}
                disabled={openInExplorer.isPending || !folder.path}
                className="flex-1 text-slate-400 hover:text-slate-200"
                title="Open in file explorer"
              >
                <ExternalLink className="mr-1 h-4 w-4" />
                Open
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={() => folder.path && onBrowse(folder.id, folder.path, folder.label)}
                disabled={!folder.path}
                title="Browse files"
              >
                <FolderOpen className="h-4 w-4" />
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={() => folder.path && onConflicts(folder.id, folder.path, folder.label)}
                disabled={!folder.path}
                title="Resolve conflicts"
                className="text-amber-400 hover:bg-amber-500/10 hover:text-amber-300"
              >
                <AlertTriangle className="h-4 w-4" />
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={() => onIgnorePatterns(folder.id, folder.label)}
                title="Ignore patterns"
              >
                <FileX className="h-4 w-4" />
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={handleRemove}
                disabled={removeFolder.isPending}
                className="text-red-400 hover:bg-red-500/10 hover:text-red-300"
                title="Remove folder"
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </div>
          </>
        )}
      </CardContent>
    </Card>
  );
}

export function FolderList() {
  const [addDialogOpen, setAddDialogOpen] = useState(false);
  const [shareData, setShareData] = useState<{
    id: string;
    label?: string;
  } | null>(null);
  const [ignoreData, setIgnoreData] = useState<{
    id: string;
    label?: string;
  } | null>(null);
  const [browseData, setBrowseData] = useState<{
    id: string;
    path: string;
    label?: string;
  } | null>(null);
  const [conflictData, setConflictData] = useState<{
    id: string;
    path: string;
    label?: string;
  } | null>(null);
  const { data: config, isLoading, isError } = useConfig();
  const { data: systemStatus } = useSystemStatus();

  const localDeviceId = systemStatus?.myID;

  if (isLoading) {
    return (
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {[1, 2, 3].map((i) => (
          <Card key={i} className="border-slate-800 bg-slate-900/50">
            <CardHeader>
              <Skeleton className="h-6 w-32" />
              <Skeleton className="h-4 w-48" />
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                <Skeleton className="h-4 w-full" />
                <Skeleton className="h-4 w-3/4" />
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    );
  }

  if (isError || !config?.folders?.length) {
    return (
      <>
        <Card className="border-slate-800 bg-slate-900/50 backdrop-blur-md">
          <CardContent className="flex flex-col items-center justify-center py-12">
            <Folder className="mb-4 h-12 w-12 text-slate-600" />
            <p className="text-lg font-medium text-slate-300">No folders configured</p>
            <p className="mb-4 text-sm text-slate-500">Add folders to start syncing</p>
            <Button
              onClick={() => setAddDialogOpen(true)}
              className="bg-indigo-600 hover:bg-indigo-700"
            >
              <Plus className="mr-2 h-4 w-4" />
              Add Folder
            </Button>
          </CardContent>
        </Card>
        <AddFolderDialog open={addDialogOpen} onOpenChange={setAddDialogOpen} />
      </>
    );
  }

  return (
    <>
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {config.folders.map((folder) => (
          <FolderCard
            key={folder.id}
            folder={folder}
            devices={config.devices || []}
            localDeviceId={localDeviceId}
            onShare={(id, label) => setShareData({ id, label })}
            onIgnorePatterns={(id, label) => setIgnoreData({ id, label })}
            onBrowse={(id, path, label) => setBrowseData({ id, path, label })}
            onConflicts={(id, path, label) => setConflictData({ id, path, label })}
          />
        ))}
        {/* Add Folder Card */}
        <Card
          className="flex cursor-pointer items-center justify-center border-2 border-dashed border-slate-700 bg-slate-900/30 transition-colors hover:border-indigo-500/50 hover:bg-slate-800/50"
          onClick={() => setAddDialogOpen(true)}
        >
          <CardContent className="flex flex-col items-center justify-center py-12">
            <div className="flex h-12 w-12 items-center justify-center rounded-full bg-indigo-500/20">
              <Plus className="h-6 w-6 text-indigo-400" />
            </div>
            <p className="mt-3 text-sm font-medium text-slate-300">Add Folder</p>
          </CardContent>
        </Card>
      </div>
      <AddFolderDialog open={addDialogOpen} onOpenChange={setAddDialogOpen} />
      <ShareFolderDialog
        open={!!shareData}
        onOpenChange={(open) => !open && setShareData(null)}
        folderId={shareData?.id || ''}
        folderLabel={shareData?.label}
      />
      <IgnorePatternsDialog
        open={!!ignoreData}
        onOpenChange={(open) => !open && setIgnoreData(null)}
        folderId={ignoreData?.id || ''}
        folderLabel={ignoreData?.label}
      />
      <FileBrowser
        open={!!browseData}
        onOpenChange={(open) => !open && setBrowseData(null)}
        folderId={browseData?.id || ''}
        folderPath={browseData?.path || ''}
        folderLabel={browseData?.label}
      />
      <ConflictResolver
        open={!!conflictData}
        onOpenChange={(open) => !open && setConflictData(null)}
        folderId={conflictData?.id || ''}
        folderPath={conflictData?.path || ''}
        folderLabel={conflictData?.label}
      />
    </>
  );
}
</file>

<file path="src/components/header.tsx">
'use client';

import { useAppStore } from '@/store';
import { useSystemStatus } from '@/hooks/useSyncthing';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { AISearchBar } from '@/components/ai-search-bar';
import { RefreshCw, Wifi, WifiOff } from 'lucide-react';

export function Header() {
  const { activeTab, setActiveTab } = useAppStore();
  const { data: status, isError, refetch, isRefetching } = useSystemStatus();

  const isOnline = !isError && status?.myID;

  const titles: Record<string, string> = {
    dashboard: 'Dashboard',
    folders: 'Folders',
    devices: 'Devices',
    settings: 'Settings',
  };

  const handleSearchResultSelect = (path: string) => {
    // Navigate to folders tab and potentially open file browser
    setActiveTab('folders');
    // TODO: Open file browser at the selected path
    console.log('Selected file:', path);
  };

  return (
    <header className="relative z-50 flex h-16 items-center justify-between border-b border-slate-800 bg-slate-950/50 px-6 backdrop-blur-xl">
      <div className="flex items-center gap-4">
        <h1 className="text-xl font-semibold text-white">{titles[activeTab] || 'Dashboard'}</h1>
      </div>

      {/* AI Search Bar */}
      <div className="relative z-50 mx-4 max-w-md flex-1">
        <AISearchBar onResultSelect={handleSearchResultSelect} className="w-full" />
      </div>

      <div className="flex items-center gap-3">
        {/* Connection Status */}
        <div className="flex items-center gap-2">
          {isOnline ? (
            <Wifi className="h-4 w-4 text-emerald-400" />
          ) : (
            <WifiOff className="h-4 w-4 text-red-400" />
          )}
          <Badge variant={isOnline ? 'success' : 'destructive'}>
            {isOnline ? 'Connected' : 'Offline'}
          </Badge>
        </div>

        {/* Refresh Button */}
        <Button
          variant="ghost"
          size="icon"
          onClick={() => refetch()}
          disabled={isRefetching}
          className="h-8 w-8 text-slate-400 hover:text-white"
          title="Refresh status"
        >
          <RefreshCw className={`h-4 w-4 ${isRefetching ? 'animate-spin' : ''}`} />
        </Button>
      </div>
    </header>
  );
}
</file>

<file path="src/components/logs-page.tsx">
'use client';

import { useState, useEffect, useRef } from 'react';
import { useSystemLogs, LogEntry } from '@/hooks/useSyncthing';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import {
  RefreshCw,
  AlertCircle,
  AlertTriangle,
  Info,
  Bug,
  Download,
  Trash2,
  ChevronDown,
} from 'lucide-react';
import { cn } from '@/lib/utils';

type LogLevel = 'all' | 'error' | 'warning' | 'info' | 'debug';

const levelConfig: Record<string, { icon: typeof Info; color: string; bg: string }> = {
  error: { icon: AlertCircle, color: 'text-red-500', bg: 'bg-red-500/10' },
  warning: {
    icon: AlertTriangle,
    color: 'text-yellow-500',
    bg: 'bg-yellow-500/10',
  },
  info: { icon: Info, color: 'text-blue-500', bg: 'bg-blue-500/10' },
  debug: { icon: Bug, color: 'text-gray-500', bg: 'bg-gray-500/10' },
  verbose: { icon: Bug, color: 'text-gray-400', bg: 'bg-gray-400/10' },
};

export function LogsPage() {
  const [filter, setFilter] = useState<LogLevel>('all');
  const [autoScroll, setAutoScroll] = useState(true);
  const logContainerRef = useRef<HTMLDivElement>(null);

  const { data: logs, isLoading, refetch, isRefetching } = useSystemLogs();

  // Auto-scroll to bottom when new logs arrive
  useEffect(() => {
    if (autoScroll && logContainerRef.current) {
      logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
    }
  }, [logs, autoScroll]);

  const logEntries = logs?.messages || [];

  // Convert numeric log level to string
  const getLevelString = (level?: number): string => {
    if (level === undefined) return 'info';
    // Syncthing log levels: 0=debug, 1=verbose, 2=info, 3=warning, 4=error
    switch (level) {
      case 0:
        return 'debug';
      case 1:
        return 'verbose';
      case 2:
        return 'info';
      case 3:
        return 'warning';
      case 4:
        return 'error';
      default:
        return 'info';
    }
  };

  const filteredLogs = logEntries.filter((log) => {
    if (filter === 'all') return true;
    const level = getLevelString(log.level);
    return level === filter;
  });

  const getLogLevel = (log: { level?: number; message?: string }): string => {
    if (log.level !== undefined) return getLevelString(log.level);
    // Try to infer from message
    const msg = log.message?.toLowerCase() || '';
    if (msg.includes('error') || msg.includes('failed')) return 'error';
    if (msg.includes('warning') || msg.includes('warn')) return 'warning';
    return 'info';
  };

  const handleExport = () => {
    if (!logEntries.length) return;
    const content = logEntries
      .map(
        (log) =>
          `[${log.when || ''}] [${getLevelString(log.level).toUpperCase()}] ${log.message || ''}`
      )
      .join('\n');

    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `syncthing-logs-${new Date().toISOString().split('T')[0]}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const formatTime = (timestamp?: string) => {
    if (!timestamp) return '';
    try {
      return new Date(timestamp).toLocaleTimeString();
    } catch {
      return timestamp;
    }
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold text-white">System Logs</h2>
        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            size="sm"
            onClick={handleExport}
            disabled={!logEntries.length}
            className="border-slate-700 bg-slate-800/50 hover:bg-slate-700"
          >
            <Download className="mr-2 h-4 w-4" />
            Export
          </Button>
          <Button
            variant="outline"
            size="sm"
            onClick={() => refetch()}
            disabled={isLoading || isRefetching}
            className="border-slate-700 bg-slate-800/50 hover:bg-slate-700"
          >
            <RefreshCw className={cn('h-4 w-4', (isLoading || isRefetching) && 'animate-spin')} />
          </Button>
        </div>
      </div>

      <Card className="border-slate-800 bg-slate-900/50 backdrop-blur-md">
        <CardHeader className="border-b border-slate-800 pb-4">
          <div className="flex items-center justify-between">
            <CardTitle className="text-base text-white">Log Output</CardTitle>
            <div className="flex items-center gap-2">
              {/* Filter buttons */}
              {(['all', 'error', 'warning', 'info', 'debug'] as const).map((level) => (
                <Button
                  key={level}
                  variant={filter === level ? 'default' : 'ghost'}
                  size="sm"
                  onClick={() => setFilter(level)}
                  className={cn(
                    'text-xs capitalize',
                    filter === level
                      ? 'bg-indigo-600 hover:bg-indigo-700'
                      : 'text-slate-400 hover:text-white'
                  )}
                >
                  {level}
                </Button>
              ))}
            </div>
          </div>
        </CardHeader>
        <CardContent className="p-0">
          {isLoading ? (
            <div className="flex items-center justify-center py-12">
              <RefreshCw className="h-8 w-8 animate-spin text-slate-400" />
            </div>
          ) : filteredLogs.length === 0 ? (
            <div className="flex flex-col items-center justify-center py-12 text-center">
              <Info className="h-8 w-8 text-slate-500" />
              <p className="mt-2 text-sm text-slate-400">No logs to display</p>
            </div>
          ) : (
            <div ref={logContainerRef} className="h-[500px] overflow-auto font-mono text-xs">
              {filteredLogs.map((log, index) => {
                const level = getLogLevel(log);
                const config = levelConfig[level] || levelConfig.info;
                const Icon = config.icon;

                return (
                  <div
                    key={index}
                    className={cn(
                      'flex items-start gap-2 border-b border-slate-800/50 px-4 py-2 hover:bg-slate-800/30',
                      config.bg
                    )}
                  >
                    <Icon className={cn('mt-0.5 h-3 w-3 shrink-0', config.color)} />
                    <span className="shrink-0 text-slate-500">{formatTime(log.when)}</span>
                    <span className="flex-1 break-all text-slate-300">{log.message}</span>
                  </div>
                );
              })}
            </div>
          )}
        </CardContent>
      </Card>

      {/* Auto-scroll toggle */}
      <div className="flex items-center justify-between">
        <label className="flex items-center gap-2 text-sm text-slate-400">
          <input
            type="checkbox"
            checked={autoScroll}
            onChange={(e) => setAutoScroll(e.target.checked)}
            className="rounded border-slate-600 bg-slate-800"
          />
          Auto-scroll to new logs
        </label>
        <p className="text-xs text-slate-500">{filteredLogs.length} log entries</p>
      </div>
    </div>
  );
}
</file>

<file path="src/components/main-content.tsx">
'use client';

import { useAppStore } from '@/store';
import { NetworkGraph } from '@/components/network-graph';
import { StatsOverview } from '@/components/stats-overview';
import { FolderList } from '@/components/folder-list';
import { DeviceList } from '@/components/device-list';
import { SettingsPage } from '@/components/settings-page';
import { LogsPage } from '@/components/logs-page';
import { MotionPage, MotionList, MotionItem } from '@/components/ui/motion';
import { AnimatePresence } from 'framer-motion';

function DashboardView() {
  return (
    <MotionPage className="space-y-8">
      {/* Network Visualization */}
      <MotionList>
        <MotionItem>
          <section>
            <h2 className="mb-4 text-lg font-semibold text-white">Network Topology</h2>
            <NetworkGraph />
          </section>
        </MotionItem>

        {/* Stats Overview */}
        <MotionItem>
          <section className="mt-8">
            <h2 className="mb-4 text-lg font-semibold text-white">Overview</h2>
            <StatsOverview />
          </section>
        </MotionItem>

        {/* Quick Folders Preview */}
        <MotionItem>
          <section className="mt-8">
            <h2 className="mb-4 text-lg font-semibold text-white">Recent Folders</h2>
            <FolderList />
          </section>
        </MotionItem>
      </MotionList>
    </MotionPage>
  );
}

function FoldersView() {
  return (
    <MotionPage className="space-y-6">
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold text-white">All Folders</h2>
      </div>
      <FolderList />
    </MotionPage>
  );
}

function DevicesView() {
  return (
    <MotionPage className="space-y-6">
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold text-white">All Devices</h2>
      </div>
      <DeviceList />
    </MotionPage>
  );
}

function LogsView() {
  return (
    <MotionPage>
      <LogsPage />
    </MotionPage>
  );
}

function SettingsView() {
  return (
    <MotionPage>
      <SettingsPage />
    </MotionPage>
  );
}

export function MainContent() {
  const { activeTab } = useAppStore();

  const renderContent = () => {
    switch (activeTab) {
      case 'dashboard':
        return <DashboardView />;
      case 'folders':
        return <FoldersView />;
      case 'devices':
        return <DevicesView />;
      case 'logs':
        return <LogsView />;
      case 'settings':
        return <SettingsView />;
      default:
        return <DashboardView />;
    }
  };

  return (
    <main className="relative z-0 flex-1 overflow-auto p-6">
      <AnimatePresence mode="wait">
        <div key={activeTab}>{renderContent()}</div>
      </AnimatePresence>
    </main>
  );
}
</file>

<file path="src/components/network-graph.tsx">
'use client';

import { useConnections, useConfig } from '@/hooks/useSyncthing';
import { Skeleton } from '@/components/ui/skeleton';
import { useMemo } from 'react';

interface DeviceNode {
  id: string;
  name: string;
  connected: boolean;
  x: number;
  y: number;
}

export function NetworkGraph() {
  const { data: connections, isLoading: connectionsLoading } = useConnections();
  const { data: config, isLoading: configLoading } = useConfig();

  const { nodes, lines, myDeviceId } = useMemo(() => {
    if (!connections || !config) {
      return { nodes: [], lines: [], myDeviceId: null };
    }

    const deviceNodes: DeviceNode[] = [];
    const conns = connections.connections || {};
    const devices = config.devices || [];

    // Find my device ID from connections response
    const myId = (connections as { myID?: string }).myID || null;

    // Center position
    const centerX = 150;
    const centerY = 120;
    const radius = 80;

    // Add my device at center
    if (myId) {
      const myDevice = devices.find((d: { deviceID: string }) => d.deviceID === myId);
      deviceNodes.push({
        id: myId,
        name: myDevice?.name || 'This Device',
        connected: true,
        x: centerX,
        y: centerY,
      });
    }

    // Add other devices in a circle around center
    const otherDevices = devices.filter((d: { deviceID: string }) => d.deviceID !== myId);
    const angleStep = (2 * Math.PI) / Math.max(otherDevices.length, 1);

    otherDevices.forEach((device: { deviceID: string; name?: string }, index: number) => {
      const angle = index * angleStep - Math.PI / 2; // Start from top
      const connectionInfo = conns[device.deviceID] as { connected?: boolean } | undefined;

      deviceNodes.push({
        id: device.deviceID,
        name: device.name || device.deviceID.slice(0, 8),
        connected: connectionInfo?.connected ?? false,
        x: centerX + Math.cos(angle) * radius,
        y: centerY + Math.sin(angle) * radius,
      });
    });

    // Build connection lines from center to connected devices
    const connectionLines: Array<{
      x1: number;
      y1: number;
      x2: number;
      y2: number;
    }> = [];
    const centerNode = deviceNodes.find((n) => n.id === myId);

    if (centerNode) {
      deviceNodes
        .filter((n) => n.id !== myId && n.connected)
        .forEach((node) => {
          connectionLines.push({
            x1: centerNode.x,
            y1: centerNode.y,
            x2: node.x,
            y2: node.y,
          });
        });
    }

    return { nodes: deviceNodes, lines: connectionLines, myDeviceId: myId };
  }, [connections, config]);

  if (connectionsLoading || configLoading) {
    return <Skeleton className="h-64 w-full rounded-xl bg-slate-800/50" />;
  }

  if (nodes.length === 0) {
    return (
      <div className="flex h-64 w-full items-center justify-center rounded-xl bg-slate-900/50 backdrop-blur-md">
        <p className="text-sm text-slate-400">
          No devices connected. Start Syncthing to see your network.
        </p>
      </div>
    );
  }

  return (
    <div className="h-64 w-full overflow-hidden rounded-xl bg-slate-900/50 backdrop-blur-md">
      <svg viewBox="0 0 300 240" className="h-full w-full">
        {/* Connection lines */}
        {lines.map((line, i) => (
          <line
            key={i}
            x1={line.x1}
            y1={line.y1}
            x2={line.x2}
            y2={line.y2}
            stroke="#6366f1"
            strokeWidth="2"
            strokeOpacity="0.5"
            strokeDasharray="4 2"
          >
            <animate
              attributeName="stroke-dashoffset"
              from="0"
              to="12"
              dur="1s"
              repeatCount="indefinite"
            />
          </line>
        ))}

        {/* Device nodes */}
        {nodes.map((node) => {
          const isMe = node.id === myDeviceId;
          const nodeRadius = isMe ? 24 : 18;
          const color = isMe ? '#6366f1' : node.connected ? '#10b981' : '#6b7280';

          return (
            <g key={node.id}>
              {/* Glow effect */}
              <circle
                cx={node.x}
                cy={node.y}
                r={nodeRadius + 4}
                fill={color}
                opacity={node.connected || isMe ? 0.3 : 0.1}
              >
                {(node.connected || isMe) && (
                  <animate
                    attributeName="opacity"
                    values="0.3;0.5;0.3"
                    dur="2s"
                    repeatCount="indefinite"
                  />
                )}
              </circle>

              {/* Main circle */}
              <circle
                cx={node.x}
                cy={node.y}
                r={nodeRadius}
                fill={color}
                stroke={isMe ? '#818cf8' : node.connected ? '#34d399' : '#9ca3af'}
                strokeWidth="2"
              />

              {/* Icon */}
              <text
                x={node.x}
                y={node.y}
                textAnchor="middle"
                dominantBaseline="central"
                fontSize={isMe ? '14' : '12'}
              >
                {isMe ? '' : node.connected ? '' : ''}
              </text>

              {/* Label */}
              <text
                x={node.x}
                y={node.y + nodeRadius + 14}
                textAnchor="middle"
                fill="white"
                fontSize="10"
                fontWeight="500"
                className="select-none"
              >
                {node.name.length > 12 ? node.name.slice(0, 12) + '' : node.name}
              </text>
            </g>
          );
        })}
      </svg>
    </div>
  );
}
</file>

<file path="src/components/stats-overview.tsx">
'use client';

import { useSystemStatus, useConnections } from '@/hooks/useSyncthing';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Skeleton } from '@/components/ui/skeleton';
import { formatUptime, formatBytes } from '@/lib/utils';
import { motion } from 'framer-motion';
import {
  Activity,
  HardDrive,
  Network,
  Clock,
  ArrowDownToLine,
  ArrowUpFromLine,
} from 'lucide-react';

const cardVariants = {
  hidden: { opacity: 0, y: 20, scale: 0.95 },
  visible: (i: number) => ({
    opacity: 1,
    y: 0,
    scale: 1,
    transition: {
      delay: i * 0.1,
      type: 'spring' as const,
      stiffness: 300,
      damping: 25,
    },
  }),
};

function StatCard({
  title,
  value,
  icon: Icon,
  isLoading,
  badge,
  index = 0,
}: {
  title: string;
  value: string;
  icon: React.ComponentType<{ className?: string }>;
  isLoading: boolean;
  badge?: { label: string; variant: 'success' | 'warning' | 'destructive' };
  index?: number;
}) {
  return (
    <motion.div
      variants={cardVariants}
      initial="hidden"
      animate="visible"
      custom={index}
      whileHover={{
        y: -4,
        transition: { type: 'spring', stiffness: 400, damping: 25 },
      }}
    >
      <Card className="border-slate-800 bg-slate-900/50 backdrop-blur-md">
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium text-slate-300">{title}</CardTitle>
          <Icon className="h-4 w-4 text-slate-400" />
        </CardHeader>
        <CardContent>
          {isLoading ? (
            <Skeleton className="h-8 w-24" />
          ) : (
            <div className="flex items-center gap-2">
              <motion.div
                className="text-2xl font-bold text-white"
                key={value}
                initial={{ opacity: 0, scale: 0.8 }}
                animate={{ opacity: 1, scale: 1 }}
                transition={{
                  type: 'spring',
                  stiffness: 500,
                  damping: 30,
                }}
              >
                {value}
              </motion.div>
              {badge && (
                <Badge variant={badge.variant} className="text-xs">
                  {badge.label}
                </Badge>
              )}
            </div>
          )}
        </CardContent>
      </Card>
    </motion.div>
  );
}

export function StatsOverview() {
  const { data: status, isLoading: statusLoading, isError: statusError } = useSystemStatus();
  const { data: connections, isLoading: connectionsLoading } = useConnections();

  const isLoading = statusLoading || connectionsLoading;

  // Calculate connected devices
  const connectedDevices = Object.values(connections?.connections || {}).filter(
    (c) => c?.connected
  ).length;
  const totalDevices = Object.keys(connections?.connections || {}).length;

  // Calculate transfer stats
  const inBytes = connections?.total?.inBytesTotal || 0;
  const outBytes = connections?.total?.outBytesTotal || 0;

  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
      <StatCard
        title="Status"
        value={statusError ? 'Offline' : 'Online'}
        icon={Activity}
        isLoading={isLoading}
        index={0}
        badge={
          statusError
            ? { label: 'Disconnected', variant: 'destructive' }
            : { label: 'Connected', variant: 'success' }
        }
      />
      <StatCard
        title="Uptime"
        value={status?.uptime ? formatUptime(status.uptime) : ''}
        icon={Clock}
        isLoading={isLoading}
        index={1}
      />
      <StatCard
        title="Devices"
        value={`${connectedDevices}/${totalDevices}`}
        icon={Network}
        isLoading={isLoading}
        index={2}
        badge={
          connectedDevices === totalDevices && totalDevices > 0
            ? { label: 'All Connected', variant: 'success' }
            : undefined
        }
      />
      <StatCard
        title="Goroutines"
        value={status?.goroutines?.toString() || ''}
        icon={HardDrive}
        isLoading={isLoading}
        index={3}
      />
      <StatCard
        title="Downloaded"
        value={formatBytes(inBytes)}
        icon={ArrowDownToLine}
        isLoading={isLoading}
        index={4}
      />
      <StatCard
        title="Uploaded"
        value={formatBytes(outBytes)}
        icon={ArrowUpFromLine}
        isLoading={isLoading}
        index={5}
      />
    </div>
  );
}
</file>

<file path="src/hooks/useAISearch.ts">
/**
 * useAISearch - Hook for semantic file search using AI embeddings
 *
 * Manages a Web Worker running transformers.js for:
 * - Generating file path embeddings
 * - Semantic similarity search
 */

import { useCallback, useEffect, useRef } from 'react';
import { storeEmbedding, getAllEmbeddings, type FileEmbedding } from '@/lib/db';
import { useAIStore, type AIStatus } from '@/store';

export type { AIStatus } from '@/store';

interface AIWorkerMessage {
    id?: string;
    type: string;
    payload?: unknown;
}

interface SearchResult {
    path: string;
    score: number;
}

interface UseAISearchOptions {
    enabled?: boolean;
}

interface UseAISearchReturn {
    status: AIStatus;
    statusMessage: string;
    isReady: boolean;
    initialize: () => Promise<void>;
    retry: () => Promise<void>;
    generateEmbeddings: (texts: string[]) => Promise<number[][]>;
    indexFiles: (files: { path: string; name: string }[]) => Promise<void>;
    search: (query: string, folderId?: string) => Promise<SearchResult[]>;
    progress: { current: number; total: number } | null;
}

// Module-level singleton for the AI worker (shared across all hook instances)
let sharedWorker: Worker | null = null;
let sharedPendingCalls = new Map<
    string,
    { resolve: (value: unknown) => void; reject: (error: Error) => void }
>();
let callIdCounter = 0;
let workerInitialized = false;

function getOrCreateWorker(): Worker | null {
    if (typeof window === 'undefined') return null;

    if (!sharedWorker) {
        console.log('[useAISearch] Creating new AI worker...');
        try {
            // Use dynamic import path for better bundler compatibility
            sharedWorker = new Worker(
                new URL('../workers/ai.worker.ts', import.meta.url),
                { type: 'module' }
            );
            console.log('[useAISearch] Worker object created');

            // Add error handler for worker loading issues
            sharedWorker.addEventListener('error', (e) => {
                console.error('[useAISearch] Worker error event:', e.message, e.filename, e.lineno);
            });

        } catch (error) {
            console.error('[useAISearch] Failed to create AI worker:', error);
            const store = useAIStore.getState();
            store.setAIStatus('error');
            store.setAIStatusMessage(`Failed to create AI worker: ${error instanceof Error ? error.message : 'Unknown error'}`);
            return null;
        }

        sharedWorker.onmessage = (event: MessageEvent<AIWorkerMessage>) => {
            const { id, type, payload } = event.data;
            console.log('[useAISearch] Received message from worker:', type, payload);

            // Handle status updates - update global store directly
            if (type === 'status' && payload && typeof payload === 'object') {
                const statusPayload = payload as { status?: string; message?: string };
                const store = useAIStore.getState();
                if (statusPayload.status === 'loading') {
                    store.setAIStatus('loading');
                    store.setAIStatusMessage(statusPayload.message || 'Loading model...');
                } else if (statusPayload.status === 'ready') {
                    store.setAIStatus('ready');
                    store.setAIStatusMessage(statusPayload.message || 'Ready');
                } else if (statusPayload.status === 'error') {
                    store.setAIStatus('error');
                    store.setAIStatusMessage(statusPayload.message || 'Error');
                } else if (statusPayload.status === 'initialized') {
                    // Worker is ready to receive commands
                    console.log('AI Worker initialized and ready');
                }
            }

            // Handle responses to calls
            if (id) {
                const pending = sharedPendingCalls.get(id);
                if (pending) {
                    if (type === 'error') {
                        const errorPayload = payload as { message?: string };
                        pending.reject(new Error(errorPayload?.message || 'Worker error'));
                    } else {
                        pending.resolve(payload);
                    }
                    sharedPendingCalls.delete(id);
                }
            }
        };

        sharedWorker.onerror = (error) => {
            console.error('AI Worker error:', error);
            const store = useAIStore.getState();
            store.setAIStatus('error');
            store.setAIStatusMessage(`Worker error: ${error.message || 'Unknown error'}`);
        };
    }

    return sharedWorker;
}

function terminateWorker() {
    if (sharedWorker) {
        sharedWorker.terminate();
        sharedWorker = null;
        workerInitialized = false;
        sharedPendingCalls.clear();
    }
}

export function useAISearch(options: UseAISearchOptions = {}): UseAISearchReturn {
    const { enabled = true } = options;

    const initializingRef = useRef(false);

    // Use global store for AI status (shared across all components)
    const status = useAIStore((state) => state.aiStatus);
    const statusMessage = useAIStore((state) => state.aiStatusMessage);
    const progress = useAIStore((state) => state.aiProgress);
    const setStatus = useAIStore((state) => state.setAIStatus);
    const setStatusMessage = useAIStore((state) => state.setAIStatusMessage);
    const setProgress = useAIStore((state) => state.setAIProgress);

    // Sync disabled state
    useEffect(() => {
        if (!enabled && status !== 'disabled') {
            setStatus('disabled');
            setStatusMessage('AI features are disabled');
            terminateWorker();
        } else if (enabled && status === 'disabled') {
            setStatus('idle');
            setStatusMessage('');
        }
    }, [enabled, status, setStatus, setStatusMessage]);

    // Initialize worker when enabled
    useEffect(() => {
        console.log('[useAISearch] Effect running, enabled:', enabled);
        if (enabled) {
            console.log('[useAISearch] Calling getOrCreateWorker...');
            const worker = getOrCreateWorker();
            console.log('[useAISearch] Worker result:', worker ? 'created' : 'null');
        }
    }, [enabled]);

    // Send message to worker and wait for response
    const sendMessage = useCallback(
        <T>(type: string, payload?: unknown, timeoutMs = 120000): Promise<T> => {
            return new Promise((resolve, reject) => {
                const worker = getOrCreateWorker();
                if (!worker) {
                    reject(new Error('Worker not initialized'));
                    return;
                }

                const id = `call-${++callIdCounter}`;

                const timeoutId = setTimeout(() => {
                    if (sharedPendingCalls.has(id)) {
                        sharedPendingCalls.delete(id);
                        reject(
                            new Error(`Worker call timed out after ${timeoutMs / 1000}s for operation: ${type}`)
                        );
                    }
                }, timeoutMs);

                sharedPendingCalls.set(id, {
                    resolve: (value: unknown) => {
                        clearTimeout(timeoutId);
                        resolve(value as T);
                    },
                    reject: (error: Error) => {
                        clearTimeout(timeoutId);
                        reject(error);
                    },
                });

                worker.postMessage({ id, type, payload });
            });
        },
        []
    );

    // Initialize the model
    const initialize = useCallback(async () => {
        if (!enabled) return;
        if (status === 'ready' || status === 'loading' || status === 'error') return;
        if (initializingRef.current) return;

        initializingRef.current = true;
        setStatus('loading');
        setStatusMessage('Downloading AI model (~23MB)...');
        try {
            // Model loading/downloading can take 10+ minutes on slow connections
            // The model is ~23MB and needs to be downloaded from Hugging Face
            await sendMessage('init', undefined, 600000); // 10 minute timeout
        } catch (error) {
            console.error('Failed to initialize AI model:', error);
            const errorMessage = error instanceof Error ? error.message : 'Failed to initialize';
            const isTimeout = errorMessage.includes('timed out');
            setStatus('error');
            setStatusMessage(
                isTimeout
                    ? 'Model download timed out after 10 minutes. This could be a network issue or the Hugging Face server may be slow. Try again later.'
                    : errorMessage
            );
        } finally {
            initializingRef.current = false;
        }
    }, [enabled, status, sendMessage, setStatus, setStatusMessage]);

    // Retry initialization after an error
    const retry = useCallback(async () => {
        if (!enabled) return;
        // Reset status to idle so initialize() can run again
        setStatus('idle');
        setStatusMessage('');
        // Terminate the existing worker and create a new one
        terminateWorker();
        // Small delay to ensure cleanup
        await new Promise((resolve) => setTimeout(resolve, 100));
        // Re-create worker and initialize
        getOrCreateWorker();
        // Initialize will be called by the effect or manually
    }, [enabled, setStatus, setStatusMessage]);

    // Generate embeddings for texts
    const generateEmbeddings = useCallback(
        async (texts: string[]): Promise<number[][]> => {
            if (!enabled) return [];
            // Embedding generation: 60 seconds should be enough for a batch
            const result = await sendMessage<{ embeddings: number[][] }>('embed', { texts }, 60000);
            return result.embeddings;
        },
        [enabled, sendMessage]
    );

    // Index files - generate and store embeddings
    const indexFiles = useCallback(
        async (files: { path: string; name: string }[]) => {
            if (!enabled) return;
            if (files.length === 0) return;

            setProgress({ current: 0, total: files.length });

            const batchSize = 10;

            for (let i = 0; i < files.length; i += batchSize) {
                const batch = files.slice(i, i + batchSize);
                const texts = batch.map((f) => `${f.name} ${f.path}`);

                try {
                    const embeddings = await generateEmbeddings(texts);

                    // Save to IndexedDB
                    for (let j = 0; j < batch.length; j++) {
                        await storeEmbedding({
                            path: batch[j].path,
                            embedding: embeddings[j],
                            model: 'all-MiniLM-L6-v2',
                            createdAt: Date.now(),
                        });
                    }
                } catch (error) {
                    console.error('Error indexing batch:', error);
                }

                setProgress({ current: Math.min(i + batchSize, files.length), total: files.length });
            }

            setProgress(null);
        },
        [enabled, generateEmbeddings, setProgress]
    );

    // Semantic search
    const search = useCallback(
        async (query: string, folderId?: string): Promise<SearchResult[]> => {
            if (!enabled) return [];
            if (!query.trim()) return [];

            // Get stored embeddings
            const storedEmbeddings = await getAllEmbeddings();

            // TODO: Filter by folderId if provided (need to join with files table)
            const embeddings = storedEmbeddings.map((e: FileEmbedding) => ({
                path: e.path,
                embedding: e.embedding,
            }));

            if (embeddings.length === 0) {
                return [];
            }

            // Search should be fast, 30 seconds is plenty
            const result = await sendMessage<{ results: SearchResult[] }>(
                'search',
                {
                    query,
                    embeddings,
                    topK: 20,
                },
                30000
            );

            return result.results;
        },
        [enabled, sendMessage]
    );

    return {
        status,
        statusMessage,
        isReady: status === 'ready',
        initialize,
        retry,
        generateEmbeddings,
        indexFiles,
        search,
        progress,
    };
}
</file>

<file path="src/hooks/useErrorNotifications.ts">
// src/hooks/useErrorNotifications.ts
// Enhanced notification hook that integrates with the error system

'use client';

import { useCallback, useEffect, useRef } from 'react';
import { toast } from 'sonner';
import { logger } from '@/lib/logger';
import {
  errorNotifications,
  notifyError,
  notifySuccess,
  notifyWarning,
  notifyInfo,
} from '@/lib/error-notifications';
import { ErrorHandler, AppError } from '@/lib/errors';
import { syncthingCircuitBreaker } from '@/lib/retry';
import { healthMonitor, HealthStatus } from '@/lib/health-monitor';

export interface UseErrorNotificationsOptions {
  watchCircuitBreaker?: boolean;
  watchHealth?: boolean;
  notifyOnHealthChange?: boolean;
}

/**
 * Hook for handling errors with toast notifications and recovery
 */
export function useErrorNotifications(options: UseErrorNotificationsOptions = {}) {
  const { watchCircuitBreaker = true, watchHealth = true, notifyOnHealthChange = true } = options;

  const previousHealthRef = useRef<Map<string, HealthStatus>>(new Map());
  const connectionLostToastRef = useRef<string | number | null>(null);

  // Watch circuit breaker state
  useEffect(() => {
    if (!watchCircuitBreaker) return;

    const checkInterval = setInterval(() => {
      const state = syncthingCircuitBreaker.getState();

      if (state.state === 'open' && connectionLostToastRef.current === null) {
        connectionLostToastRef.current = errorNotifications.notifyConnectionIssue(() => {
          syncthingCircuitBreaker.reset();
        });
      } else if (state.state === 'closed' && connectionLostToastRef.current !== null) {
        toast.dismiss(connectionLostToastRef.current);
        connectionLostToastRef.current = null;
        errorNotifications.notifyRecovery('Syncthing');
      }
    }, 5000);

    return () => clearInterval(checkInterval);
  }, [watchCircuitBreaker]);

  // Watch health status changes
  useEffect(() => {
    if (!watchHealth) return;

    const unsubscribe = healthMonitor.subscribe((status) => {
      if (!notifyOnHealthChange) return;

      status.forEach((currentStatus, name) => {
        const previousStatus = previousHealthRef.current.get(name);

        // Check for status changes
        if (previousStatus) {
          // Service recovered
          if (!previousStatus.healthy && currentStatus.healthy) {
            logger.info(`Health check recovered: ${name}`);
            toast.success(`${formatServiceName(name)} recovered`, {
              description: 'Service is now healthy',
            });
          }

          // Service became unhealthy (only notify after multiple failures)
          if (
            previousStatus.healthy &&
            !currentStatus.healthy &&
            currentStatus.consecutiveFailures >= 2
          ) {
            logger.warn(`Health check failing: ${name}`, {
              consecutiveFailures: currentStatus.consecutiveFailures,
            });
            toast.warning(`${formatServiceName(name)} issue detected`, {
              description: currentStatus.error || 'Service is experiencing problems',
            });
          }
        }
      });

      previousHealthRef.current = new Map(status);
    });

    return unsubscribe;
  }, [watchHealth, notifyOnHealthChange]);

  /**
   * Handle an error with notification
   */
  const handleError = useCallback(
    (
      error: unknown,
      options?: {
        showToast?: boolean;
        retryAction?: () => Promise<void>;
        context?: string;
      }
    ) => {
      const { showToast = true, retryAction, context } = options || {};

      logger.error('Error handled', {
        error: error instanceof Error ? error.message : String(error),
        context,
      });

      return notifyError(error, {
        showToast,
        retryAction,
        autoRecover: true,
      });
    },
    []
  );

  /**
   * Show a success notification
   */
  const showSuccess = useCallback((message: string, description?: string) => {
    notifySuccess(message, description);
  }, []);

  /**
   * Show a warning notification
   */
  const showWarning = useCallback((message: string, description?: string) => {
    notifyWarning(message, description);
  }, []);

  /**
   * Show an info notification
   */
  const showInfo = useCallback((message: string, description?: string) => {
    notifyInfo(message, description);
  }, []);

  /**
   * Show error notification with custom message
   */
  const showError = useCallback((message: string, description?: string) => {
    toast.error(message, { description });
    logger.error(message, { description });
  }, []);

  /**
   * Wrap an async function with error handling
   */
  const withErrorHandling = useCallback(
    <T extends unknown[], R>(
      fn: (...args: T) => Promise<R>,
      options?: {
        successMessage?: string;
        errorMessage?: string;
        showSuccessToast?: boolean;
      }
    ) => {
      return async (...args: T): Promise<R | undefined> => {
        try {
          const result = await fn(...args);

          if (options?.showSuccessToast && options?.successMessage) {
            showSuccess(options.successMessage);
          }

          return result;
        } catch (error) {
          handleError(error, {
            showToast: true,
            context: options?.errorMessage,
          });
          return undefined;
        }
      };
    },
    [handleError, showSuccess]
  );

  /**
   * Get user-friendly error message
   */
  const getUserMessage = useCallback((error: unknown): string => {
    return ErrorHandler.getUserMessage(error);
  }, []);

  /**
   * Check if error is recoverable
   */
  const isRecoverable = useCallback((error: unknown): boolean => {
    return ErrorHandler.isRetryable(error);
  }, []);

  return {
    handleError,
    showSuccess,
    showWarning,
    showInfo,
    showError,
    withErrorHandling,
    getUserMessage,
    isRecoverable,
    errorNotifications,
  };
}

/**
 * Format service name for display
 */
function formatServiceName(name: string): string {
  return name
    .split('-')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

/**
 * Hook for operation notifications (mutations)
 */
export function useOperationNotifications() {
  const { handleError, showSuccess } = useErrorNotifications();

  /**
   * Wrap a mutation with notifications
   */
  const withNotifications = useCallback(
    <T extends unknown[], R>(
      operation: (...args: T) => Promise<R>,
      options: {
        operationName: string;
        successMessage?: string;
        errorMessage?: string;
      }
    ) => {
      return async (...args: T): Promise<R> => {
        const { operationName, successMessage, errorMessage } = options;

        logger.debug(`Starting operation: ${operationName}`);

        try {
          const result = await operation(...args);

          if (successMessage) {
            showSuccess(successMessage);
          }

          logger.info(`Operation completed: ${operationName}`);
          return result;
        } catch (error) {
          logger.error(`Operation failed: ${operationName}`, {
            error: error instanceof Error ? error.message : String(error),
          });

          handleError(error, {
            showToast: true,
            context: errorMessage || `Failed to ${operationName.toLowerCase()}`,
          });

          throw error;
        }
      };
    },
    [handleError, showSuccess]
  );

  return {
    withNotifications,
  };
}

export { notifyError, notifySuccess, notifyWarning, notifyInfo };
</file>

<file path="src/hooks/useNotifications.ts">
'use client';

import { useEffect, useState, useCallback } from 'react';
import {
  isPermissionGranted,
  requestPermission,
  sendNotification,
} from '@tauri-apps/plugin-notification';
import { useAppStore } from '@/store';

export type NotificationPriority = 'low' | 'normal' | 'high';

export interface NotificationOptions {
  title: string;
  body: string;
  priority?: NotificationPriority;
}

/**
 * Hook for sending native OS notifications
 */
export function useNativeNotifications() {
  const [permissionGranted, setPermissionGranted] = useState(false);
  const [initialized, setInitialized] = useState(false);
  const nativeNotificationsEnabled = useAppStore((s) => s.nativeNotificationsEnabled);

  // Check and request permission on mount
  useEffect(() => {
    async function checkPermission() {
      try {
        let granted = await isPermissionGranted();

        if (!granted) {
          const permission = await requestPermission();
          granted = permission === 'granted';
        }

        setPermissionGranted(granted);
      } catch (error) {
        console.debug('Notification permission check failed:', error);
        setPermissionGranted(false);
      } finally {
        setInitialized(true);
      }
    }

    checkPermission();
  }, []);

  /**
   * Send a native notification
   */
  const notify = useCallback(
    async ({ title, body }: NotificationOptions) => {
      // Check if notifications are enabled in settings
      if (!nativeNotificationsEnabled) {
        return false;
      }

      if (!permissionGranted) {
        console.debug('Notifications not permitted');
        return false;
      }

      try {
        await sendNotification({
          title,
          body,
        });
        return true;
      } catch (error) {
        console.error('Failed to send notification:', error);
        return false;
      }
    },
    [permissionGranted, nativeNotificationsEnabled]
  );

  /**
   * Quick notification for device events
   */
  const notifyDeviceEvent = useCallback(
    (type: 'connected' | 'disconnected' | 'rejected', deviceName: string) => {
      const messages = {
        connected: {
          title: 'Device Connected',
          body: `${deviceName} is now online`,
        },
        disconnected: {
          title: 'Device Disconnected',
          body: `${deviceName} went offline`,
        },
        rejected: {
          title: 'New Device Request',
          body: `${deviceName} wants to connect`,
        },
      };

      return notify(messages[type]);
    },
    [notify]
  );

  /**
   * Quick notification for folder events
   */
  const notifyFolderEvent = useCallback(
    (type: 'synced' | 'error' | 'shared', folderName: string, extra?: string) => {
      const messages = {
        synced: {
          title: 'Sync Complete',
          body: `${folderName} is now up to date`,
        },
        error: {
          title: 'Sync Error',
          body: `${folderName}: ${extra || 'An error occurred'}`,
        },
        shared: {
          title: 'Folder Shared',
          body: `${extra || 'A device'} shared ${folderName} with you`,
        },
      };

      return notify(messages[type]);
    },
    [notify]
  );

  return {
    initialized,
    permissionGranted,
    notify,
    notifyDeviceEvent,
    notifyFolderEvent,
  };
}
</file>

<file path="src/hooks/useSyncthingEnhanced.ts">
// src/hooks/useSyncthingEnhanced.ts
// Enhanced Syncthing hooks with retry logic, circuit breaker, and better error handling

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { invoke } from '@tauri-apps/api/core';
import { toast } from 'sonner';
import { logger } from '@/lib/logger';
import { retry, syncthingCircuitBreaker } from '@/lib/retry';
import { SyncthingError, ErrorHandler } from '@/lib/errors';
import { useAppStore } from '@/store';
import {
  SystemStatusSchema,
  ConnectionsSchema,
  ConfigSchema,
  FolderStatusSchema,
  type SystemStatus,
  type Connections,
  type Config,
  type FolderStatus,
} from './useSyncthing';

/**
 * Enhanced Syncthing error with context
 */
class EnhancedSyncthingError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly context?: Record<string, unknown>,
    public readonly originalError?: unknown
  ) {
    super(message);
    this.name = 'EnhancedSyncthingError';
  }
}

/**
 * Wrap Tauri invoke with retry logic and circuit breaker
 */
async function invokeWithRetry<T>(
  command: string,
  args?: Record<string, unknown>,
  options?: {
    maxAttempts?: number;
    showToast?: boolean;
    critical?: boolean;
  }
): Promise<T> {
  const { maxAttempts = 3, showToast = false, critical = false } = options || {};

  logger.debug(`Invoking command: ${command}`, { args });

  try {
    const result = await syncthingCircuitBreaker.execute(async () => {
      return await retry(
        async () => {
          const result = await invoke<T>(command, args);
          logger.debug(`Command succeeded: ${command}`);
          return result;
        },
        {
          maxAttempts,
          onRetry: (attempt, error) => {
            logger.warn(`Retrying ${command} (attempt ${attempt})`, {
              error: error instanceof Error ? error.message : String(error),
            });

            if (showToast && attempt === 2) {
              toast.warning('Connection issues detected', {
                description: 'Retrying...',
              });
            }
          },
        }
      );
    });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);

    logger.error(`Command failed: ${command}`, {
      error: errorMessage,
      args,
      critical,
    });

    // Show user-friendly error
    if (showToast) {
      toast.error('Operation failed', {
        description: ErrorHandler.getUserMessage(error),
        action: {
          label: 'Retry',
          onClick: () => invokeWithRetry(command, args, options),
        },
      });
    }

    throw new EnhancedSyncthingError(
      `Failed to execute ${command}`,
      'INVOKE_ERROR',
      { command, args },
      error
    );
  }
}

/**
 * Enhanced system status hook with health checks
 */
export function useSystemStatusEnhanced() {
  const pollingInterval = useAppStore((state) => state.pollingInterval);

  return useQuery({
    queryKey: ['systemStatus'],
    queryFn: async (): Promise<SystemStatus> => {
      try {
        const data = await invokeWithRetry('get_system_status', undefined, {
          maxAttempts: 5,
          showToast: true,
          critical: true,
        });

        const parsed = SystemStatusSchema.parse(data);

        // Health check - log circuit breaker state
        const circuitState = syncthingCircuitBreaker.getState();
        if (circuitState.state !== 'closed') {
          logger.info('Syncthing connection recovered', circuitState);
        }

        return parsed;
      } catch (error) {
        logger.error('System status check failed', {
          error: error instanceof Error ? error.message : String(error),
        });
        throw error;
      }
    },
    retry: false, // We handle retries ourselves
    refetchInterval: pollingInterval,
    staleTime: pollingInterval - 1000,
    meta: {
      errorMessage: 'Failed to fetch Syncthing status',
    },
  });
}

/**
 * Enhanced connections hook
 */
export function useConnectionsEnhanced() {
  const pollingInterval = useAppStore((state) => state.pollingInterval);

  return useQuery({
    queryKey: ['connections'],
    queryFn: async (): Promise<Connections> => {
      const data = await invokeWithRetry('get_connections', undefined, {
        maxAttempts: 3,
      });
      return ConnectionsSchema.parse(data);
    },
    retry: false,
    refetchInterval: pollingInterval,
    staleTime: pollingInterval - 1000,
  });
}

/**
 * Enhanced config hook
 */
export function useConfigEnhanced() {
  return useQuery({
    queryKey: ['config'],
    queryFn: async (): Promise<Config> => {
      const data = await invokeWithRetry('get_config', undefined, {
        maxAttempts: 3,
      });
      return ConfigSchema.parse(data);
    },
    retry: false,
    refetchInterval: 30000,
    staleTime: 25000,
  });
}

/**
 * Enhanced folder status hook
 */
export function useFolderStatusEnhanced(folderId: string) {
  const pollingInterval = useAppStore((state) => state.pollingInterval);
  const folderPollingInterval = Math.max(pollingInterval / 2, 1000);

  return useQuery({
    queryKey: ['folderStatus', folderId],
    queryFn: async (): Promise<FolderStatus> => {
      const data = await invokeWithRetry(
        'get_folder_status',
        { folderId },
        {
          maxAttempts: 2,
        }
      );
      return FolderStatusSchema.parse(data);
    },
    enabled: !!folderId,
    retry: false,
    refetchInterval: folderPollingInterval,
  });
}

/**
 * Enhanced mutation with optimistic updates for pausing folder
 */
export function usePauseFolderEnhanced() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (folderId: string) => {
      logger.info(`Pausing folder: ${folderId}`);
      await invokeWithRetry('pause_folder', { folderId }, { showToast: true });
    },
    onMutate: async (folderId) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['config'] });

      // Snapshot previous value
      const previousConfig = queryClient.getQueryData<Config>(['config']);

      // Optimistically update
      queryClient.setQueryData<Config>(['config'], (old) => {
        if (!old?.folders) return old;
        return {
          ...old,
          folders: old.folders.map((folder) =>
            folder.id === folderId ? { ...folder, paused: true } : folder
          ),
        };
      });

      logger.debug('Optimistic update applied', { folderId });

      return { previousConfig, folderId };
    },
    onError: (error, folderId, context) => {
      // Rollback on error
      if (context?.previousConfig) {
        queryClient.setQueryData(['config'], context.previousConfig);
        logger.warn('Rolled back optimistic update', { folderId });
      }

      logger.error('Failed to pause folder', {
        folderId,
        error: error instanceof Error ? error.message : String(error),
      });

      toast.error('Failed to pause folder', {
        description: ErrorHandler.getUserMessage(error),
      });
    },
    onSuccess: (_, folderId) => {
      logger.info(`Folder paused successfully: ${folderId}`);
      toast.success('Folder paused');
    },
    onSettled: () => {
      // Always refetch to ensure consistency
      queryClient.invalidateQueries({ queryKey: ['config'] });
    },
  });
}

/**
 * Enhanced mutation with optimistic updates for resuming folder
 */
export function useResumeFolderEnhanced() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (folderId: string) => {
      logger.info(`Resuming folder: ${folderId}`);
      await invokeWithRetry('resume_folder', { folderId }, { showToast: true });
    },
    onMutate: async (folderId) => {
      await queryClient.cancelQueries({ queryKey: ['config'] });
      const previousConfig = queryClient.getQueryData<Config>(['config']);

      queryClient.setQueryData<Config>(['config'], (old) => {
        if (!old?.folders) return old;
        return {
          ...old,
          folders: old.folders.map((folder) =>
            folder.id === folderId ? { ...folder, paused: false } : folder
          ),
        };
      });

      return { previousConfig, folderId };
    },
    onError: (error, folderId, context) => {
      if (context?.previousConfig) {
        queryClient.setQueryData(['config'], context.previousConfig);
      }

      toast.error('Failed to resume folder', {
        description: ErrorHandler.getUserMessage(error),
      });
    },
    onSuccess: (_, folderId) => {
      logger.info(`Folder resumed successfully: ${folderId}`);
      toast.success('Folder resumed');
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['config'] });
    },
  });
}

/**
 * Hook to monitor overall system health
 */
export function useSystemHealth() {
  const { data: status, isError, error } = useSystemStatusEnhanced();
  const circuitState = syncthingCircuitBreaker.getState();

  return {
    isHealthy: !isError && circuitState.state === 'closed',
    status: circuitState.state,
    details: {
      syncthing: status ? 'connected' : 'disconnected',
      circuitBreaker: circuitState,
      error: error instanceof Error ? error.message : null,
    },
  };
}

/**
 * Query error handler wrapper for custom queryFn
 */
export function withErrorHandling<T>(
  queryFn: () => Promise<T>,
  context: { operation: string; component?: string }
) {
  return async (): Promise<T> => {
    try {
      return await queryFn();
    } catch (error) {
      logger.error(`Query error in ${context.operation}`, {
        component: context.component,
        error: error instanceof Error ? error.message : String(error),
      });

      // Transform error for better UX
      if (error instanceof Error) {
        if (error.message.includes('ECONNREFUSED')) {
          throw new SyncthingError('Cannot connect to Syncthing', 'CONNECTION_REFUSED', {
            context,
          });
        }
        if (error.message.includes('timeout')) {
          throw new SyncthingError('Request timed out', 'TIMEOUT', { context });
        }
      }

      throw error;
    }
  };
}

/**
 * Enhanced mutation for starting Syncthing
 */
export function useStartSyncthingEnhanced() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async () => {
      logger.info('Starting Syncthing sidecar');
      return await invokeWithRetry<string>('start_syncthing_sidecar', undefined, {
        maxAttempts: 1, // Only try once for starting
        showToast: true,
      });
    },
    onSuccess: () => {
      logger.info('Syncthing started successfully');
      toast.success('Syncthing started');

      // Reset circuit breaker when starting fresh
      syncthingCircuitBreaker.reset();

      // Wait for Syncthing to fully start, then refresh
      setTimeout(() => {
        queryClient.invalidateQueries({ queryKey: ['systemStatus'] });
        queryClient.invalidateQueries({ queryKey: ['connections'] });
        queryClient.invalidateQueries({ queryKey: ['config'] });
      }, 2000);
    },
    onError: (error) => {
      logger.error('Failed to start Syncthing', {
        error: error instanceof Error ? error.message : String(error),
      });
      toast.error('Failed to start Syncthing', {
        description: ErrorHandler.getUserMessage(error),
      });
    },
  });
}

/**
 * Enhanced mutation for stopping Syncthing
 */
export function useStopSyncthingEnhanced() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async () => {
      logger.info('Stopping Syncthing');
      return await invoke<void>('stop_syncthing_sidecar');
    },
    onSuccess: () => {
      logger.info('Syncthing stopped successfully');
      toast.success('Syncthing stopped');

      queryClient.invalidateQueries({ queryKey: ['systemStatus'] });
      queryClient.invalidateQueries({ queryKey: ['connections'] });
    },
    onError: (error) => {
      logger.error('Failed to stop Syncthing', {
        error: error instanceof Error ? error.message : String(error),
      });
      toast.error('Failed to stop Syncthing', {
        description: ErrorHandler.getUserMessage(error),
      });
    },
  });
}

/**
 * Enhanced mutation for restarting Syncthing
 */
export function useRestartSyncthingEnhanced() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async () => {
      logger.info('Restarting Syncthing');
      return await invokeWithRetry<void>('restart_syncthing', undefined, {
        maxAttempts: 1,
        showToast: true,
      });
    },
    onSuccess: () => {
      logger.info('Syncthing restart initiated');
      toast.success('Syncthing restarting...');

      // Reset circuit breaker
      syncthingCircuitBreaker.reset();

      // Wait for restart to complete
      setTimeout(() => {
        queryClient.invalidateQueries({ queryKey: ['systemStatus'] });
        queryClient.invalidateQueries({ queryKey: ['connections'] });
        queryClient.invalidateQueries({ queryKey: ['config'] });
      }, 5000);
    },
    onError: (error) => {
      logger.error('Failed to restart Syncthing', {
        error: error instanceof Error ? error.message : String(error),
      });
      toast.error('Failed to restart Syncthing', {
        description: ErrorHandler.getUserMessage(error),
      });
    },
  });
}
</file>

<file path="src/lib/__tests__/error-test-utils.ts">
// src/lib/__tests__/error-test-utils.ts
// Test utilities for error scenarios

import {
  AppError,
  NetworkError,
  APIError,
  SyncthingError,
  ValidationError,
  ConfigError,
  ErrorHandler,
} from '../errors';
import { logger } from '../logger';

/**
 * Create mock errors for testing
 */
export const mockErrors = {
  network: () =>
    new NetworkError('Network request failed', {
      context: { endpoint: 'http://localhost:8384' },
    }),

  api404: () =>
    new APIError('Resource not found', 404, {
      context: { resource: '/rest/config' },
    }),

  api500: () =>
    new APIError('Internal server error', 500, {
      context: { resource: '/rest/config' },
    }),

  syncthingConnection: () =>
    new SyncthingError('Connection refused', 'CONNECTION_REFUSED', {
      context: { host: '127.0.0.1', port: 8384 },
    }),

  syncthingTimeout: () =>
    new SyncthingError('Request timed out', 'TIMEOUT', {
      context: { command: 'get_system_status', timeout: 10000 },
    }),

  validation: (fields?: Record<string, string[]>) =>
    new ValidationError('Validation failed', fields || { folderId: ['Folder ID is required'] }),

  config: () =>
    new ConfigError('Invalid configuration', {
      context: { field: 'syncthingPort' },
    }),

  generic: () => new Error('Something went wrong'),
};

/**
 * Create error with custom properties for testing
 */
export function createTestError(options: {
  message?: string;
  code?: string;
  recoverable?: boolean;
  userMessage?: string;
}): AppError {
  const {
    message = 'Test error',
    code = 'TEST_ERROR',
    recoverable = true,
    userMessage = 'A test error occurred',
  } = options;

  return new TestError(message, code, { userMessage, recoverable });
}

class TestError extends AppError {
  constructor(
    message: string,
    code: string,
    options: { userMessage?: string; recoverable?: boolean }
  ) {
    super(message, code, options);
  }
}

/**
 * Simulate async operation that fails
 */
export function createFailingOperation(
  error: Error | (() => Error),
  delay = 100
): () => Promise<never> {
  return async () => {
    await new Promise((resolve) => setTimeout(resolve, delay));
    throw typeof error === 'function' ? error() : error;
  };
}

/**
 * Simulate async operation that succeeds after N failures
 */
export function createFlakyOperation<T>(
  result: T,
  failuresBeforeSuccess: number,
  error: Error = new Error('Temporary failure')
): () => Promise<T> {
  let attempts = 0;

  return async () => {
    attempts++;
    if (attempts <= failuresBeforeSuccess) {
      throw error;
    }
    return result;
  };
}

/**
 * Test logger capture
 */
export function createLogCapture() {
  const logs: Array<{ level: string; message: string; context?: Record<string, unknown> }> = [];

  const originalDebug = logger.debug.bind(logger);
  const originalInfo = logger.info.bind(logger);
  const originalWarn = logger.warn.bind(logger);
  const originalError = logger.error.bind(logger);

  const capture = {
    logs,

    start() {
      logger.debug = (message, context) => {
        logs.push({ level: 'debug', message, context });
        originalDebug(message, context);
      };
      logger.info = (message, context) => {
        logs.push({ level: 'info', message, context });
        originalInfo(message, context);
      };
      logger.warn = (message, context) => {
        logs.push({ level: 'warn', message, context });
        originalWarn(message, context);
      };
      logger.error = (message, context) => {
        logs.push({ level: 'error', message, context });
        originalError(message, context);
      };
    },

    stop() {
      logger.debug = originalDebug;
      logger.info = originalInfo;
      logger.warn = originalWarn;
      logger.error = originalError;
    },

    clear() {
      logs.length = 0;
    },

    getByLevel(level: string) {
      return logs.filter((log) => log.level === level);
    },

    getErrors() {
      return this.getByLevel('error');
    },

    getWarnings() {
      return this.getByLevel('warn');
    },
  };

  return capture;
}

/**
 * Assert error properties
 */
export function assertErrorProperties(
  error: unknown,
  expected: {
    code?: string;
    recoverable?: boolean;
    userMessage?: string;
  }
) {
  if (!(error instanceof AppError)) {
    throw new Error(`Expected AppError, got ${error?.constructor.name}`);
  }

  if (expected.code !== undefined && error.code !== expected.code) {
    throw new Error(`Expected code "${expected.code}", got "${error.code}"`);
  }

  if (expected.recoverable !== undefined && error.recoverable !== expected.recoverable) {
    throw new Error(`Expected recoverable=${expected.recoverable}, got ${error.recoverable}`);
  }

  if (expected.userMessage !== undefined && error.userMessage !== expected.userMessage) {
    throw new Error(`Expected userMessage "${expected.userMessage}", got "${error.userMessage}"`);
  }
}

/**
 * Test error handler behavior
 */
export function testErrorHandler() {
  const results = {
    retryable: [] as Array<{ error: unknown; result: boolean }>,
    userMessages: [] as Array<{ error: unknown; message: string }>,
    normalized: [] as Array<{ error: unknown; result: AppError }>,
  };

  // Test isRetryable
  const testErrors = [
    mockErrors.network(),
    mockErrors.api500(),
    mockErrors.api404(),
    mockErrors.syncthingConnection(),
    mockErrors.validation(),
    mockErrors.config(),
    mockErrors.generic(),
  ];

  testErrors.forEach((error) => {
    results.retryable.push({
      error,
      result: ErrorHandler.isRetryable(error),
    });
    results.userMessages.push({
      error,
      message: ErrorHandler.getUserMessage(error),
    });
    results.normalized.push({
      error,
      result: ErrorHandler.normalize(error),
    });
  });

  return results;
}

/**
 * Simulate network conditions
 */
export const networkSimulator = {
  /**
   * Simulate offline mode
   */
  goOffline() {
    if (typeof window !== 'undefined') {
      Object.defineProperty(navigator, 'onLine', {
        value: false,
        writable: true,
      });
      window.dispatchEvent(new Event('offline'));
    }
  },

  /**
   * Simulate online mode
   */
  goOnline() {
    if (typeof window !== 'undefined') {
      Object.defineProperty(navigator, 'onLine', {
        value: true,
        writable: true,
      });
      window.dispatchEvent(new Event('online'));
    }
  },

  /**
   * Simulate slow network
   */
  createSlowFetch(delayMs: number) {
    const originalFetch = globalThis.fetch;

    globalThis.fetch = async (...args) => {
      await new Promise((resolve) => setTimeout(resolve, delayMs));
      return originalFetch(...args);
    };

    return () => {
      globalThis.fetch = originalFetch;
    };
  },

  /**
   * Simulate failing fetch
   */
  createFailingFetch(error: Error = new Error('Network error')) {
    const originalFetch = globalThis.fetch;

    globalThis.fetch = async () => {
      throw error;
    };

    return () => {
      globalThis.fetch = originalFetch;
    };
  },
};

/**
 * Wait for condition with timeout
 */
export async function waitFor(
  condition: () => boolean | Promise<boolean>,
  options: { timeout?: number; interval?: number } = {}
): Promise<void> {
  const { timeout = 5000, interval = 100 } = options;
  const startTime = Date.now();

  while (Date.now() - startTime < timeout) {
    if (await condition()) {
      return;
    }
    await new Promise((resolve) => setTimeout(resolve, interval));
  }

  throw new Error('waitFor timed out');
}

/**
 * Create a deferred promise for testing
 */
export function createDeferred<T>() {
  let resolve: (value: T) => void;
  let reject: (error: Error) => void;

  const promise = new Promise<T>((res, rej) => {
    resolve = res;
    reject = rej;
  });

  return {
    promise,
    resolve: resolve!,
    reject: reject!,
  };
}
</file>

<file path="src/lib/auto-recovery.ts">
// src/lib/auto-recovery.ts
// Automatic recovery service for common failure scenarios

import { invoke } from '@tauri-apps/api/core';
import { logger } from './logger';
import { syncthingCircuitBreaker } from './retry';
import { healthMonitor } from './health-monitor';
import { errorNotifications } from './error-notifications';

export interface RecoveryStrategy {
  name: string;
  condition: () => boolean | Promise<boolean>;
  action: () => Promise<boolean>;
  maxAttempts: number;
  cooldownMs: number;
}

interface RecoveryState {
  attempts: number;
  lastAttempt: Date | null;
  lastSuccess: Date | null;
  isRecovering: boolean;
}

class AutoRecoveryService {
  private strategies: Map<string, RecoveryStrategy> = new Map();
  private state: Map<string, RecoveryState> = new Map();
  private monitorInterval: ReturnType<typeof setInterval> | null = null;
  private isEnabled = true;

  /**
   * Register a recovery strategy
   */
  register(strategy: RecoveryStrategy) {
    this.strategies.set(strategy.name, strategy);
    this.state.set(strategy.name, {
      attempts: 0,
      lastAttempt: null,
      lastSuccess: null,
      isRecovering: false,
    });
    logger.info(`Recovery strategy registered: ${strategy.name}`);
  }

  /**
   * Unregister a recovery strategy
   */
  unregister(name: string) {
    this.strategies.delete(name);
    this.state.delete(name);
  }

  /**
   * Start monitoring for recovery conditions
   */
  startMonitoring(intervalMs = 10000) {
    if (this.monitorInterval) {
      return;
    }

    this.monitorInterval = setInterval(() => {
      this.checkAndRecover();
    }, intervalMs);

    logger.info('Auto-recovery monitoring started', { intervalMs });
  }

  /**
   * Stop monitoring
   */
  stopMonitoring() {
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
      this.monitorInterval = null;
      logger.info('Auto-recovery monitoring stopped');
    }
  }

  /**
   * Enable/disable auto-recovery
   */
  setEnabled(enabled: boolean) {
    this.isEnabled = enabled;
    logger.info(`Auto-recovery ${enabled ? 'enabled' : 'disabled'}`);
  }

  /**
   * Check all strategies and attempt recovery if needed
   */
  private async checkAndRecover() {
    if (!this.isEnabled) return;

    for (const [name, strategy] of this.strategies) {
      const state = this.state.get(name);
      if (!state || state.isRecovering) continue;

      // Check cooldown
      if (state.lastAttempt) {
        const timeSince = Date.now() - state.lastAttempt.getTime();
        if (timeSince < strategy.cooldownMs) continue;
      }

      // Check max attempts
      if (state.attempts >= strategy.maxAttempts) {
        // Reset attempts after cooldown * 2
        if (state.lastAttempt) {
          const timeSince = Date.now() - state.lastAttempt.getTime();
          if (timeSince > strategy.cooldownMs * 2) {
            state.attempts = 0;
          } else {
            continue;
          }
        }
      }

      try {
        const needsRecovery = await strategy.condition();

        if (needsRecovery) {
          await this.executeRecovery(name, strategy);
        }
      } catch (error) {
        logger.error(`Recovery condition check failed: ${name}`, {
          error: error instanceof Error ? error.message : String(error),
        });
      }
    }
  }

  /**
   * Execute a recovery strategy
   */
  private async executeRecovery(name: string, strategy: RecoveryStrategy) {
    const state = this.state.get(name);
    if (!state) return;

    state.isRecovering = true;
    state.attempts++;
    state.lastAttempt = new Date();

    logger.info(`Attempting recovery: ${name}`, {
      attempt: state.attempts,
      maxAttempts: strategy.maxAttempts,
    });

    try {
      const success = await strategy.action();

      if (success) {
        state.lastSuccess = new Date();
        state.attempts = 0;
        logger.info(`Recovery successful: ${name}`);
        errorNotifications.notifyRecovery(name);
      } else {
        logger.warn(`Recovery returned false: ${name}`);
      }
    } catch (error) {
      logger.error(`Recovery failed: ${name}`, {
        error: error instanceof Error ? error.message : String(error),
        attempt: state.attempts,
      });

      if (state.attempts >= strategy.maxAttempts) {
        errorNotifications.notify(error, {
          showToast: true,
          autoRecover: false,
        });
      }
    } finally {
      state.isRecovering = false;
    }
  }

  /**
   * Manually trigger recovery for a specific strategy
   */
  async triggerRecovery(name: string): Promise<boolean> {
    const strategy = this.strategies.get(name);
    if (!strategy) {
      logger.warn(`Recovery strategy not found: ${name}`);
      return false;
    }

    const state = this.state.get(name);
    if (state?.isRecovering) {
      logger.warn(`Recovery already in progress: ${name}`);
      return false;
    }

    await this.executeRecovery(name, strategy);
    return this.state.get(name)?.lastSuccess !== null;
  }

  /**
   * Get recovery state for debugging
   */
  getState(): Map<string, RecoveryState> {
    return new Map(this.state);
  }

  /**
   * Reset recovery state for a strategy
   */
  resetState(name: string) {
    const state = this.state.get(name);
    if (state) {
      state.attempts = 0;
      state.lastAttempt = null;
      state.isRecovering = false;
    }
  }
}

// Global instance
export const autoRecovery = new AutoRecoveryService();

/**
 * Register default recovery strategies
 */
export function registerDefaultRecoveryStrategies() {
  // Syncthing connection recovery
  autoRecovery.register({
    name: 'syncthing-connection',
    condition: async () => {
      const status = healthMonitor.getCheckStatus('syncthing-api');
      return status ? !status.healthy && status.consecutiveFailures >= 2 : false;
    },
    action: async () => {
      try {
        // First, try a simple ping
        const response = await fetch('http://127.0.0.1:8384/rest/system/ping', {
          method: 'GET',
          signal: AbortSignal.timeout(5000),
        });

        if (response.ok) {
          // Reset circuit breaker if ping succeeds
          syncthingCircuitBreaker.reset();
          return true;
        }

        // If ping fails, try restarting Syncthing
        logger.info('Attempting to restart Syncthing');
        await invoke('restart_syncthing');

        // Wait for restart
        await new Promise((resolve) => setTimeout(resolve, 3000));

        // Check again
        const retryResponse = await fetch('http://127.0.0.1:8384/rest/system/ping', {
          method: 'GET',
          signal: AbortSignal.timeout(5000),
        });

        if (retryResponse.ok) {
          syncthingCircuitBreaker.reset();
          return true;
        }

        return false;
      } catch {
        return false;
      }
    },
    maxAttempts: 3,
    cooldownMs: 30000, // Wait 30s between attempts
  });

  // Circuit breaker recovery
  autoRecovery.register({
    name: 'circuit-breaker',
    condition: () => {
      const state = syncthingCircuitBreaker.getState();
      // Try to recover if circuit is open for more than 1 minute
      return state.state === 'open';
    },
    action: async () => {
      try {
        // Test connection before resetting
        const response = await fetch('http://127.0.0.1:8384/rest/system/ping', {
          method: 'GET',
          signal: AbortSignal.timeout(5000),
        });

        if (response.ok) {
          syncthingCircuitBreaker.reset();
          return true;
        }
        return false;
      } catch {
        return false;
      }
    },
    maxAttempts: 5,
    cooldownMs: 60000, // Wait 1 minute between attempts
  });

  // Memory pressure recovery
  autoRecovery.register({
    name: 'memory-pressure',
    condition: async () => {
      if (typeof window === 'undefined' || !('memory' in performance)) {
        return false;
      }

      const memory = (
        performance as Performance & {
          memory?: { usedJSHeapSize: number; jsHeapSizeLimit: number };
        }
      ).memory;
      if (!memory) return false;

      const usedPercent = (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100;
      return usedPercent > 85;
    },
    action: async () => {
      logger.info('Attempting memory cleanup');

      // Clear logger history (keeping last 100)
      const { logger: appLogger } = await import('./logger');
      const recentLogs = appLogger.getRecentLogs(100);
      appLogger.clearHistory();
      recentLogs.forEach((log) => {
        appLogger[log.level](log.message, log.context);
      });

      // Suggest garbage collection
      if (typeof window !== 'undefined' && 'gc' in window) {
        (window as Window & { gc?: () => void }).gc?.();
      }

      return true;
    },
    maxAttempts: 3,
    cooldownMs: 120000, // Wait 2 minutes between cleanups
  });

  logger.info('Default recovery strategies registered');
}
</file>

<file path="src/lib/db.ts">
/**
 * IndexedDB schema and utilities for file metadata and embeddings
 */
import { openDB, DBSchema, IDBPDatabase } from 'idb';

// Database schema
interface EigenDB extends DBSchema {
  files: {
    key: string; // Full path
    value: FileMetadata;
    indexes: {
      'by-folder': string;
      'by-name': string;
      'by-modified': number;
    };
  };
  embeddings: {
    key: string; // Full path
    value: FileEmbedding;
  };
  searchHistory: {
    key: number; // Auto-increment
    value: SearchHistoryEntry;
    indexes: {
      'by-query': string;
      'by-date': number;
    };
  };
  activityLog: {
    key: number;
    value: ActivityLogEntry;
    indexes: {
      'by-path': string;
      'by-date': number;
      'by-action': string;
    };
  };
}

export interface FileMetadata {
  path: string;
  name: string;
  folderId: string;
  folderPath: string;
  size: number;
  modified: number;
  isDirectory: boolean;
  extension?: string;
  indexed: number; // When it was indexed
}

export interface FileEmbedding {
  path: string;
  embedding: number[]; // Vector embedding
  model: string;
  createdAt: number;
}

export interface SearchHistoryEntry {
  query: string;
  resultCount: number;
  selectedPath?: string;
  timestamp: number;
}

export interface ActivityLogEntry {
  path: string;
  action: 'open' | 'sync' | 'modify' | 'search';
  timestamp: number;
  details?: string;
}

const DB_NAME = 'eigen-ai';
const DB_VERSION = 1;

let dbInstance: IDBPDatabase<EigenDB> | null = null;

/**
 * Get or create the database instance
 */
export async function getDB(): Promise<IDBPDatabase<EigenDB>> {
  if (dbInstance) return dbInstance;

  dbInstance = await openDB<EigenDB>(DB_NAME, DB_VERSION, {
    upgrade(db) {
      // Files store
      if (!db.objectStoreNames.contains('files')) {
        const fileStore = db.createObjectStore('files', { keyPath: 'path' });
        fileStore.createIndex('by-folder', 'folderId');
        fileStore.createIndex('by-name', 'name');
        fileStore.createIndex('by-modified', 'modified');
      }

      // Embeddings store
      if (!db.objectStoreNames.contains('embeddings')) {
        db.createObjectStore('embeddings', { keyPath: 'path' });
      }

      // Search history store
      if (!db.objectStoreNames.contains('searchHistory')) {
        const historyStore = db.createObjectStore('searchHistory', {
          keyPath: 'id',
          autoIncrement: true,
        });
        historyStore.createIndex('by-query', 'query');
        historyStore.createIndex('by-date', 'timestamp');
      }

      // Activity log store
      if (!db.objectStoreNames.contains('activityLog')) {
        const activityStore = db.createObjectStore('activityLog', {
          keyPath: 'id',
          autoIncrement: true,
        });
        activityStore.createIndex('by-path', 'path');
        activityStore.createIndex('by-date', 'timestamp');
        activityStore.createIndex('by-action', 'action');
      }
    },
  });

  return dbInstance;
}

// ============================================================================
// File Operations
// ============================================================================

/**
 * Add or update file metadata
 */
export async function upsertFile(file: FileMetadata): Promise<void> {
  const db = await getDB();
  await db.put('files', file);
}

/**
 * Bulk add files (for initial indexing)
 */
export async function bulkUpsertFiles(files: FileMetadata[]): Promise<void> {
  const db = await getDB();
  const tx = db.transaction('files', 'readwrite');
  await Promise.all([...files.map((file) => tx.store.put(file)), tx.done]);
}

/**
 * Get all files for a folder
 */
export async function getFilesByFolder(folderId: string): Promise<FileMetadata[]> {
  const db = await getDB();
  return db.getAllFromIndex('files', 'by-folder', folderId);
}

/**
 * Search files by name (simple substring match)
 */
export async function searchFilesByName(query: string): Promise<FileMetadata[]> {
  const db = await getDB();
  const allFiles = await db.getAll('files');
  const lowerQuery = query.toLowerCase();
  return allFiles.filter(
    (file) =>
      file.name.toLowerCase().includes(lowerQuery) || file.path.toLowerCase().includes(lowerQuery)
  );
}

/**
 * Get file count
 */
export async function getFileCount(): Promise<number> {
  const db = await getDB();
  return db.count('files');
}

/**
 * Clear all files for a folder (for re-indexing)
 */
export async function clearFilesForFolder(folderId: string): Promise<void> {
  const db = await getDB();
  const files = await db.getAllFromIndex('files', 'by-folder', folderId);
  const tx = db.transaction('files', 'readwrite');
  await Promise.all([...files.map((file) => tx.store.delete(file.path)), tx.done]);
}

// ============================================================================
// Embedding Operations
// ============================================================================

/**
 * Store embedding for a file
 */
export async function storeEmbedding(embedding: FileEmbedding): Promise<void> {
  const db = await getDB();
  await db.put('embeddings', embedding);
}

/**
 * Bulk store embeddings
 */
export async function bulkStoreEmbeddings(embeddings: FileEmbedding[]): Promise<void> {
  const db = await getDB();
  const tx = db.transaction('embeddings', 'readwrite');
  await Promise.all([...embeddings.map((emb) => tx.store.put(emb)), tx.done]);
}

/**
 * Get embedding for a file
 */
export async function getEmbedding(path: string): Promise<FileEmbedding | undefined> {
  const db = await getDB();
  return db.get('embeddings', path);
}

/**
 * Get all embeddings (for semantic search)
 */
export async function getAllEmbeddings(): Promise<FileEmbedding[]> {
  const db = await getDB();
  return db.getAll('embeddings');
}

/**
 * Get files without embeddings
 */
export async function getFilesWithoutEmbeddings(): Promise<FileMetadata[]> {
  const db = await getDB();
  const files = await db.getAll('files');
  const embeddingPaths = new Set(await db.getAllKeys('embeddings'));
  return files.filter((file) => !embeddingPaths.has(file.path));
}

// ============================================================================
// Activity Logging
// ============================================================================

/**
 * Log an activity
 */
export async function logActivity(entry: Omit<ActivityLogEntry, 'timestamp'>): Promise<void> {
  const db = await getDB();
  await db.add('activityLog', {
    ...entry,
    timestamp: Date.now(),
  });
}

/**
 * Get recent activity for a path (for predictive sync)
 */
export async function getActivityForPath(path: string, limit = 100): Promise<ActivityLogEntry[]> {
  const db = await getDB();
  const entries = await db.getAllFromIndex('activityLog', 'by-path', path);
  return entries.slice(-limit);
}

/**
 * Get most accessed files (for predictive sync)
 */
export async function getMostAccessedFiles(limit = 50): Promise<{ path: string; count: number }[]> {
  const db = await getDB();
  const entries = await db.getAll('activityLog');

  // Count accesses per path
  const counts = new Map<string, number>();
  for (const entry of entries) {
    counts.set(entry.path, (counts.get(entry.path) || 0) + 1);
  }

  // Sort by count and return top N
  return Array.from(counts.entries())
    .map(([path, count]) => ({ path, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, limit);
}

// ============================================================================
// Search History
// ============================================================================

/**
 * Log a search query
 */
export async function logSearch(
  query: string,
  resultCount: number,
  selectedPath?: string
): Promise<void> {
  const db = await getDB();
  await db.add('searchHistory', {
    query,
    resultCount,
    selectedPath,
    timestamp: Date.now(),
  });
}

/**
 * Get recent searches
 */
export async function getRecentSearches(limit = 10): Promise<SearchHistoryEntry[]> {
  const db = await getDB();
  const entries = await db.getAllFromIndex('searchHistory', 'by-date');
  return entries.slice(-limit).reverse();
}

// ============================================================================
// Database Management
// ============================================================================

/**
 * Clear all data
 */
export async function clearAllData(): Promise<void> {
  const db = await getDB();
  await Promise.all([
    db.clear('files'),
    db.clear('embeddings'),
    db.clear('searchHistory'),
    db.clear('activityLog'),
  ]);
}

/**
 * Get database stats
 */
export async function getDBStats(): Promise<{
  fileCount: number;
  embeddingCount: number;
  activityCount: number;
  searchCount: number;
}> {
  const db = await getDB();
  return {
    fileCount: await db.count('files'),
    embeddingCount: await db.count('embeddings'),
    activityCount: await db.count('activityLog'),
    searchCount: await db.count('searchHistory'),
  };
}
</file>

<file path="src/lib/error-notifications.ts">
// src/lib/error-notifications.ts
// Global error notification system with auto-recovery

import { toast } from 'sonner';
import { logger } from './logger';
import { AppError, ErrorHandler, ErrorRecovery } from './errors';
import { syncthingCircuitBreaker } from './retry';

export interface ErrorNotificationOptions {
  showToast?: boolean;
  autoRecover?: boolean;
  retryAction?: () => Promise<void>;
  dismissable?: boolean;
  duration?: number;
}

type ErrorSeverity = 'info' | 'warning' | 'error' | 'critical';

interface ErrorEvent {
  id: string;
  error: AppError | Error;
  severity: ErrorSeverity;
  timestamp: Date;
  recovered: boolean;
  notified: boolean;
}

class ErrorNotificationService {
  private recentErrors: Map<string, ErrorEvent> = new Map();
  private readonly maxRecentErrors = 50;
  private readonly dedupeWindowMs = 5000; // Don't show same error twice in 5s

  /**
   * Notify user of an error with appropriate toast
   */
  notify(error: unknown, options: ErrorNotificationOptions = {}): string {
    const {
      showToast = true,
      autoRecover = true,
      retryAction,
      dismissable = true,
      duration = 5000,
    } = options;

    const normalized = ErrorHandler.normalize(error);
    const severity = this.getSeverity(normalized);
    const errorId = this.generateErrorId(normalized);

    // Check for duplicate errors
    if (this.isDuplicate(errorId)) {
      logger.debug('Suppressing duplicate error notification', { errorId });
      return errorId;
    }

    // Log the error
    logger.error('Error notification', {
      code: normalized.code,
      message: normalized.message,
      userMessage: normalized.userMessage,
      recoverable: normalized.recoverable,
      severity,
    });

    // Store error event
    this.storeError(errorId, normalized, severity);

    // Show toast notification
    if (showToast) {
      this.showToast(normalized, severity, {
        retryAction,
        dismissable,
        duration,
        errorId,
      });
    }

    // Attempt auto-recovery
    if (autoRecover && normalized.recoverable) {
      this.attemptAutoRecovery(normalized, errorId);
    }

    return errorId;
  }

  /**
   * Show success notification
   */
  success(message: string, description?: string) {
    toast.success(message, { description });
    logger.info(message, { description });
  }

  /**
   * Show warning notification
   */
  warning(message: string, description?: string) {
    toast.warning(message, { description });
    logger.warn(message, { description });
  }

  /**
   * Show info notification
   */
  info(message: string, description?: string) {
    toast.info(message, { description });
    logger.info(message, { description });
  }

  /**
   * Notify about connection recovery
   */
  notifyRecovery(serviceName: string = 'Connection') {
    toast.success(`${serviceName} restored`, {
      description: 'The connection has been re-established',
    });
    logger.info(`${serviceName} recovered`);
  }

  /**
   * Notify about ongoing connection issues
   */
  notifyConnectionIssue(retryAction?: () => void) {
    const toastId = toast.error('Connection lost', {
      description: 'Attempting to reconnect...',
      duration: Infinity,
      action: retryAction
        ? {
            label: 'Retry Now',
            onClick: retryAction,
          }
        : undefined,
    });
    logger.warn('Connection lost, attempting recovery');
    return toastId;
  }

  /**
   * Dismiss a specific toast
   */
  dismiss(toastId: string | number) {
    toast.dismiss(toastId);
  }

  /**
   * Get error severity based on error type
   */
  private getSeverity(error: AppError): ErrorSeverity {
    // Critical errors - system is unusable
    if (!error.recoverable) {
      return 'critical';
    }

    // Check specific error codes
    switch (error.code) {
      case 'NETWORK_ERROR':
      case 'SYNCTHING_CONNECTION_REFUSED':
        return 'warning';
      case 'VALIDATION_ERROR':
        return 'info';
      case 'CONFIG_ERROR':
        return 'critical';
      default:
        if (error.statusCode && error.statusCode >= 500) {
          return 'error';
        }
        return 'warning';
    }
  }

  /**
   * Generate unique error ID for deduplication
   */
  private generateErrorId(error: AppError): string {
    return `${error.code}-${error.message.slice(0, 50)}`;
  }

  /**
   * Check if this error was recently shown
   */
  private isDuplicate(errorId: string): boolean {
    const existing = this.recentErrors.get(errorId);
    if (!existing) return false;

    const timeSince = Date.now() - existing.timestamp.getTime();
    return timeSince < this.dedupeWindowMs;
  }

  /**
   * Store error in recent errors map
   */
  private storeError(errorId: string, error: AppError, severity: ErrorSeverity) {
    const event: ErrorEvent = {
      id: errorId,
      error,
      severity,
      timestamp: new Date(),
      recovered: false,
      notified: true,
    };

    this.recentErrors.set(errorId, event);

    // Cleanup old errors
    if (this.recentErrors.size > this.maxRecentErrors) {
      const oldestKey = this.recentErrors.keys().next().value;
      if (oldestKey) {
        this.recentErrors.delete(oldestKey);
      }
    }
  }

  /**
   * Show toast based on severity
   */
  private showToast(
    error: AppError,
    severity: ErrorSeverity,
    options: {
      retryAction?: () => Promise<void>;
      dismissable: boolean;
      duration: number;
      errorId: string;
    }
  ) {
    const { retryAction, dismissable, duration, errorId } = options;

    const toastOptions: Parameters<typeof toast.error>[1] = {
      description: error.userMessage,
      duration: severity === 'critical' ? Infinity : duration,
      dismissible: dismissable,
      id: errorId,
    };

    // Add retry action if provided and error is recoverable
    if (retryAction && error.recoverable) {
      toastOptions.action = {
        label: 'Retry',
        onClick: async () => {
          try {
            await retryAction();
            this.markRecovered(errorId);
          } catch (retryError) {
            this.notify(retryError, { autoRecover: false });
          }
        },
      };
    }

    // Show appropriate toast type
    switch (severity) {
      case 'critical':
        toast.error(` ${this.getErrorTitle(error)}`, toastOptions);
        break;
      case 'error':
        toast.error(this.getErrorTitle(error), toastOptions);
        break;
      case 'warning':
        toast.warning(this.getErrorTitle(error), toastOptions);
        break;
      case 'info':
        toast.info(this.getErrorTitle(error), toastOptions);
        break;
    }
  }

  /**
   * Get user-friendly error title
   */
  private getErrorTitle(error: AppError): string {
    switch (error.code) {
      case 'NETWORK_ERROR':
        return 'Network Error';
      case 'SYNCTHING_CONNECTION_REFUSED':
        return 'Syncthing Unavailable';
      case 'SYNCTHING_TIMEOUT':
        return 'Request Timeout';
      case 'VALIDATION_ERROR':
        return 'Invalid Input';
      case 'CONFIG_ERROR':
        return 'Configuration Error';
      case 'FILESYSTEM_ERROR':
        return 'File System Error';
      case 'DATABASE_ERROR':
        return 'Database Error';
      default:
        if (error.code.startsWith('API_ERROR_')) {
          return 'API Error';
        }
        return 'Error';
    }
  }

  /**
   * Attempt automatic recovery
   */
  private async attemptAutoRecovery(error: AppError, errorId: string) {
    // Check if recovery strategy exists
    if (!ErrorRecovery.hasStrategy(error.code)) {
      return;
    }

    logger.info('Attempting auto-recovery', { errorCode: error.code });

    try {
      const recovered = await ErrorRecovery.attempt(error);

      if (recovered) {
        this.markRecovered(errorId);
        toast.success('Recovered', {
          description: 'The issue has been resolved automatically',
        });
      }
    } catch (recoveryError) {
      logger.error('Auto-recovery failed', {
        errorCode: error.code,
        recoveryError:
          recoveryError instanceof Error ? recoveryError.message : String(recoveryError),
      });
    }
  }

  /**
   * Mark error as recovered
   */
  private markRecovered(errorId: string) {
    const event = this.recentErrors.get(errorId);
    if (event) {
      event.recovered = true;
      this.recentErrors.set(errorId, event);
    }
    toast.dismiss(errorId);
  }

  /**
   * Get recent errors for debugging
   */
  getRecentErrors(): ErrorEvent[] {
    return Array.from(this.recentErrors.values());
  }

  /**
   * Clear all recent errors
   */
  clearRecentErrors() {
    this.recentErrors.clear();
  }

  /**
   * Check circuit breaker and notify if open
   */
  checkCircuitBreaker(): boolean {
    const state = syncthingCircuitBreaker.getState();

    if (state.state === 'open') {
      toast.error('Service Temporarily Unavailable', {
        description: 'Too many failures detected. Please wait before retrying.',
        duration: 10000,
        action: {
          label: 'Reset',
          onClick: () => {
            syncthingCircuitBreaker.reset();
            toast.success('Circuit breaker reset');
          },
        },
      });
      return true;
    }

    return false;
  }
}

// Global instance
export const errorNotifications = new ErrorNotificationService();

// Convenience exports
export const notifyError = (error: unknown, options?: ErrorNotificationOptions) =>
  errorNotifications.notify(error, options);

export const notifySuccess = (message: string, description?: string) =>
  errorNotifications.success(message, description);

export const notifyWarning = (message: string, description?: string) =>
  errorNotifications.warning(message, description);

export const notifyInfo = (message: string, description?: string) =>
  errorNotifications.info(message, description);
</file>

<file path="src/lib/errors.ts">
// src/lib/errors.ts
import { logger } from './logger';

/**
 * Base error class with rich context
 */
export abstract class AppError extends Error {
  public readonly timestamp: Date;
  public readonly code: string;
  public readonly statusCode?: number;
  public readonly context?: Record<string, unknown>;
  public readonly userMessage: string;
  public readonly recoverable: boolean;

  constructor(
    message: string,
    code: string,
    options: {
      userMessage?: string;
      statusCode?: number;
      context?: Record<string, unknown>;
      recoverable?: boolean;
      cause?: Error;
    } = {}
  ) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.timestamp = new Date();
    this.userMessage = options.userMessage || message;
    this.statusCode = options.statusCode;
    this.context = options.context;
    this.recoverable = options.recoverable ?? true;

    if (options.cause) {
      this.cause = options.cause;
    }

    // Capture stack trace properly
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }

  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      userMessage: this.userMessage,
      timestamp: this.timestamp.toISOString(),
      statusCode: this.statusCode,
      context: this.context,
      recoverable: this.recoverable,
      stack: this.stack,
    };
  }
}

/**
 * Network-related errors
 */
export class NetworkError extends AppError {
  constructor(
    message: string,
    options?: {
      userMessage?: string;
      context?: Record<string, unknown>;
      cause?: Error;
    }
  ) {
    super(message, 'NETWORK_ERROR', {
      ...options,
      userMessage:
        options?.userMessage || 'Network connection failed. Please check your connection.',
      statusCode: 0,
      recoverable: true,
    });
  }
}

/**
 * API/HTTP errors
 */
export class APIError extends AppError {
  constructor(
    message: string,
    statusCode: number,
    options?: {
      userMessage?: string;
      context?: Record<string, unknown>;
      cause?: Error;
    }
  ) {
    const code = `API_ERROR_${statusCode}`;
    const userMessage = options?.userMessage || APIError.getDefaultMessage(statusCode);

    super(message, code, {
      ...options,
      userMessage,
      statusCode,
      recoverable: statusCode < 500,
    });
  }

  static getDefaultMessage(statusCode: number): string {
    const messages: Record<number, string> = {
      400: 'Bad request - please check your input',
      401: 'Authentication required - please log in',
      403: 'Access denied - you do not have permission',
      404: 'Resource not found',
      429: 'Too many requests - please slow down',
      500: 'Server error - please try again later',
      502: 'Bad gateway - service temporarily unavailable',
      503: 'Service unavailable - please try again later',
    };
    return messages[statusCode] || 'An error occurred';
  }
}

/**
 * Syncthing-specific errors
 */
export class SyncthingError extends AppError {
  constructor(
    message: string,
    code: string,
    options?: {
      userMessage?: string;
      context?: Record<string, unknown>;
      cause?: Error;
    }
  ) {
    super(message, `SYNCTHING_${code}`, {
      ...options,
      userMessage: options?.userMessage || SyncthingError.getDefaultMessage(code),
    });
  }

  static getDefaultMessage(code: string): string {
    const messages: Record<string, string> = {
      CONNECTION_REFUSED: 'Cannot connect to Syncthing. Is it running?',
      TIMEOUT: 'Syncthing is taking too long to respond',
      NOT_RUNNING: 'Syncthing is not running',
      CONFIG_ERROR: 'Syncthing configuration error',
      FOLDER_NOT_FOUND: 'Folder not found in Syncthing',
      DEVICE_NOT_FOUND: 'Device not found in Syncthing',
      API_KEY_INVALID: 'Invalid Syncthing API key',
    };
    return messages[code] || 'Syncthing operation failed';
  }
}

/**
 * Validation errors
 */
export class ValidationError extends AppError {
  public readonly fields?: Record<string, string[]>;

  constructor(
    message: string,
    fields?: Record<string, string[]>,
    options?: {
      userMessage?: string;
      context?: Record<string, unknown>;
    }
  ) {
    super(message, 'VALIDATION_ERROR', {
      ...options,
      userMessage: options?.userMessage || 'Invalid input - please check your data',
      recoverable: true,
    });
    this.fields = fields;
  }
}

/**
 * Configuration errors
 */
export class ConfigError extends AppError {
  constructor(
    message: string,
    options?: {
      userMessage?: string;
      context?: Record<string, unknown>;
    }
  ) {
    super(message, 'CONFIG_ERROR', {
      ...options,
      userMessage: options?.userMessage || 'Configuration error - please check your settings',
      recoverable: false,
    });
  }
}

/**
 * File system errors
 */
export class FileSystemError extends AppError {
  constructor(
    message: string,
    options?: {
      userMessage?: string;
      context?: Record<string, unknown>;
      cause?: Error;
    }
  ) {
    super(message, 'FILESYSTEM_ERROR', {
      ...options,
      userMessage: options?.userMessage || 'File system error - check permissions',
    });
  }
}

/**
 * Database errors
 */
export class DatabaseError extends AppError {
  constructor(
    message: string,
    options?: {
      userMessage?: string;
      context?: Record<string, unknown>;
      cause?: Error;
    }
  ) {
    super(message, 'DATABASE_ERROR', {
      ...options,
      userMessage: options?.userMessage || 'Database operation failed',
    });
  }
}

/**
 * Invoke (Tauri) errors
 */
export class InvokeError extends AppError {
  constructor(
    message: string,
    command: string,
    options?: {
      userMessage?: string;
      context?: Record<string, unknown>;
      cause?: Error;
    }
  ) {
    super(message, 'INVOKE_ERROR', {
      ...options,
      userMessage: options?.userMessage || `Failed to execute command: ${command}`,
      context: { ...options?.context, command },
    });
  }
}

/**
 * Error handler utilities
 */
export class ErrorHandler {
  /**
   * Determine if an error is retryable
   */
  static isRetryable(error: unknown): boolean {
    if (error instanceof AppError) {
      return error.recoverable;
    }

    if (error instanceof Error) {
      // Network errors are retryable
      if (error.message.includes('network') || error.message.includes('fetch')) {
        return true;
      }
      // Timeout errors are retryable
      if (error.message.includes('timeout') || error.message.includes('ETIMEDOUT')) {
        return true;
      }
      // Connection errors are retryable
      if (error.message.includes('ECONNREFUSED') || error.message.includes('ECONNRESET')) {
        return true;
      }
    }

    return false;
  }

  /**
   * Get user-friendly error message
   */
  static getUserMessage(error: unknown): string {
    if (error instanceof AppError) {
      return error.userMessage;
    }

    if (error instanceof Error) {
      // Map common error messages
      if (error.message.includes('ECONNREFUSED')) {
        return 'Cannot connect to Syncthing. Is it running?';
      }
      if (error.message.includes('ETIMEDOUT')) {
        return 'Connection timed out. Please try again.';
      }
      if (error.message.includes('ENOTFOUND')) {
        return 'Could not find server. Check your network connection.';
      }
      if (error.message.includes('ECONNRESET')) {
        return 'Connection was reset. Please try again.';
      }

      return error.message;
    }

    return 'An unexpected error occurred';
  }

  /**
   * Get error code
   */
  static getErrorCode(error: unknown): string {
    if (error instanceof AppError) {
      return error.code;
    }
    return 'UNKNOWN_ERROR';
  }

  /**
   * Convert unknown error to AppError
   */
  static normalize(error: unknown, defaultMessage = 'An error occurred'): AppError {
    if (error instanceof AppError) {
      return error;
    }

    if (error instanceof Error) {
      // Try to infer error type
      if (error.message.includes('network') || error.message.includes('fetch')) {
        return new NetworkError(error.message, { cause: error });
      }
      if (error.message.includes('ECONNREFUSED')) {
        return new SyncthingError(error.message, 'CONNECTION_REFUSED', { cause: error });
      }

      // Generic unknown error - create a concrete implementation
      return new UnknownError(error.message, { userMessage: defaultMessage, cause: error });
    }

    return new UnknownError(String(error), { userMessage: defaultMessage });
  }

  /**
   * Report error to logging service
   */
  static report(error: unknown, context?: Record<string, unknown>) {
    const normalized = this.normalize(error);

    logger.error('Error Report', {
      ...normalized.toJSON(),
      additionalContext: context,
    });

    // TODO: Send to error tracking service (Sentry, etc.)
    // sentry.captureException(normalized, { contexts: { custom: context } });
  }
}

/**
 * Unknown/generic errors
 */
export class UnknownError extends AppError {
  constructor(
    message: string,
    options?: {
      userMessage?: string;
      context?: Record<string, unknown>;
      cause?: Error;
    }
  ) {
    super(message, 'UNKNOWN_ERROR', {
      ...options,
      userMessage: options?.userMessage || 'An unexpected error occurred',
      recoverable: true,
    });
  }
}

/**
 * Error recovery strategies
 */
export class ErrorRecovery {
  private static strategies = new Map<string, () => Promise<void>>();

  /**
   * Register recovery strategy for error code
   */
  static register(errorCode: string, strategy: () => Promise<void>) {
    this.strategies.set(errorCode, strategy);
  }

  /**
   * Attempt to recover from error
   */
  static async attempt(error: AppError): Promise<boolean> {
    const strategy = this.strategies.get(error.code);

    if (!strategy) {
      return false;
    }

    try {
      await strategy();
      logger.info('Error recovery succeeded', { errorCode: error.code });
      return true;
    } catch (recoveryError) {
      ErrorHandler.report(recoveryError, {
        originalError: error.code,
        recovery: 'failed',
      });
      return false;
    }
  }

  /**
   * Check if recovery strategy exists
   */
  static hasStrategy(errorCode: string): boolean {
    return this.strategies.has(errorCode);
  }
}

// Register default recovery strategies
ErrorRecovery.register('NETWORK_ERROR', async () => {
  // Wait and retry connection
  await new Promise((resolve) => setTimeout(resolve, 2000));
});

ErrorRecovery.register('SYNCTHING_CONNECTION_REFUSED', async () => {
  // Could try to start Syncthing via Tauri
  // await invoke('start_syncthing_sidecar');
  await new Promise((resolve) => setTimeout(resolve, 3000));
});
</file>

<file path="src/lib/logger.ts">
// src/lib/logger.ts
type LogLevel = 'debug' | 'info' | 'warn' | 'error';

interface LogContext {
    component?: string;
    action?: string;
    [key: string]: unknown;
}

interface LogEntry {
    timestamp: Date;
    level: LogLevel;
    message: string;
    context?: LogContext;
}

class Logger {
    private level: LogLevel = process.env.NODE_ENV === 'development' ? 'debug' : 'info';
    private history: LogEntry[] = [];
    private maxHistory = 1000;
    private listeners: Set<() => void> = new Set();

    setLevel(level: LogLevel) {
        this.level = level;
    }

    private shouldLog(level: LogLevel): boolean {
        const levels: LogLevel[] = ['debug', 'info', 'warn', 'error'];
        return levels.indexOf(level) >= levels.indexOf(this.level);
    }

    private log(level: LogLevel, message: string, context?: LogContext) {
        if (!this.shouldLog(level)) return;

        const entry: LogEntry = {
            timestamp: new Date(),
            level,
            message,
            context,
        };

        // Store in history
        this.history.push(entry);
        if (this.history.length > this.maxHistory) {
            this.history.shift();
        }

        // Console output with colors (works in browser and Node.js dev mode)
        const colors = {
            debug: '\x1b[36m', // cyan
            info: '\x1b[32m', // green
            warn: '\x1b[33m', // yellow
            error: '\x1b[31m', // red
        };
        const reset = '\x1b[0m';

        const timestamp = entry.timestamp.toISOString();
        const contextStr = context ? ` ${JSON.stringify(context)}` : '';

        // Use appropriate console method
        if (typeof window !== 'undefined') {
            // Browser - use console styles
            const browserColors = {
                debug: 'color: #06b6d4',
                info: 'color: #22c55e',
                warn: 'color: #eab308',
                error: 'color: #ef4444',
            };
            // Filter out undefined values from context and only include if non-empty
            const filteredContext = context
                ? Object.fromEntries(Object.entries(context).filter(([, v]) => v !== undefined))
                : null;
            const hasContext = filteredContext && Object.keys(filteredContext).length > 0;
            console[level === 'debug' ? 'log' : level](
                `%c[${level.toUpperCase()}] ${timestamp}`,
                browserColors[level],
                message,
                ...(hasContext ? [filteredContext] : [])
            );
        } else {
            // Node.js
            console.log(
                `${colors[level]}[${level.toUpperCase()}] ${timestamp}${reset} ${message}${contextStr}`
            );
        }

        // Notify listeners
        this.notifyListeners();
    }

    debug(message: string, context?: LogContext) {
        this.log('debug', message, context);
    }

    info(message: string, context?: LogContext) {
        this.log('info', message, context);
    }

    warn(message: string, context?: LogContext) {
        this.log('warn', message, context);
    }

    error(message: string, context?: LogContext) {
        this.log('error', message, context);
    }

    // Export logs for debugging
    exportLogs(): LogEntry[] {
        return [...this.history];
    }

    // Download logs as JSON
    downloadLogs() {
        if (typeof window === 'undefined') return;

        const blob = new Blob([JSON.stringify(this.history, null, 2)], {
            type: 'application/json',
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `eigen-logs-${new Date().toISOString()}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    clearHistory() {
        this.history = [];
        this.notifyListeners();
    }

    // Subscribe to log updates
    subscribe(listener: () => void) {
        this.listeners.add(listener);
        return () => this.listeners.delete(listener);
    }

    private notifyListeners() {
        this.listeners.forEach((listener) => {
            try {
                listener();
            } catch (e) {
                console.error('Logger listener error:', e);
            }
        });
    }

    // Get logs by level
    getLogsByLevel(level: LogLevel): LogEntry[] {
        return this.history.filter((entry) => entry.level === level);
    }

    // Get recent logs
    getRecentLogs(count: number = 100): LogEntry[] {
        return this.history.slice(-count);
    }

    // Get error count
    getErrorCount(): number {
        return this.history.filter((entry) => entry.level === 'error').length;
    }

    // Get warning count
    getWarningCount(): number {
        return this.history.filter((entry) => entry.level === 'warn').length;
    }
}

export const logger = new Logger();
export type { LogLevel, LogContext, LogEntry };
</file>

<file path="src/lib/retry.ts">
// src/lib/retry.ts
import { logger } from './logger';

export interface RetryOptions {
  maxAttempts?: number;
  initialDelay?: number;
  maxDelay?: number;
  backoffMultiplier?: number;
  shouldRetry?: (error: unknown) => boolean;
  onRetry?: (attempt: number, error: unknown) => void;
}

export class RetryableError extends Error {
  constructor(
    message: string,
    public readonly originalError: unknown,
    public readonly attempt: number
  ) {
    super(message);
    this.name = 'RetryableError';
  }
}

/**
 * Exponential backoff with jitter
 */
function calculateDelay(
  attempt: number,
  initialDelay: number,
  maxDelay: number,
  backoffMultiplier: number
): number {
  const exponentialDelay = initialDelay * Math.pow(backoffMultiplier, attempt - 1);
  const clampedDelay = Math.min(exponentialDelay, maxDelay);
  // Add jitter (25%)
  const jitter = clampedDelay * 0.25 * (Math.random() * 2 - 1);
  return Math.floor(clampedDelay + jitter);
}

/**
 * Default retry predicate - retry on network errors and 5xx status codes
 */
function defaultShouldRetry(error: unknown): boolean {
  if (error instanceof Error) {
    // Network errors
    if (error.message.includes('fetch') || error.message.includes('network')) {
      return true;
    }
    // Connection errors
    if (error.message.includes('ECONNREFUSED') || error.message.includes('ETIMEDOUT')) {
      return true;
    }
    if (error.message.includes('ECONNRESET') || error.message.includes('ENOTFOUND')) {
      return true;
    }
  }

  // Check for HTTP status codes in error object
  if (typeof error === 'object' && error !== null && 'status' in error) {
    const status = (error as { status: number }).status;
    // Retry on 5xx errors and 429 (rate limit)
    return status >= 500 || status === 429;
  }

  return false;
}

/**
 * Retry a function with exponential backoff
 */
export async function retry<T>(fn: () => Promise<T>, options: RetryOptions = {}): Promise<T> {
  const {
    maxAttempts = 3,
    initialDelay = 1000,
    maxDelay = 30000,
    backoffMultiplier = 2,
    shouldRetry = defaultShouldRetry,
    onRetry,
  } = options;

  let lastError: unknown;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      const result = await fn();

      // Log success after retry
      if (attempt > 1) {
        logger.info(`Operation succeeded after ${attempt} attempts`);
      }

      return result;
    } catch (error) {
      lastError = error;

      // Check if we should retry
      const isRetryable = shouldRetry(error);
      const isLastAttempt = attempt === maxAttempts;

      logger.warn(`Operation failed (attempt ${attempt}/${maxAttempts})`, {
        error: error instanceof Error ? error.message : String(error),
        retryable: isRetryable,
        willRetry: isRetryable && !isLastAttempt,
      });

      // Don't retry if not retryable or last attempt
      if (!isRetryable || isLastAttempt) {
        throw new RetryableError(`Operation failed after ${attempt} attempts`, error, attempt);
      }

      // Call retry callback
      onRetry?.(attempt, error);

      // Calculate delay and wait
      const delay = calculateDelay(attempt, initialDelay, maxDelay, backoffMultiplier);
      logger.debug(`Waiting ${delay}ms before retry ${attempt + 1}`);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }

  throw new RetryableError(
    `Operation failed after ${maxAttempts} attempts`,
    lastError,
    maxAttempts
  );
}

/**
 * Create a retryable version of a function
 */
export function withRetry<TArgs extends unknown[], TResult>(
  fn: (...args: TArgs) => Promise<TResult>,
  options: RetryOptions = {}
): (...args: TArgs) => Promise<TResult> {
  return (...args: TArgs) => retry(() => fn(...args), options);
}

type CircuitState = 'closed' | 'open' | 'half-open';

interface CircuitBreakerOptions {
  failureThreshold?: number;
  resetTimeout?: number;
  successThreshold?: number;
}

/**
 * Circuit breaker pattern - prevent cascading failures
 */
export class CircuitBreaker {
  private failureCount = 0;
  private successCount = 0;
  private lastFailureTime: number | null = null;
  private state: CircuitState = 'closed';
  private readonly failureThreshold: number;
  private readonly resetTimeout: number;
  private readonly successThreshold: number;

  constructor(options: CircuitBreakerOptions = {}) {
    this.failureThreshold = options.failureThreshold ?? 5;
    this.resetTimeout = options.resetTimeout ?? 60000;
    this.successThreshold = options.successThreshold ?? 2;
  }

  async execute<T>(fn: () => Promise<T>): Promise<T> {
    // Check if circuit is open
    if (this.state === 'open') {
      const timeSinceLastFailure = Date.now() - (this.lastFailureTime || 0);
      if (timeSinceLastFailure < this.resetTimeout) {
        logger.warn('Circuit breaker is OPEN - rejecting request', {
          timeUntilReset: this.resetTimeout - timeSinceLastFailure,
        });
        throw new Error('Circuit breaker is OPEN - too many failures');
      }
      // Try to close circuit
      this.state = 'half-open';
      logger.info('Circuit breaker entering HALF-OPEN state');
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess() {
    this.successCount++;

    if (this.state === 'half-open' && this.successCount >= this.successThreshold) {
      this.state = 'closed';
      this.failureCount = 0;
      this.successCount = 0;
      logger.info('Circuit breaker CLOSED - system recovered');
    } else if (this.state === 'closed') {
      // Reset failure count on success when closed
      this.failureCount = Math.max(0, this.failureCount - 1);
    }
  }

  private onFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    this.successCount = 0;

    if (this.failureCount >= this.failureThreshold) {
      this.state = 'open';
      logger.error('Circuit breaker OPEN - too many failures', {
        failureCount: this.failureCount,
        threshold: this.failureThreshold,
      });
    }
  }

  getState(): { state: CircuitState; failureCount: number; successCount: number } {
    return {
      state: this.state,
      failureCount: this.failureCount,
      successCount: this.successCount,
    };
  }

  isOpen(): boolean {
    return this.state === 'open';
  }

  isClosed(): boolean {
    return this.state === 'closed';
  }

  reset() {
    this.state = 'closed';
    this.failureCount = 0;
    this.successCount = 0;
    this.lastFailureTime = null;
    logger.info('Circuit breaker manually reset');
  }
}

// Global circuit breaker for Syncthing API
export const syncthingCircuitBreaker = new CircuitBreaker({
  failureThreshold: 5,
  resetTimeout: 30000,
  successThreshold: 2,
});
</file>

<file path="src/lib/utils.ts">
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function formatBytes(bytes: number, decimals = 2): string {
  if (bytes === 0) return '0 Bytes';

  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];

  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

export function formatUptime(seconds: number): string {
  const days = Math.floor(seconds / 86400);
  const hours = Math.floor((seconds % 86400) / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);

  if (days > 0) {
    return `${days}d ${hours}h`;
  }
  if (hours > 0) {
    return `${hours}h ${minutes}m`;
  }
  return `${minutes}m`;
}
</file>

<file path="src/store/index.ts">
'use client';

import { create } from 'zustand';
import { persist } from 'zustand/middleware';

export type AIStatus = 'idle' | 'loading' | 'ready' | 'error' | 'disabled';

interface AppState {
    // UI State
    sidebarOpen: boolean;
    activeTab: 'dashboard' | 'folders' | 'devices' | 'settings' | 'logs';
    theme: 'light' | 'dark' | 'system';

    // Settings
    pollingInterval: number; // in milliseconds
    nativeNotificationsEnabled: boolean;
    aiEnabled: boolean; // Enable AI-powered semantic search

    // Actions
    setSidebarOpen: (open: boolean) => void;
    toggleSidebar: () => void;
    setActiveTab: (tab: AppState['activeTab']) => void;
    setTheme: (theme: AppState['theme']) => void;
    setPollingInterval: (interval: number) => void;
    setNativeNotificationsEnabled: (enabled: boolean) => void;
    setAiEnabled: (enabled: boolean) => void;
}

export const useAppStore = create<AppState>()(
    persist(
        (set) => ({
            // Initial State
            sidebarOpen: true,
            activeTab: 'dashboard',
            theme: 'dark',
            pollingInterval: 5000,
            nativeNotificationsEnabled: true,
            aiEnabled: false, // AI disabled by default

            // Actions
            setSidebarOpen: (open) => set({ sidebarOpen: open }),
            toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
            setActiveTab: (tab) => set({ activeTab: tab }),
            setTheme: (theme) => set({ theme }),
            setPollingInterval: (interval) => set({ pollingInterval: interval }),
            setNativeNotificationsEnabled: (enabled) => set({ nativeNotificationsEnabled: enabled }),
            setAiEnabled: (enabled) => set({ aiEnabled: enabled }),
        }),
        {
            name: 'eigen-app-store',
        }
    )
);

interface AIState {
    // AI Model state (shared across components)
    aiStatus: AIStatus;
    aiStatusMessage: string;
    aiProgress: { current: number; total: number } | null;

    // Actions
    setAIStatus: (status: AIStatus) => void;
    setAIStatusMessage: (message: string) => void;
    setAIProgress: (progress: { current: number; total: number } | null) => void;
}

export const useAIStore = create<AIState>()((set) => ({
    // Initial State
    aiStatus: 'idle',
    aiStatusMessage: '',
    aiProgress: null,

    // Actions
    setAIStatus: (status) => set({ aiStatus: status }),
    setAIStatusMessage: (message) => set({ aiStatusMessage: message }),
    setAIProgress: (progress) => set({ aiProgress: progress }),
}));

interface SyncState {
    // Syncthing state
    isConnected: boolean;
    isSyncthingRunning: boolean;
    lastError: string | null;

    // Actions
    setConnected: (connected: boolean) => void;
    setSyncthingRunning: (running: boolean) => void;
    setLastError: (error: string | null) => void;
}

export const useSyncStore = create<SyncState>()((set) => ({
    // Initial State
    isConnected: false,
    isSyncthingRunning: false,
    lastError: null,

    // Actions
    setConnected: (connected) => set({ isConnected: connected }),
    setSyncthingRunning: (running) => set({ isSyncthingRunning: running }),
    setLastError: (error) => set({ lastError: error }),
}));
</file>

<file path="src/workers/ai.worker.ts">
/**
 * AI Worker - Runs transformers.js in a Web Worker to avoid blocking the UI
 *
 * This worker handles:
 * - Loading the embedding model
 * - Generating embeddings for file names/paths
 * - Computing similarity scores for semantic search
 */

import { pipeline, env, type FeatureExtractionPipeline } from '@xenova/transformers';

// Configure transformers.js for browser
env.allowLocalModels = false;
env.useBrowserCache = true;

// Message types
interface WorkerMessage {
    id: string;
    type: 'init' | 'embed' | 'search' | 'status';
    payload?: unknown;
}

interface InitPayload {
    modelName?: string;
}

interface EmbedPayload {
    texts: string[];
}

interface SearchPayload {
    query: string;
    embeddings: { path: string; embedding: number[] }[];
    topK?: number;
}

// Worker state
let embedder: FeatureExtractionPipeline | null = null;
let isLoading = false;
let modelName = 'Xenova/all-MiniLM-L6-v2'; // Small, fast model

/**
 * Initialize the embedding pipeline
 */
async function initModel(name?: string): Promise<boolean> {
    if (isLoading) {
        // Already loading, return false to indicate no new load started
        return false;
    }
    if (embedder) {
        // Already loaded, return true
        return true;
    }

    isLoading = true;
    modelName = name || modelName;

    try {
        postMessage({
            type: 'status',
            payload: { status: 'loading', message: `Downloading model: ${modelName}...` },
        });

        embedder = (await pipeline('feature-extraction', modelName, {
            quantized: true, // Use quantized model for smaller size
            progress_callback: (progress: { status: string; file?: string; progress?: number; loaded?: number; total?: number }) => {
                // Report download progress
                if (progress.status === 'download' || progress.status === 'progress') {
                    const pct = progress.progress ? Math.round(progress.progress) : 0;
                    const file = progress.file ? progress.file.split('/').pop() : '';
                    postMessage({
                        type: 'status',
                        payload: {
                            status: 'loading',
                            message: `Downloading ${file}... ${pct}%`
                        },
                    });
                } else if (progress.status === 'done') {
                    postMessage({
                        type: 'status',
                        payload: { status: 'loading', message: 'Initializing model...' },
                    });
                }
            },
        })) as FeatureExtractionPipeline;

        postMessage({
            type: 'status',
            payload: { status: 'ready', message: 'Model loaded successfully' },
        });
    } catch (error) {
        console.error('Model loading error:', error);
        postMessage({
            type: 'status',
            payload: {
                status: 'error',
                message: `Failed to load model: ${error instanceof Error ? error.message : 'Unknown error'}`,
            },
        });
        return false;
    } finally {
        isLoading = false;
    }
    return true;
}

/**
 * Generate embeddings for texts
 */
async function generateEmbeddings(texts: string[]): Promise<number[][]> {
    if (!embedder) {
        throw new Error('Model not initialized');
    }

    const results: number[][] = [];

    for (const text of texts) {
        const output = await embedder(text, {
            pooling: 'mean',
            normalize: true,
        });
        // Convert tensor to array
        results.push(Array.from(output.data as Float32Array));
    }

    return results;
}

/**
 * Compute cosine similarity between two vectors
 */
function cosineSimilarity(a: number[], b: number[]): number {
    if (a.length !== b.length) return 0;

    let dotProduct = 0;
    let normA = 0;
    let normB = 0;

    for (let i = 0; i < a.length; i++) {
        dotProduct += a[i] * b[i];
        normA += a[i] * a[i];
        normB += b[i] * b[i];
    }

    normA = Math.sqrt(normA);
    normB = Math.sqrt(normB);

    if (normA === 0 || normB === 0) return 0;

    return dotProduct / (normA * normB);
}

/**
 * Semantic search - find most similar files to query
 */
async function semanticSearch(
    query: string,
    embeddings: { path: string; embedding: number[] }[],
    topK = 10
): Promise<{ path: string; score: number }[]> {
    if (!embedder) {
        throw new Error('Model not initialized');
    }

    // Generate query embedding
    const queryEmbedding = (await generateEmbeddings([query]))[0];

    // Compute similarities
    const results = embeddings.map((item) => ({
        path: item.path,
        score: cosineSimilarity(queryEmbedding, item.embedding),
    }));

    // Sort by similarity and return top K
    return results.sort((a, b) => b.score - a.score).slice(0, topK);
}

// Handle messages from main thread
self.onmessage = async (event: MessageEvent<WorkerMessage>) => {
    const { id, type, payload } = event.data;

    console.log(`[AI Worker] Received message: ${type}`, id ? `(id: ${id})` : '');

    try {
        switch (type) {
            case 'init': {
                const initPayload = payload as InitPayload | undefined;
                // If already loading, wait for it to complete
                if (isLoading) {
                    console.log('[AI Worker] Model already loading, waiting...');
                    // Poll until loading is done
                    while (isLoading) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                const success = await initModel(initPayload?.modelName);
                console.log(`[AI Worker] Init complete, success: ${success}, embedder: ${!!embedder}`);
                postMessage({ id, type: 'init', payload: { success: !!embedder } });
                break;
            }

            case 'embed': {
                const embedPayload = payload as EmbedPayload;
                const embeddings = await generateEmbeddings(embedPayload.texts);
                postMessage({ id, type: 'embed', payload: { embeddings } });
                break;
            }

            case 'search': {
                const searchPayload = payload as SearchPayload;
                const results = await semanticSearch(
                    searchPayload.query,
                    searchPayload.embeddings,
                    searchPayload.topK
                );
                postMessage({ id, type: 'search', payload: { results } });
                break;
            }

            case 'status': {
                postMessage({
                    id,
                    type: 'status',
                    payload: {
                        initialized: !!embedder,
                        loading: isLoading,
                        model: modelName,
                    },
                });
                break;
            }

            default:
                postMessage({
                    id,
                    type: 'error',
                    payload: { message: `Unknown message type: ${type}` },
                });
        }
    } catch (error) {
        console.error('[AI Worker] Error handling message:', error);
        postMessage({
            id,
            type: 'error',
            payload: {
                message: error instanceof Error ? error.message : 'Unknown error',
            },
        });
    }
};

// Signal that worker is ready
console.log('[AI Worker] Worker script loaded, signaling ready');
postMessage({ type: 'status', payload: { status: 'initialized' } });
</file>

<file path="src-tauri/src/lib.rs">
use serde::{Deserialize, Serialize};
use std::fs;
use std::sync::Mutex;
use tauri::Manager;
use tauri_plugin_shell::process::CommandChild;

pub mod commands;

#[derive(Debug, Clone)]
pub struct SyncthingConfig {
    pub api_key: String,
    pub port: u16,
    pub host: String,
}

impl SyncthingConfig {
    /// Try to read API key from Syncthing's config file
    fn read_api_key() -> Option<String> {
        // Try common config locations
        let home = std::env::var("HOME").ok()?;
        let paths = [
            format!("{}/.local/state/syncthing/config.xml", home),
            format!("{}/.config/syncthing/config.xml", home),
        ];
        
        for path in &paths {
            if let Ok(content) = fs::read_to_string(path) {
                // Simple XML parsing for apikey
                if let Some(start) = content.find("<apikey>") {
                    if let Some(end) = content[start..].find("</apikey>") {
                        let key = &content[start + 8..start + end];
                        if !key.is_empty() {
                            return Some(key.to_string());
                        }
                    }
                }
            }
        }
        None
    }
}

impl Default for SyncthingConfig {
    fn default() -> Self {
        Self {
            api_key: Self::read_api_key().unwrap_or_else(|| "no-api-key".to_string()),
            port: 8384,
            host: "127.0.0.1".to_string(),
        }
    }
}

pub struct SyncthingState {
    pub config: SyncthingConfig,
    pub sidecar_child: Mutex<Option<CommandChild>>,
}

impl Default for SyncthingState {
    fn default() -> Self {
        Self {
            config: SyncthingConfig::default(),
            sidecar_child: Mutex::new(None),
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub enum SyncthingError {
    NotRunning,
    HttpError(String),
    ParseError(String),
    ProcessError(String),
}

impl std::fmt::Display for SyncthingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SyncthingError::NotRunning => write!(f, "Syncthing is not running"),
            SyncthingError::HttpError(e) => write!(f, "HTTP error: {}", e),
            SyncthingError::ParseError(e) => write!(f, "Parse error: {}", e),
            SyncthingError::ProcessError(e) => write!(f, "Process error: {}", e),
        }
    }
}

impl std::error::Error for SyncthingError {}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_opener::init())
        .plugin(tauri_plugin_notification::init())
        .plugin(tauri_plugin_dialog::init())
        .plugin(tauri_plugin_shell::init())
        .manage(SyncthingState::default())
        .setup(|app| {
            // Set up tray menu
            use tauri::menu::{MenuBuilder, MenuItemBuilder, PredefinedMenuItem};
            use tauri::tray::TrayIconBuilder;

            let status = MenuItemBuilder::with_id("status", "Status: Checking...")
                .enabled(false)
                .build(app)?;
            let separator1 = PredefinedMenuItem::separator(app)?;
            let show = MenuItemBuilder::with_id("show", "Show Window").build(app)?;
            let hide = MenuItemBuilder::with_id("hide", "Hide to Tray").build(app)?;
            let separator2 = PredefinedMenuItem::separator(app)?;
            let open_syncthing = MenuItemBuilder::with_id("open_syncthing", "Open Syncthing Web UI").build(app)?;
            let separator3 = PredefinedMenuItem::separator(app)?;
            let quit = MenuItemBuilder::with_id("quit", "Quit Eigen").build(app)?;

            let menu = MenuBuilder::new(app)
                .item(&status)
                .item(&separator1)
                .item(&show)
                .item(&hide)
                .item(&separator2)
                .item(&open_syncthing)
                .item(&separator3)
                .item(&quit)
                .build()?;

            // Load tray icon - embedded at compile time
            let tray_icon_bytes = include_bytes!("../icons/tray_icon.png");
            let tray_img = image::load_from_memory(tray_icon_bytes)
                .expect("Failed to load tray icon");
            let rgba = tray_img.to_rgba8();
            let (width, height) = rgba.dimensions();
            let tray_icon = tauri::image::Image::new_owned(rgba.into_raw(), width, height);

            let _tray = TrayIconBuilder::with_id("main")
                .icon(tray_icon)
                .menu(&menu)
                .tooltip("Eigen - Syncthing Manager")
                .on_menu_event(|app, event| {
                    match event.id().as_ref() {
                        "show" => {
                            if let Some(window) = app.get_webview_window("main") {
                                let _ = window.show();
                                let _ = window.unminimize();
                                let _ = window.set_focus();
                            }
                        }
                        "hide" => {
                            if let Some(window) = app.get_webview_window("main") {
                                let _ = window.hide();
                            }
                        }
                        "open_syncthing" => {
                            // Open Syncthing web UI in browser
                            let _ = open::that("http://127.0.0.1:8384");
                        }
                        "quit" => {
                            // Stop syncthing sidecar before quitting
                            let state = app.state::<SyncthingState>();
                            if let Ok(mut child_guard) = state.sidecar_child.lock() {
                                if let Some(child) = child_guard.take() {
                                    let _ = child.kill();
                                }
                            }
                            app.exit(0);
                        }
                        _ => {}
                    }
                })
                .on_tray_icon_event(|tray, event| {
                    use tauri::tray::TrayIconEvent;
                    if let TrayIconEvent::Click { button: tauri::tray::MouseButton::Left, .. } = event {
                        let app = tray.app_handle();
                        if let Some(window) = app.get_webview_window("main") {
                            // Toggle window visibility
                            if window.is_visible().unwrap_or(false) {
                                let _ = window.hide();
                            } else {
                                let _ = window.show();
                                let _ = window.unminimize();
                                let _ = window.set_focus();
                            }
                        }
                    }
                })
                .build(app)?;

            // Handle window close to minimize to tray instead
            if let Some(window) = app.get_webview_window("main") {
                let window_clone = window.clone();
                window.on_window_event(move |event| {
                    if let tauri::WindowEvent::CloseRequested { api, .. } = event {
                        // Prevent the window from actually closing
                        api.prevent_close();
                        // Just hide it instead
                        let _ = window_clone.hide();
                    }
                });
            }

            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            commands::check_syncthing_installation,
            commands::start_syncthing_sidecar,
            commands::stop_syncthing_sidecar,
            commands::get_system_status,
            commands::get_connections,
            commands::get_config,
            commands::update_options,
            commands::get_folder_status,
            commands::pause_folder,
            commands::resume_folder,
            commands::rescan_folder,
            commands::get_api_config,
            commands::get_device_id,
            commands::add_device,
            commands::remove_device,
            commands::add_folder,
            commands::remove_folder,
            commands::share_folder,
            // Advanced folder configuration
            commands::add_folder_advanced,
            commands::update_folder_config,
            commands::get_folder_config,
            // Ignore patterns
            commands::get_folder_ignores,
            commands::set_folder_ignores,
            // System logs
            commands::get_system_logs,
            // Event API
            commands::get_events,
            // Advanced device settings
            commands::add_device_advanced,
            commands::update_device_config,
            commands::get_device_config,
            commands::pause_device,
            commands::resume_device,
            // Folder sharing
            commands::unshare_folder,
            // System management
            commands::restart_syncthing,
            // File browser
            commands::open_folder_in_explorer,
            commands::browse_folder,
            commands::browse_folder_recursive,
            // Conflict resolution
            commands::scan_for_conflicts,
            commands::delete_conflict_file,
            commands::resolve_conflict_keep_conflict,
            // File versioning
            commands::browse_versions,
            commands::restore_version,
            // Tray
            commands::update_tray_status,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
</file>

<file path=".gitignore">
# Dependencies
node_modules/

# Logs
*.log
npm-debug.log*
yarn-debug.log*
pnpm-debug.log*

# Build outputs
.next/
out/
dist/
dist-ssr/
build/

# Tauri / Rust
target/
gen/schemas/
*.rs.bk

# Environment
.env
.env.local
*.local

# Editor
.idea/
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Cache
.cache/
.eslintcache

# Testing
coverage/
.nyc_output/
</file>

<file path="next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./out/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
</file>

<file path="next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export',
  distDir: 'out',
  images: {
    unoptimized: true,
  },
  assetPrefix: process.env.NODE_ENV === 'production' ? '' : undefined,
  // Empty turbopack config to allow running without --turbopack flag
  turbopack: {},
  // Enable Web Workers with webpack 5
  webpack: (config) => {
    config.resolve.alias = {
      ...config.resolve.alias,
      sharp$: false,
      'onnxruntime-node$': false,
    };
    return config;
  },
};

export default nextConfig;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "target": "ES2017",
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "next-env.d.ts",
    "src/types/**/*.d.ts",
    "out/types/**/*.ts",
    "out/dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "src-tauri"
  ]
}
</file>

<file path="src/app/globals.css">
@import 'tailwindcss';

@custom-variant dark (&:is(.dark *));

@theme {
  --color-background: hsl(var(--background));
  --color-foreground: hsl(var(--foreground));

  --color-card: hsl(var(--card));
  --color-card-foreground: hsl(var(--card-foreground));

  --color-popover: hsl(var(--popover));
  --color-popover-foreground: hsl(var(--popover-foreground));

  --color-primary: hsl(var(--primary));
  --color-primary-foreground: hsl(var(--primary-foreground));

  --color-secondary: hsl(var(--secondary));
  --color-secondary-foreground: hsl(var(--secondary-foreground));

  --color-muted: hsl(var(--muted));
  --color-muted-foreground: hsl(var(--muted-foreground));

  --color-accent: hsl(var(--accent));
  --color-accent-foreground: hsl(var(--accent-foreground));

  --color-destructive: hsl(var(--destructive));
  --color-destructive-foreground: hsl(var(--destructive-foreground));

  --color-border: hsl(var(--border));
  --color-input: hsl(var(--input));
  --color-ring: hsl(var(--ring));

  --radius-lg: var(--radius);
  --radius-md: calc(var(--radius) - 2px);
  --radius-sm: calc(var(--radius) - 4px);
}

/*
  The default border color has changed to `currentcolor` in Tailwind CSS v4,
  so we've added these compatibility styles to make sure everything still
  looks the same as it did with Tailwind CSS v3.

  If we ever want to remove these styles, we need to add an explicit border
  color utility to any element that depends on these defaults.
*/
@layer base {
  *,
  ::after,
  ::before,
  ::backdrop,
  ::file-selector-button {
    border-color: var(--color-gray-200, currentcolor);
  }
}

/* Glassmorphism utilities */
@utility glass {
  @apply border border-slate-800 bg-slate-900/50 backdrop-blur-xl;
}
@utility glass-card {
  @apply rounded-xl border border-slate-800 bg-slate-900/50 shadow-xl backdrop-blur-xl;
}
@utility animate-glow {
  animation: glow 2s ease-in-out infinite alternate;
}

@layer base {
  :root {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 217.2 91.2% 59.8%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 224.3 76.3% 48%;
    --radius: 0.75rem;
  }
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground;
  }

  /* Custom scrollbar styles */
  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }

  ::-webkit-scrollbar-track {
    @apply bg-slate-900;
  }

  ::-webkit-scrollbar-thumb {
    @apply rounded-full bg-slate-700;
  }

  ::-webkit-scrollbar-thumb:hover {
    @apply bg-slate-600;
  }
}

/* Animation utilities */
@layer utilities {
  @keyframes glow {
    from {
      box-shadow: 0 0 5px rgb(99 102 241 / 0.5);
    }
    to {
      box-shadow: 0 0 20px rgb(99 102 241 / 0.8);
    }
  }
}
</file>

<file path="src/app/page.tsx">
'use client';

import { Sidebar } from '@/components/sidebar';
import { Header } from '@/components/header';
import { MainContent } from '@/components/main-content';

export default function Home() {
  return (
    <div className="flex h-screen w-screen overflow-hidden bg-linear-to-br from-slate-950 via-slate-900 to-slate-950">
      <Sidebar />
      <div className="flex flex-1 flex-col overflow-hidden">
        <Header />
        <MainContent />
      </div>
    </div>
  );
}
</file>

<file path="src/components/ui/badge.tsx">
import * as React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';

const badgeVariants = cva(
  'inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2',
  {
    variants: {
      variant: {
        default:
          'border-transparent bg-primary text-primary-foreground shadow-sm hover:bg-primary/80',
        secondary:
          'border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80',
        destructive:
          'border-transparent bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/80',
        outline: 'text-foreground',
        success: 'border-transparent bg-emerald-500/20 text-emerald-400 shadow-sm',
        warning: 'border-transparent bg-amber-500/20 text-amber-400 shadow-sm',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>, VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return <div className={cn(badgeVariants({ variant }), className)} {...props} />;
}

export { Badge, badgeVariants };
</file>

<file path="src/components/ui/button.tsx">
import * as React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';

const buttonVariants = cva(
  'inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-hidden focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0',
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground shadow-sm hover:bg-primary/90',
        destructive: 'bg-destructive text-destructive-foreground shadow-xs hover:bg-destructive/90',
        outline:
          'border border-input bg-background shadow-xs hover:bg-accent hover:text-accent-foreground',
        secondary: 'bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-9 px-4 py-2',
        sm: 'h-8 rounded-md px-3 text-xs',
        lg: 'h-10 rounded-md px-8',
        icon: 'h-9 w-9',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, ...props }, ref) => {
    return (
      <button className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} />
    );
  }
);
Button.displayName = 'Button';

export { Button, buttonVariants };
</file>

<file path="src/components/ui/card.tsx">
import * as React from 'react';
import { cn } from '@/lib/utils';

const Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('bg-card text-card-foreground rounded-xl border shadow-sm', className)}
      {...props}
    />
  )
);
Card.displayName = 'Card';

const CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('flex flex-col space-y-1.5 p-6', className)} {...props} />
  )
);
CardHeader.displayName = 'CardHeader';

const CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    <h3
      ref={ref}
      className={cn('leading-none font-semibold tracking-tight', className)}
      {...props}
    />
  )
);
CardTitle.displayName = 'CardTitle';

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p ref={ref} className={cn('text-muted-foreground text-sm', className)} {...props} />
));
CardDescription.displayName = 'CardDescription';

const CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
  )
);
CardContent.displayName = 'CardContent';

const CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('flex items-center p-6 pt-0', className)} {...props} />
  )
);
CardFooter.displayName = 'CardFooter';

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };
</file>

<file path="src/components/add-device-dialog.tsx">
'use client';

import { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { useDeviceId, useAddDeviceAdvanced } from '@/hooks/useSyncthing';
import {
  Copy,
  Check,
  Plus,
  X,
  QrCode,
  Loader2,
  ChevronDown,
  ChevronUp,
  Gauge,
  Network,
  Settings2,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { toast } from 'sonner';

interface AddDeviceDialogProps {
  open: boolean;
  onClose: () => void;
}

type CompressionType = 'metadata' | 'always' | 'never';

const compressionOptions: {
  value: CompressionType;
  label: string;
  description: string;
}[] = [
  {
    value: 'metadata',
    label: 'Metadata Only',
    description: 'Compress only metadata (recommended)',
  },
  {
    value: 'always',
    label: 'Always',
    description: 'Compress all data (slower, saves bandwidth)',
  },
  {
    value: 'never',
    label: 'Never',
    description: 'No compression (fastest, uses more bandwidth)',
  },
];

export function AddDeviceDialog({ open, onClose }: AddDeviceDialogProps) {
  const [remoteDeviceId, setRemoteDeviceId] = useState('');
  const [deviceName, setDeviceName] = useState('');
  const [copied, setCopied] = useState(false);
  const [showAdvanced, setShowAdvanced] = useState(false);

  // Advanced options
  const [addresses, setAddresses] = useState('dynamic');
  const [compression, setCompression] = useState<CompressionType>('metadata');
  const [introducer, setIntroducer] = useState(false);
  const [autoAcceptFolders, setAutoAcceptFolders] = useState(false);
  const [maxSendKbps, setMaxSendKbps] = useState<number>(0);
  const [maxRecvKbps, setMaxRecvKbps] = useState<number>(0);

  const { data: localDeviceId, isLoading: deviceIdLoading } = useDeviceId();
  const addDevice = useAddDeviceAdvanced();

  const handleCopyId = async () => {
    if (localDeviceId) {
      await navigator.clipboard.writeText(localDeviceId);
      setCopied(true);
      toast.success('Device ID copied to clipboard');
      setTimeout(() => setCopied(false), 2000);
    }
  };

  const handleAddDevice = async () => {
    if (!remoteDeviceId.trim()) {
      toast.error('Please enter a Device ID');
      return;
    }

    try {
      await addDevice.mutateAsync({
        deviceId: remoteDeviceId.trim().toUpperCase(),
        name: deviceName.trim() || 'Unnamed Device',
        addresses: addresses
          .split(',')
          .map((a) => a.trim())
          .filter(Boolean),
        compression,
        introducer,
        autoAcceptFolders,
        maxSendKbps: maxSendKbps > 0 ? maxSendKbps : undefined,
        maxRecvKbps: maxRecvKbps > 0 ? maxRecvKbps : undefined,
      });
      toast.success('Device added successfully');
      resetForm();
      onClose();
    } catch (error) {
      toast.error('Failed to add device');
    }
  };

  const resetForm = () => {
    setRemoteDeviceId('');
    setDeviceName('');
    setShowAdvanced(false);
    setAddresses('dynamic');
    setCompression('metadata');
    setIntroducer(false);
    setAutoAcceptFolders(false);
    setMaxSendKbps(0);
    setMaxRecvKbps(0);
  };

  if (!open) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-xs">
      <Card className="w-full max-w-lg border-slate-700 bg-slate-900 shadow-2xl">
        <CardHeader className="relative">
          <Button
            variant="ghost"
            size="icon"
            onClick={onClose}
            className="absolute top-4 right-4 text-slate-400 hover:text-white"
          >
            <X className="h-4 w-4" />
          </Button>
          <CardTitle className="text-xl text-white">Connect a Device</CardTitle>
          <CardDescription className="text-slate-400">
            Share your Device ID with another device, or enter their Device ID to connect.
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          {/* Your Device ID Section */}
          <div className="space-y-3">
            <label className="text-sm font-medium text-slate-300">Your Device ID</label>
            <p className="text-xs text-slate-500">
              Share this ID with other devices you want to connect to.
            </p>
            <div className="flex gap-2">
              <div
                className={cn(
                  'flex-1 rounded-lg border border-slate-700 bg-slate-800 p-3',
                  'font-mono text-xs break-all text-slate-300'
                )}
              >
                {deviceIdLoading ? (
                  <span className="text-slate-500">Loading...</span>
                ) : (
                  localDeviceId || 'Unable to get Device ID'
                )}
              </div>
              <Button
                variant="outline"
                size="icon"
                onClick={handleCopyId}
                disabled={!localDeviceId}
                className="shrink-0 border-slate-700 bg-slate-800 hover:bg-slate-700"
              >
                {copied ? (
                  <Check className="h-4 w-4 text-emerald-400" />
                ) : (
                  <Copy className="h-4 w-4" />
                )}
              </Button>
            </div>
          </div>

          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <span className="w-full border-t border-slate-700" />
            </div>
            <div className="relative flex justify-center text-xs uppercase">
              <span className="bg-slate-900 px-2 text-slate-500">Add Remote Device</span>
            </div>
          </div>

          {/* Add Remote Device Section */}
          <div className="space-y-4">
            <div className="space-y-2">
              <label className="text-sm font-medium text-slate-300">Remote Device ID</label>
              <input
                type="text"
                value={remoteDeviceId}
                onChange={(e) => setRemoteDeviceId(e.target.value)}
                placeholder="XXXXXXX-XXXXXXX-XXXXXXX-XXXXXXX-XXXXXXX-XXXXXXX-XXXXXXX-XXXXXXX"
                className={cn(
                  'w-full rounded-lg border border-slate-700 bg-slate-800 px-3 py-2',
                  'font-mono text-sm text-white placeholder:text-slate-600',
                  'focus:border-violet-500 focus:ring-1 focus:ring-violet-500 focus:outline-hidden'
                )}
              />
            </div>
            <div className="space-y-2">
              <label className="text-sm font-medium text-slate-300">
                Device Name <span className="text-slate-500">(optional)</span>
              </label>
              <input
                type="text"
                value={deviceName}
                onChange={(e) => setDeviceName(e.target.value)}
                placeholder="e.g., My Laptop, Phone, etc."
                className={cn(
                  'w-full rounded-lg border border-slate-700 bg-slate-800 px-3 py-2',
                  'text-sm text-white placeholder:text-slate-600',
                  'focus:border-violet-500 focus:ring-1 focus:ring-violet-500 focus:outline-hidden'
                )}
              />
            </div>
          </div>

          {/* Advanced Options Toggle */}
          <button
            type="button"
            onClick={() => setShowAdvanced(!showAdvanced)}
            className="flex items-center gap-2 text-sm text-slate-400 transition-colors hover:text-slate-300"
          >
            <Settings2 className="h-4 w-4" />
            Advanced Settings
            {showAdvanced ? <ChevronUp className="h-4 w-4" /> : <ChevronDown className="h-4 w-4" />}
          </button>

          {/* Advanced Options */}
          {showAdvanced && (
            <div className="space-y-4 rounded-lg border border-slate-700 bg-slate-800/50 p-4">
              {/* Addresses */}
              <div className="space-y-2">
                <label className="flex items-center gap-2 text-sm font-medium text-slate-300">
                  <Network className="h-4 w-4" />
                  Addresses
                </label>
                <input
                  type="text"
                  value={addresses}
                  onChange={(e) => setAddresses(e.target.value)}
                  placeholder="dynamic, tcp://hostname:port"
                  className={cn(
                    'w-full rounded-lg border border-slate-700 bg-slate-800 px-3 py-2',
                    'text-sm text-white placeholder:text-slate-600',
                    'focus:border-violet-500 focus:ring-1 focus:ring-violet-500 focus:outline-hidden'
                  )}
                />
                <p className="text-xs text-slate-500">
                  Use "dynamic" for auto-discovery, or specify addresses like tcp://hostname:22000
                </p>
              </div>

              {/* Compression */}
              <div className="space-y-2">
                <label className="text-sm font-medium text-slate-300">Compression</label>
                <div className="grid grid-cols-3 gap-2">
                  {compressionOptions.map((option) => (
                    <button
                      key={option.value}
                      type="button"
                      onClick={() => setCompression(option.value)}
                      className={cn(
                        'rounded-lg border p-2 text-left transition-all',
                        compression === option.value
                          ? 'border-violet-500 bg-violet-500/20 text-violet-300'
                          : 'border-slate-700 bg-slate-800 text-slate-400 hover:border-slate-600'
                      )}
                    >
                      <div className="text-sm font-medium">{option.label}</div>
                    </button>
                  ))}
                </div>
              </div>

              {/* Rate Limits */}
              <div className="grid grid-cols-2 gap-4">
                <div className="space-y-2">
                  <label className="flex items-center gap-2 text-sm font-medium text-slate-300">
                    <Gauge className="h-4 w-4" />
                    Upload Limit (KB/s)
                  </label>
                  <input
                    type="number"
                    value={maxSendKbps || ''}
                    onChange={(e) => setMaxSendKbps(parseInt(e.target.value) || 0)}
                    placeholder="0 = unlimited"
                    min={0}
                    className={cn(
                      'w-full rounded-lg border border-slate-700 bg-slate-800 px-3 py-2',
                      'text-sm text-white placeholder:text-slate-600',
                      'focus:border-violet-500 focus:ring-1 focus:ring-violet-500 focus:outline-hidden'
                    )}
                  />
                </div>
                <div className="space-y-2">
                  <label className="flex items-center gap-2 text-sm font-medium text-slate-300">
                    <Gauge className="h-4 w-4" />
                    Download Limit (KB/s)
                  </label>
                  <input
                    type="number"
                    value={maxRecvKbps || ''}
                    onChange={(e) => setMaxRecvKbps(parseInt(e.target.value) || 0)}
                    placeholder="0 = unlimited"
                    min={0}
                    className={cn(
                      'w-full rounded-lg border border-slate-700 bg-slate-800 px-3 py-2',
                      'text-sm text-white placeholder:text-slate-600',
                      'focus:border-violet-500 focus:ring-1 focus:ring-violet-500 focus:outline-hidden'
                    )}
                  />
                </div>
              </div>

              {/* Introducer & Auto-accept */}
              <div className="space-y-3">
                <label className="flex cursor-pointer items-center gap-3">
                  <input
                    type="checkbox"
                    checked={introducer}
                    onChange={(e) => setIntroducer(e.target.checked)}
                    className="rounded border-slate-600 bg-slate-800 text-violet-500 focus:ring-violet-500"
                  />
                  <div>
                    <div className="text-sm font-medium text-slate-300">Introducer</div>
                    <div className="text-xs text-slate-500">
                      This device can introduce us to other devices
                    </div>
                  </div>
                </label>
                <label className="flex cursor-pointer items-center gap-3">
                  <input
                    type="checkbox"
                    checked={autoAcceptFolders}
                    onChange={(e) => setAutoAcceptFolders(e.target.checked)}
                    className="rounded border-slate-600 bg-slate-800 text-violet-500 focus:ring-violet-500"
                  />
                  <div>
                    <div className="text-sm font-medium text-slate-300">Auto-accept Folders</div>
                    <div className="text-xs text-slate-500">
                      Automatically accept folder share invitations from this device
                    </div>
                  </div>
                </label>
              </div>
            </div>
          )}

          <div className="flex justify-end gap-3 pt-2">
            <Button
              variant="outline"
              onClick={onClose}
              className="border-slate-700 bg-transparent hover:bg-slate-800"
            >
              Cancel
            </Button>
            <Button
              onClick={handleAddDevice}
              disabled={!remoteDeviceId.trim() || addDevice.isPending}
              className="bg-violet-600 hover:bg-violet-700"
            >
              {addDevice.isPending ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Adding...
                </>
              ) : (
                <>
                  <Plus className="mr-2 h-4 w-4" />
                  Add Device
                </>
              )}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

export function MyDeviceId() {
  const { data: localDeviceId, isLoading } = useDeviceId();
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    if (localDeviceId) {
      await navigator.clipboard.writeText(localDeviceId);
      setCopied(true);
      toast.success('Device ID copied to clipboard');
      setTimeout(() => setCopied(false), 2000);
    }
  };

  return (
    <Card className="border-slate-800 bg-slate-900/50 backdrop-blur-md">
      <CardHeader className="pb-3">
        <div className="flex items-center justify-between">
          <div>
            <CardTitle className="text-lg text-white">This Device</CardTitle>
            <CardDescription className="text-slate-500">
              Share this ID to connect other devices
            </CardDescription>
          </div>
          <div className="flex items-center gap-2">
            <QrCode className="h-5 w-5 text-slate-500" />
          </div>
        </div>
      </CardHeader>
      <CardContent>
        <div className="flex gap-2">
          <div className="flex-1 rounded-lg border border-slate-700 bg-slate-800 p-3 font-mono text-xs break-all text-slate-300">
            {isLoading ? (
              <span className="text-slate-500">Loading...</span>
            ) : (
              localDeviceId || 'Unable to get Device ID'
            )}
          </div>
          <Button
            variant="outline"
            size="icon"
            onClick={handleCopy}
            disabled={!localDeviceId}
            className="shrink-0 border-slate-700 bg-slate-800 hover:bg-slate-700"
          >
            {copied ? <Check className="h-4 w-4 text-emerald-400" /> : <Copy className="h-4 w-4" />}
          </Button>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/add-folder-dialog.tsx">
'use client';

import { useState } from 'react';
import { useAddFolderAdvanced } from '@/hooks/useSyncthing';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
  FolderPlus,
  X,
  ChevronDown,
  ChevronUp,
  History,
  Clock,
  Trash2,
  Terminal,
  FolderOpen,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { toast } from 'sonner';
import { open as openDialog } from '@tauri-apps/plugin-dialog';

interface AddFolderDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

type VersioningType = '' | 'simple' | 'staggered' | 'trashcan' | 'external';

const versioningOptions = [
  {
    value: '' as VersioningType,
    label: 'No Versioning',
    description: 'Deleted or modified files are not preserved',
    icon: X,
  },
  {
    value: 'simple' as VersioningType,
    label: 'Simple',
    description: 'Keep a specified number of old versions',
    icon: History,
  },
  {
    value: 'staggered' as VersioningType,
    label: 'Staggered',
    description: 'Smart versioning: more frequent recent, sparse older',
    icon: Clock,
  },
  {
    value: 'trashcan' as VersioningType,
    label: 'Trash Can',
    description: 'Move deleted files to .stversions folder',
    icon: Trash2,
  },
  {
    value: 'external' as VersioningType,
    label: 'External',
    description: 'Use an external command for versioning',
    icon: Terminal,
  },
];

export function AddFolderDialog({ open, onOpenChange }: AddFolderDialogProps) {
  const [folderId, setFolderId] = useState('');
  const [folderLabel, setFolderLabel] = useState('');
  const [folderPath, setFolderPath] = useState('');
  const [showAdvanced, setShowAdvanced] = useState(false);
  const [versioning, setVersioning] = useState<{
    type: VersioningType;
    params: Record<string, string>;
  }>({ type: '', params: {} });
  const [rescanInterval, setRescanInterval] = useState(3600);
  const [fsWatcherEnabled, setFsWatcherEnabled] = useState(true);
  const [fsWatcherDelay, setFsWatcherDelay] = useState(10);
  const [ignorePerms, setIgnorePerms] = useState(false);

  const addFolder = useAddFolderAdvanced();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!folderId.trim()) {
      toast.error('Folder ID is required');
      return;
    }
    if (!folderPath.trim()) {
      toast.error('Folder path is required');
      return;
    }

    try {
      await addFolder.mutateAsync({
        folderId: folderId.trim(),
        folderLabel: folderLabel.trim() || folderId.trim(),
        folderPath: folderPath.trim(),
        versioningType: versioning.type || undefined,
        versioningParams: Object.keys(versioning.params).length > 0 ? versioning.params : undefined,
        rescanIntervalS: rescanInterval,
        fsWatcherEnabled,
        fsWatcherDelayS: fsWatcherDelay,
        ignorePerms,
      });
      toast.success('Folder added successfully');
      handleClose();
    } catch (err) {
      toast.error('Failed to add folder');
    }
  };

  const handleClose = () => {
    setFolderId('');
    setFolderLabel('');
    setFolderPath('');
    setShowAdvanced(false);
    setVersioning({ type: '', params: {} });
    setRescanInterval(3600);
    setFsWatcherEnabled(true);
    setFsWatcherDelay(10);
    setIgnorePerms(false);
    onOpenChange(false);
  };

  const updateVersioningType = (type: VersioningType) => {
    const defaultParams: Record<VersioningType, Record<string, string>> = {
      '': {},
      simple: { keep: '5' },
      staggered: { maxAge: '31536000' },
      trashcan: { cleanoutDays: '0' },
      external: { command: '' },
    };
    setVersioning({ type, params: defaultParams[type] });
  };

  if (!open) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center py-8">
      <div className="absolute inset-0 bg-black/60 backdrop-blur-xs" onClick={handleClose} />
      <Card className="relative z-10 mx-4 max-h-[90vh] w-full max-w-lg overflow-y-auto border-slate-700 bg-slate-900/95 backdrop-blur-sm">
        <CardHeader className="pb-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <div className="flex h-10 w-10 items-center justify-center rounded-lg bg-indigo-500/20">
                <FolderPlus className="h-5 w-5 text-indigo-400" />
              </div>
              <div>
                <CardTitle className="text-white">Add Folder</CardTitle>
                <p className="text-sm text-slate-400">Share a folder with your devices</p>
              </div>
            </div>
            <Button
              variant="ghost"
              size="sm"
              onClick={handleClose}
              className="text-slate-400 hover:text-white"
            >
              <X className="h-4 w-4" />
            </Button>
          </div>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="space-y-2">
              <label className="text-sm font-medium text-slate-300">Folder ID *</label>
              <input
                type="text"
                value={folderId}
                onChange={(e) => setFolderId(e.target.value)}
                placeholder="my-folder"
                className="w-full rounded-lg border border-slate-700 bg-slate-800 px-3 py-2 text-white placeholder:text-slate-500 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 focus:outline-hidden"
              />
              <p className="text-xs text-slate-500">Unique identifier for this folder</p>
            </div>

            <div className="space-y-2">
              <label className="text-sm font-medium text-slate-300">Label</label>
              <input
                type="text"
                value={folderLabel}
                onChange={(e) => setFolderLabel(e.target.value)}
                placeholder="My Folder"
                className="w-full rounded-lg border border-slate-700 bg-slate-800 px-3 py-2 text-white placeholder:text-slate-500 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 focus:outline-hidden"
              />
              <p className="text-xs text-slate-500">Human-readable name (optional)</p>
            </div>

            <div className="space-y-2">
              <label className="text-sm font-medium text-slate-300">Path *</label>
              <div className="flex gap-2">
                <input
                  type="text"
                  value={folderPath}
                  onChange={(e) => setFolderPath(e.target.value)}
                  placeholder="/home/user/sync-folder"
                  className="flex-1 rounded-lg border border-slate-700 bg-slate-800 px-3 py-2 font-mono text-sm text-white placeholder:text-slate-500 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 focus:outline-hidden"
                />
                <Button
                  type="button"
                  variant="outline"
                  onClick={async () => {
                    try {
                      const selected = await openDialog({
                        directory: true,
                        multiple: false,
                        title: 'Select Folder to Sync',
                      });
                      if (selected) {
                        setFolderPath(selected as string);
                      }
                    } catch (err) {
                      console.error('Failed to open folder picker:', err);
                    }
                  }}
                  className="border-slate-700 bg-slate-800 text-slate-300 hover:bg-slate-700 hover:text-white"
                >
                  <FolderOpen className="h-4 w-4" />
                </Button>
              </div>
              <p className="text-xs text-slate-500">Absolute path to the folder</p>
            </div>

            <Button
              type="button"
              variant="ghost"
              onClick={() => setShowAdvanced(!showAdvanced)}
              className="w-full justify-between text-slate-300 hover:text-white"
            >
              <span>Advanced Options</span>
              {showAdvanced ? (
                <ChevronUp className="h-4 w-4" />
              ) : (
                <ChevronDown className="h-4 w-4" />
              )}
            </Button>

            {showAdvanced && (
              <div className="space-y-4 rounded-lg border border-slate-700 bg-slate-800/50 p-4">
                <div className="space-y-2">
                  <label className="text-sm font-medium text-slate-300">File Versioning</label>
                  <div className="grid gap-2">
                    {versioningOptions.map((option) => {
                      const Icon = option.icon;
                      return (
                        <button
                          key={option.value}
                          type="button"
                          onClick={() => updateVersioningType(option.value)}
                          className={cn(
                            'flex items-start gap-3 rounded-lg border p-3 text-left transition-colors',
                            versioning.type === option.value
                              ? 'border-indigo-500 bg-indigo-500/10'
                              : 'border-slate-700 hover:border-slate-600'
                          )}
                        >
                          <Icon
                            className={cn(
                              'mt-0.5 h-4 w-4',
                              versioning.type === option.value
                                ? 'text-indigo-400'
                                : 'text-slate-500'
                            )}
                          />
                          <div>
                            <p
                              className={cn(
                                'text-sm font-medium',
                                versioning.type === option.value ? 'text-white' : 'text-slate-300'
                              )}
                            >
                              {option.label}
                            </p>
                            <p className="text-xs text-slate-500">{option.description}</p>
                          </div>
                        </button>
                      );
                    })}
                  </div>
                </div>

                {versioning.type === 'simple' && (
                  <div className="space-y-2 pl-6">
                    <label className="text-sm text-slate-400">Versions to keep</label>
                    <input
                      type="number"
                      min="1"
                      value={versioning.params.keep || '5'}
                      onChange={(e) =>
                        setVersioning({
                          ...versioning,
                          params: {
                            keep: e.target.value,
                          },
                        })
                      }
                      className="w-full rounded border border-slate-700 bg-slate-800 px-3 py-2 text-white"
                    />
                  </div>
                )}

                {versioning.type === 'staggered' && (
                  <div className="space-y-2 pl-6">
                    <label className="text-sm text-slate-400">Max age (seconds)</label>
                    <select
                      value={versioning.params.maxAge || '31536000'}
                      onChange={(e) =>
                        setVersioning({
                          ...versioning,
                          params: {
                            maxAge: e.target.value,
                          },
                        })
                      }
                      className="w-full rounded border border-slate-700 bg-slate-800 px-3 py-2 text-white"
                    >
                      <option value="86400">1 day</option>
                      <option value="604800">1 week</option>
                      <option value="2592000">30 days</option>
                      <option value="31536000">1 year</option>
                      <option value="0">Forever</option>
                    </select>
                  </div>
                )}

                {versioning.type === 'trashcan' && (
                  <div className="space-y-2 pl-6">
                    <label className="text-sm text-slate-400">
                      Clean out after (days, 0 = never)
                    </label>
                    <input
                      type="number"
                      min="0"
                      value={versioning.params.cleanoutDays || '0'}
                      onChange={(e) =>
                        setVersioning({
                          ...versioning,
                          params: {
                            cleanoutDays: e.target.value,
                          },
                        })
                      }
                      className="w-full rounded border border-slate-700 bg-slate-800 px-3 py-2 text-white"
                    />
                  </div>
                )}

                {versioning.type === 'external' && (
                  <div className="space-y-2 pl-6">
                    <label className="text-sm text-slate-400">Command</label>
                    <input
                      type="text"
                      value={versioning.params.command || ''}
                      onChange={(e) =>
                        setVersioning({
                          ...versioning,
                          params: {
                            command: e.target.value,
                          },
                        })
                      }
                      placeholder="/path/to/command %FOLDER_PATH% %FILE_PATH%"
                      className="w-full rounded border border-slate-700 bg-slate-800 px-3 py-2 font-mono text-sm text-white"
                    />
                  </div>
                )}

                <div className="space-y-2">
                  <label className="text-sm font-medium text-slate-300">Rescan Interval</label>
                  <select
                    value={rescanInterval}
                    onChange={(e) => setRescanInterval(parseInt(e.target.value))}
                    className="w-full rounded border border-slate-700 bg-slate-800 px-3 py-2 text-white"
                  >
                    <option value={60}>1 minute</option>
                    <option value={300}>5 minutes</option>
                    <option value={900}>15 minutes</option>
                    <option value={3600}>1 hour</option>
                    <option value={86400}>24 hours</option>
                  </select>
                </div>

                <div className="space-y-3">
                  <label className="flex items-center gap-3">
                    <input
                      type="checkbox"
                      checked={fsWatcherEnabled}
                      onChange={(e) => setFsWatcherEnabled(e.target.checked)}
                      className="h-4 w-4 rounded border-slate-600 bg-slate-800 text-indigo-500"
                    />
                    <div>
                      <span className="text-sm text-slate-300">Enable File Watcher</span>
                      <p className="text-xs text-slate-500">Detect changes immediately</p>
                    </div>
                  </label>

                  <label className="flex items-center gap-3">
                    <input
                      type="checkbox"
                      checked={ignorePerms}
                      onChange={(e) => setIgnorePerms(e.target.checked)}
                      className="h-4 w-4 rounded border-slate-600 bg-slate-800 text-indigo-500"
                    />
                    <div>
                      <span className="text-sm text-slate-300">Ignore Permissions</span>
                      <p className="text-xs text-slate-500">Useful for FAT/NTFS filesystems</p>
                    </div>
                  </label>
                </div>
              </div>
            )}

            <div className="flex gap-3 pt-4">
              <Button
                type="button"
                variant="outline"
                onClick={handleClose}
                className="flex-1 border-slate-700 text-slate-300 hover:bg-slate-800"
              >
                Cancel
              </Button>
              <Button
                type="submit"
                disabled={addFolder.isPending}
                className="flex-1 bg-indigo-600 hover:bg-indigo-700"
              >
                {addFolder.isPending ? 'Adding...' : 'Add Folder'}
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/ai-search-bar.tsx">
'use client';

/**
 * AISearchBar - Semantic file search component powered by transformers.js
 */

import { useState, useCallback, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Search, Sparkles, Loader2, Brain, X, FileText, Folder, AlertCircle } from 'lucide-react';
import { useAISearch, type AIStatus } from '@/hooks/useAISearch';
import { useAppStore } from '@/store';
import { cn } from '@/lib/utils';

interface SearchResult {
  path: string;
  score: number;
}

interface AISearchBarProps {
  onResultSelect?: (path: string) => void;
  className?: string;
}

export function AISearchBar({ onResultSelect, className }: AISearchBarProps) {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState<SearchResult[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [showResults, setShowResults] = useState(false);
  const [selectedIndex, setSelectedIndex] = useState(0);
  const inputRef = useRef<HTMLInputElement>(null);
  const resultsRef = useRef<HTMLDivElement>(null);

  const aiEnabled = useAppStore((state) => state.aiEnabled);
  const { status, statusMessage, isReady, initialize, search, progress } = useAISearch({
    enabled: aiEnabled,
  });

  // Initialize AI model when component mounts (only if enabled)
  useEffect(() => {
    if (aiEnabled && status === 'idle') {
      initialize();
    }
  }, [aiEnabled, status, initialize]);

  // Search with debounce
  useEffect(() => {
    if (!aiEnabled || !query.trim() || !isReady) {
      setResults([]);
      return;
    }

    const timer = setTimeout(async () => {
      setIsSearching(true);
      try {
        const searchResults = await search(query);
        setResults(searchResults);
        setSelectedIndex(0);
      } catch (error) {
        console.error('Search error:', error);
      } finally {
        setIsSearching(false);
      }
    }, 300);

    return () => clearTimeout(timer);
  }, [query, isReady, search]);

  // Keyboard navigation
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (!showResults || results.length === 0) return;

      switch (e.key) {
        case 'ArrowDown':
          e.preventDefault();
          setSelectedIndex((i) => Math.min(i + 1, results.length - 1));
          break;
        case 'ArrowUp':
          e.preventDefault();
          setSelectedIndex((i) => Math.max(i - 1, 0));
          break;
        case 'Enter':
          e.preventDefault();
          if (results[selectedIndex]) {
            onResultSelect?.(results[selectedIndex].path);
            setShowResults(false);
            setQuery('');
          }
          break;
        case 'Escape':
          e.preventDefault();
          setShowResults(false);
          break;
      }
    },
    [showResults, results, selectedIndex, onResultSelect]
  );

  // Close results when clicking outside
  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (
        resultsRef.current &&
        !resultsRef.current.contains(e.target as Node) &&
        inputRef.current &&
        !inputRef.current.contains(e.target as Node)
      ) {
        setShowResults(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const getStatusIcon = () => {
    switch (status) {
      case 'loading':
        return <Loader2 className="text-primary h-4 w-4 animate-spin" />;
      case 'ready':
        return <Sparkles className="text-primary h-4 w-4" />;
      case 'error':
        return <AlertCircle className="text-destructive h-4 w-4" />;
      case 'disabled':
        return <Brain className="text-muted-foreground/50 h-4 w-4" />;
      default:
        return <Brain className="text-muted-foreground h-4 w-4" />;
    }
  };

  const getFileName = (path: string) => {
    const parts = path.split('/');
    return parts[parts.length - 1];
  };

  const getParentPath = (path: string) => {
    const parts = path.split('/');
    return parts.slice(0, -1).join('/');
  };

  return (
    <div className={cn('relative', className)}>
      {/* Search Input */}
      <div className="relative">
        <Search className="text-muted-foreground absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2" />
        <input
          ref={inputRef}
          type="text"
          value={query}
          onChange={(e) => {
            setQuery(e.target.value);
            setShowResults(true);
          }}
          onFocus={() => setShowResults(true)}
          onKeyDown={handleKeyDown}
          placeholder={
            !aiEnabled
              ? 'AI search disabled'
              : isReady
                ? 'Search files semantically...'
                : 'Loading AI model...'
          }
          disabled={status === 'loading' || status === 'disabled'}
          className={cn(
            'w-full rounded-lg py-2 pr-20 pl-10',
            'bg-muted/50 border-border border',
            'placeholder:text-muted-foreground text-sm',
            'focus:ring-primary/20 focus:border-primary focus:ring-2 focus:outline-hidden',
            'disabled:cursor-not-allowed disabled:opacity-50',
            'transition-all duration-200'
          )}
        />

        {/* Status indicator */}
        <div className="absolute top-1/2 right-3 flex -translate-y-1/2 items-center gap-2">
          {isSearching && <Loader2 className="h-4 w-4 animate-spin" />}
          {query && (
            <button
              onClick={() => {
                setQuery('');
                setResults([]);
              }}
              className="hover:bg-muted rounded p-1"
            >
              <X className="h-3 w-3" />
            </button>
          )}
          {getStatusIcon()}
        </div>
      </div>

      {/* Status message during loading */}
      {status === 'loading' && (
        <motion.div
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          className="bg-card border-border absolute top-full right-0 left-0 z-100 mt-2 rounded-lg border p-3 shadow-lg"
        >
          <div className="flex items-center gap-3">
            <Loader2 className="text-primary h-5 w-5 animate-spin" />
            <div>
              <p className="text-sm font-medium">Loading AI Model</p>
              <p className="text-muted-foreground text-xs">{statusMessage}</p>
            </div>
          </div>
          {progress && (
            <div className="mt-2">
              <div className="bg-muted h-1 overflow-hidden rounded-full">
                <motion.div
                  className="bg-primary h-full"
                  initial={{ width: 0 }}
                  animate={{
                    width: `${(progress.current / progress.total) * 100}%`,
                  }}
                />
              </div>
            </div>
          )}
        </motion.div>
      )}

      {/* Search Results */}
      <AnimatePresence>
        {showResults && results.length > 0 && (
          <motion.div
            ref={resultsRef}
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="bg-card border-border absolute top-full right-0 left-0 z-100 mt-2 max-h-[400px] overflow-y-auto rounded-lg border shadow-lg"
          >
            <div className="p-2">
              <p className="text-muted-foreground px-2 py-1 text-xs">
                {results.length} results  Powered by AI
              </p>
            </div>
            <div className="border-border border-t">
              {results.map((result, index) => (
                <motion.button
                  key={result.path}
                  initial={{ opacity: 0, x: -10 }}
                  animate={{ opacity: 1, x: 0 }}
                  transition={{ delay: index * 0.05 }}
                  onClick={() => {
                    onResultSelect?.(result.path);
                    setShowResults(false);
                    setQuery('');
                  }}
                  className={cn(
                    'flex w-full items-start gap-3 px-4 py-3 text-left',
                    'hover:bg-muted/50 transition-colors',
                    index === selectedIndex && 'bg-muted'
                  )}
                >
                  <FileText className="text-muted-foreground mt-0.5 h-5 w-5 shrink-0" />
                  <div className="min-w-0 flex-1">
                    <p className="truncate text-sm font-medium">{getFileName(result.path)}</p>
                    <p className="text-muted-foreground truncate text-xs">
                      {getParentPath(result.path)}
                    </p>
                  </div>
                  <div className="shrink-0">
                    <span className="bg-primary/10 text-primary rounded px-2 py-1 text-xs">
                      {Math.round(result.score * 100)}%
                    </span>
                  </div>
                </motion.button>
              ))}
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* No results */}
      <AnimatePresence>
        {showResults && query && !isSearching && results.length === 0 && isReady && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="bg-card border-border absolute top-full right-0 left-0 z-100 mt-2 rounded-lg border p-6 text-center shadow-lg"
          >
            <Search className="text-muted-foreground mx-auto mb-2 h-8 w-8" />
            <p className="text-muted-foreground text-sm">No files found</p>
            <p className="text-muted-foreground mt-1 text-xs">Try indexing your files first</p>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
</file>

<file path="src/components/conflict-resolver.tsx">
'use client';

import { useState } from 'react';
import {
  useScanConflicts,
  useDeleteConflict,
  useResolveConflictKeepConflict,
  ConflictFile,
} from '@/hooks/useSyncthing';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
  AlertTriangle,
  X,
  RefreshCw,
  Trash2,
  Check,
  FileWarning,
  File,
  Clock,
  HardDrive,
} from 'lucide-react';
import { cn, formatBytes } from '@/lib/utils';
import { toast } from 'sonner';

interface ConflictResolverProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  folderId: string;
  folderPath: string;
  folderLabel?: string;
}

function formatDate(timestamp?: number): string {
  if (!timestamp) return 'Unknown';
  try {
    return new Date(timestamp * 1000).toLocaleDateString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  } catch {
    return 'Unknown';
  }
}

function ConflictCard({
  conflict,
  folderPath,
  onResolve,
}: {
  conflict: ConflictFile;
  folderPath: string;
  onResolve: () => void;
}) {
  const deleteConflict = useDeleteConflict();
  const keepConflict = useResolveConflictKeepConflict();
  const [isResolving, setIsResolving] = useState(false);

  const handleKeepOriginal = async () => {
    setIsResolving(true);
    try {
      await deleteConflict.mutateAsync({
        folderPath,
        conflictFile: conflict.name,
      });
      toast.success('Conflict resolved - kept original file');
      onResolve();
    } catch (error) {
      toast.error('Failed to resolve conflict');
    } finally {
      setIsResolving(false);
    }
  };

  const handleKeepConflict = async () => {
    setIsResolving(true);
    try {
      await keepConflict.mutateAsync({
        folderPath,
        originalFile: conflict.original,
        conflictFile: conflict.name,
      });
      toast.success('Conflict resolved - kept newer version');
      onResolve();
    } catch (error) {
      toast.error('Failed to resolve conflict');
    } finally {
      setIsResolving(false);
    }
  };

  return (
    <div className="rounded-lg border border-amber-500/30 bg-amber-500/5 p-4">
      <div className="flex items-start gap-3">
        <div className="flex h-10 w-10 shrink-0 items-center justify-center rounded-lg bg-amber-500/20">
          <FileWarning className="h-5 w-5 text-amber-400" />
        </div>
        <div className="min-w-0 flex-1">
          <div className="flex items-start justify-between gap-2">
            <div className="min-w-0">
              <p className="truncate font-medium text-white">{conflict.original}</p>
              <p className="mt-1 truncate text-xs text-slate-400">Conflict: {conflict.name}</p>
            </div>
          </div>

          <div className="mt-3 flex flex-wrap items-center gap-4 text-xs text-slate-400">
            <span className="flex items-center gap-1">
              <HardDrive className="h-3 w-3" />
              {formatBytes(conflict.size)}
            </span>
            {conflict.modTime && (
              <span className="flex items-center gap-1">
                <Clock className="h-3 w-3" />
                {formatDate(conflict.modTime)}
              </span>
            )}
          </div>

          <div className="mt-4 flex flex-wrap gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleKeepOriginal}
              disabled={isResolving}
              className="border-red-500/30 bg-red-500/10 text-red-400 hover:bg-red-500/20"
            >
              {isResolving ? (
                <RefreshCw className="mr-1 h-3 w-3 animate-spin" />
              ) : (
                <Trash2 className="mr-1 h-3 w-3" />
              )}
              Keep Original
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={handleKeepConflict}
              disabled={isResolving}
              className="border-emerald-500/30 bg-emerald-500/10 text-emerald-400 hover:bg-emerald-500/20"
            >
              {isResolving ? (
                <RefreshCw className="mr-1 h-3 w-3 animate-spin" />
              ) : (
                <Check className="mr-1 h-3 w-3" />
              )}
              Keep This Version
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
}

export function ConflictResolver({
  open,
  onOpenChange,
  folderId,
  folderPath,
  folderLabel,
}: ConflictResolverProps) {
  const { data: conflicts, isLoading, refetch, isRefetching } = useScanConflicts(folderPath);

  if (!open) return null;

  const conflictList = conflicts || [];

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4 backdrop-blur-xs">
      <Card className="bg-background/95 border-border/50 flex max-h-[80vh] w-full max-w-2xl flex-col backdrop-blur-md">
        <CardHeader className="border-border/50 flex flex-row items-center justify-between space-y-0 border-b pb-4">
          <CardTitle className="flex items-center gap-2 text-xl font-semibold">
            <AlertTriangle className="h-5 w-5 text-amber-400" />
            Conflict Resolution
            {conflictList.length > 0 && (
              <span className="ml-2 rounded-full bg-amber-500/20 px-2 py-0.5 text-xs text-amber-400">
                {conflictList.length}
              </span>
            )}
          </CardTitle>
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              onClick={() => refetch()}
              disabled={isLoading || isRefetching}
            >
              <RefreshCw className={cn('h-4 w-4', (isLoading || isRefetching) && 'animate-spin')} />
            </Button>
            <Button variant="ghost" size="icon" onClick={() => onOpenChange(false)}>
              <X className="h-4 w-4" />
            </Button>
          </div>
        </CardHeader>

        <CardContent className="flex-1 overflow-y-auto p-4">
          <div className="mb-4">
            <p className="text-sm text-slate-400">
              Folder: <span className="text-white">{folderLabel || folderId}</span>
            </p>
            <p className="mt-1 text-xs text-slate-500">{folderPath}</p>
          </div>

          {isLoading ? (
            <div className="flex flex-col items-center justify-center py-12 text-center">
              <RefreshCw className="h-8 w-8 animate-spin text-slate-400" />
              <p className="mt-4 text-sm text-slate-400">Scanning for conflicts...</p>
            </div>
          ) : conflictList.length === 0 ? (
            <div className="flex flex-col items-center justify-center py-12 text-center">
              <div className="flex h-16 w-16 items-center justify-center rounded-full bg-emerald-500/20">
                <Check className="h-8 w-8 text-emerald-400" />
              </div>
              <p className="mt-4 text-lg font-medium text-white">No Conflicts</p>
              <p className="mt-2 text-sm text-slate-400">
                This folder has no file conflicts to resolve.
              </p>
            </div>
          ) : (
            <div className="space-y-3">
              <p className="text-sm text-slate-400">
                {conflictList.length} conflict
                {conflictList.length !== 1 ? 's' : ''} found. Choose which version to keep for each
                file.
              </p>
              {conflictList.map((conflict) => (
                <ConflictCard
                  key={conflict.name}
                  conflict={conflict}
                  folderPath={folderPath}
                  onResolve={() => refetch()}
                />
              ))}
            </div>
          )}
        </CardContent>

        <div className="border-border/50 border-t p-4">
          <div className="flex items-center justify-between">
            <p className="text-xs text-slate-500">
              Conflicts occur when the same file is modified on multiple devices simultaneously.
            </p>
            <Button variant="outline" size="sm" onClick={() => onOpenChange(false)}>
              Close
            </Button>
          </div>
        </div>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/debug-panel.tsx">
'use client';

import { useState, useEffect, useCallback } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import {
  Bug,
  Download,
  Trash2,
  AlertCircle,
  CheckCircle,
  XCircle,
  Activity,
  Database,
  Clock,
  X,
} from 'lucide-react';
import { logger, LogEntry } from '@/lib/logger';
import { healthMonitor, HealthStatus } from '@/lib/health-monitor';
import { syncthingCircuitBreaker } from '@/lib/retry';

type LogFilter = 'all' | 'error' | 'warn' | 'info' | 'debug';

export default function DebugPanel() {
  const [isOpen, setIsOpen] = useState(false);
  const [logs, setLogs] = useState<LogEntry[]>([]);
  const [filter, setFilter] = useState<LogFilter>('all');
  const [healthStatus, setHealthStatus] = useState<Map<string, HealthStatus>>(new Map());
  const [circuitState, setCircuitState] = useState(syncthingCircuitBreaker.getState());

  // Listen for Ctrl+Shift+D to toggle panel
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.ctrlKey && e.shiftKey && e.key === 'D') {
        e.preventDefault();
        setIsOpen((prev) => !prev);
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  // Subscribe to log updates
  useEffect(() => {
    if (isOpen) {
      const unsubscribe = logger.subscribe(() => {
        setLogs(logger.exportLogs());
      });
      // Initial load
      setLogs(logger.exportLogs());
      return () => {
        unsubscribe();
      };
    }
  }, [isOpen]);

  // Subscribe to health status updates
  useEffect(() => {
    if (isOpen) {
      const unsubscribe = healthMonitor.subscribe((status) => {
        setHealthStatus(status);
      });
      return unsubscribe;
    }
  }, [isOpen]);

  // Update circuit breaker state periodically
  useEffect(() => {
    if (isOpen) {
      const interval = setInterval(() => {
        setCircuitState(syncthingCircuitBreaker.getState());
      }, 1000);
      return () => clearInterval(interval);
    }
  }, [isOpen]);

  const handleClearLogs = useCallback(() => {
    logger.clearHistory();
    setLogs([]);
  }, []);

  const handleDownloadLogs = useCallback(() => {
    logger.downloadLogs();
  }, []);

  const handleResetCircuitBreaker = useCallback(() => {
    syncthingCircuitBreaker.reset();
    setCircuitState(syncthingCircuitBreaker.getState());
    logger.info('Circuit breaker manually reset');
  }, []);

  const filteredLogs = logs.filter((log) => filter === 'all' || log.level === filter);

  const stats = {
    total: logs.length,
    errors: logs.filter((l) => l.level === 'error').length,
    warnings: logs.filter((l) => l.level === 'warn').length,
  };

  const healthSummary = healthMonitor.getSummary();

  if (!isOpen) {
    return (
      <Button
        onClick={() => setIsOpen(true)}
        className="fixed right-4 bottom-4 z-50 h-12 w-12 rounded-full bg-indigo-600 shadow-lg hover:bg-indigo-700"
        title="Open Debug Panel (Ctrl+Shift+D)"
      >
        <Bug className="h-5 w-5" />
      </Button>
    );
  }

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4 backdrop-blur-xs">
      <Card className="flex h-[80vh] w-full max-w-6xl flex-col border-slate-700 bg-slate-900">
        <CardHeader className="shrink-0 border-b border-slate-800">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <Bug className="h-6 w-6 text-indigo-400" />
              <CardTitle className="text-white">Debug Panel</CardTitle>
              <Badge variant="outline" className="text-xs text-slate-400">
                Ctrl+Shift+D
              </Badge>
            </div>
            <div className="flex items-center gap-2">
              <Badge variant="outline" className="text-xs">
                {stats.total} logs
              </Badge>
              <Button
                variant="ghost"
                size="sm"
                onClick={handleDownloadLogs}
                className="text-slate-400 hover:text-white"
              >
                <Download className="mr-1 h-4 w-4" />
                Export
              </Button>
              <Button
                variant="ghost"
                size="sm"
                onClick={handleClearLogs}
                className="text-slate-400 hover:text-white"
              >
                <Trash2 className="mr-1 h-4 w-4" />
                Clear
              </Button>
              <Button
                variant="ghost"
                size="sm"
                onClick={() => setIsOpen(false)}
                className="text-slate-400 hover:text-white"
              >
                <X className="h-4 w-4" />
              </Button>
            </div>
          </div>
        </CardHeader>

        <div className="flex min-h-0 flex-1 overflow-hidden">
          {/* Sidebar */}
          <div className="w-64 shrink-0 space-y-4 overflow-y-auto border-r border-slate-800 p-4">
            {/* Health Status */}
            <div>
              <h3 className="mb-2 text-sm font-medium text-slate-400">System Health</h3>
              <div className="space-y-2">
                {Array.from(healthStatus.entries()).map(([name, status]) => (
                  <div
                    key={name}
                    className="flex items-center justify-between rounded bg-slate-800 p-2"
                  >
                    <span className="truncate text-sm text-slate-300">{name}</span>
                    {status.healthy ? (
                      <CheckCircle className="h-4 w-4 shrink-0 text-green-400" />
                    ) : (
                      <XCircle className="h-4 w-4 shrink-0 text-red-400" />
                    )}
                  </div>
                ))}
                {healthStatus.size === 0 && (
                  <p className="text-xs text-slate-500 italic">No health checks registered</p>
                )}

                {/* Health Summary */}
                <div className="mt-2 flex items-center justify-between rounded border-t border-slate-700 bg-slate-800 p-2">
                  <span className="text-sm text-slate-300">Overall</span>
                  <Badge
                    variant={healthSummary.unhealthy === 0 ? 'default' : 'destructive'}
                    className="text-xs"
                  >
                    {healthSummary.healthy}/{healthSummary.total}
                  </Badge>
                </div>
              </div>
            </div>

            {/* Circuit Breaker Status */}
            <div>
              <h3 className="mb-2 text-sm font-medium text-slate-400">Circuit Breaker</h3>
              <div className="space-y-2 rounded bg-slate-800 p-2">
                <div className="flex items-center justify-between">
                  <span className="text-sm text-slate-300">State</span>
                  <Badge
                    variant={circuitState.state === 'closed' ? 'default' : 'destructive'}
                    className="text-xs uppercase"
                  >
                    {circuitState.state}
                  </Badge>
                </div>
                <div className="flex items-center justify-between text-xs text-slate-400">
                  <span>Failures: {circuitState.failureCount}</span>
                  <span>Successes: {circuitState.successCount}</span>
                </div>
                {circuitState.state !== 'closed' && (
                  <Button
                    variant="outline"
                    size="sm"
                    className="mt-1 w-full text-xs"
                    onClick={handleResetCircuitBreaker}
                  >
                    Reset Circuit Breaker
                  </Button>
                )}
              </div>
            </div>

            {/* Stats */}
            <div>
              <h3 className="mb-2 text-sm font-medium text-slate-400">Log Statistics</h3>
              <div className="space-y-1 text-sm">
                <div className="flex justify-between text-slate-300">
                  <span>Total Logs:</span>
                  <span className="font-mono">{stats.total}</span>
                </div>
                <div className="flex justify-between text-red-400">
                  <span>Errors:</span>
                  <span className="font-mono">{stats.errors}</span>
                </div>
                <div className="flex justify-between text-yellow-400">
                  <span>Warnings:</span>
                  <span className="font-mono">{stats.warnings}</span>
                </div>
              </div>
            </div>

            {/* Filters */}
            <div>
              <h3 className="mb-2 text-sm font-medium text-slate-400">Filters</h3>
              <div className="space-y-1">
                {(['all', 'error', 'warn', 'info', 'debug'] as const).map((level) => (
                  <button
                    key={level}
                    onClick={() => setFilter(level)}
                    className={`w-full rounded px-3 py-2 text-left text-sm transition-colors ${
                      filter === level
                        ? 'bg-indigo-600 text-white'
                        : 'text-slate-400 hover:bg-slate-800'
                    }`}
                  >
                    {level.charAt(0).toUpperCase() + level.slice(1)}
                  </button>
                ))}
              </div>
            </div>

            {/* Quick Actions */}
            <div>
              <h3 className="mb-2 text-sm font-medium text-slate-400">Quick Actions</h3>
              <div className="space-y-1">
                <Button
                  variant="outline"
                  size="sm"
                  className="w-full justify-start border-slate-700 text-xs"
                  onClick={() =>
                    logger.info('Test log entry', {
                      type: 'manual',
                    })
                  }
                >
                  <Activity className="mr-2 h-3 w-3" />
                  Test Log
                </Button>
                <Button
                  variant="outline"
                  size="sm"
                  className="w-full justify-start border-slate-700 text-xs"
                  onClick={() => healthMonitor.runAllChecks()}
                >
                  <CheckCircle className="mr-2 h-3 w-3" />
                  Run Health Checks
                </Button>
                <Button
                  variant="outline"
                  size="sm"
                  className="w-full justify-start border-slate-700 text-xs"
                  onClick={() => {
                    console.log('Check Application tab in DevTools');
                    logger.info('Check Application tab in DevTools for IndexedDB');
                  }}
                >
                  <Database className="mr-2 h-3 w-3" />
                  View IndexedDB
                </Button>
              </div>
            </div>
          </div>

          {/* Logs */}
          <div className="min-w-0 flex-1 overflow-y-auto p-4">
            <div className="space-y-2 font-mono text-xs">
              {filteredLogs.length === 0 ? (
                <div className="py-8 text-center text-slate-500">No logs to display</div>
              ) : (
                [...filteredLogs].reverse().map((log, i) => {
                  const Icon =
                    {
                      debug: Activity,
                      info: CheckCircle,
                      warn: AlertCircle,
                      error: XCircle,
                    }[log.level] || Activity;

                  const color =
                    {
                      debug: 'text-cyan-400',
                      info: 'text-green-400',
                      warn: 'text-yellow-400',
                      error: 'text-red-400',
                    }[log.level] || 'text-slate-400';

                  return (
                    <div
                      key={`${log.timestamp.getTime()}-${i}`}
                      className="rounded border border-slate-700 bg-slate-800 p-3 transition-colors hover:border-slate-600"
                    >
                      <div className="flex items-start gap-2">
                        <Icon className={`mt-0.5 h-4 w-4 ${color} shrink-0`} />
                        <div className="min-w-0 flex-1">
                          <div className="mb-1 flex flex-wrap items-center gap-2">
                            <span className={`font-medium ${color}`}>
                              {log.level.toUpperCase()}
                            </span>
                            <span className="flex items-center text-[10px] text-slate-500">
                              <Clock className="mr-1 h-3 w-3" />
                              {new Date(log.timestamp).toLocaleTimeString()}
                            </span>
                          </div>
                          <p className="wrap-break-word text-slate-300">{log.message}</p>
                          {log.context && Object.keys(log.context).length > 0 && (
                            <details className="mt-2">
                              <summary className="cursor-pointer text-slate-500 hover:text-slate-400">
                                Context
                              </summary>
                              <pre className="mt-1 overflow-x-auto rounded bg-slate-900 p-2 text-[10px] text-slate-400">
                                {JSON.stringify(log.context, null, 2)}
                              </pre>
                            </details>
                          )}
                        </div>
                      </div>
                    </div>
                  );
                })
              )}
            </div>
          </div>
        </div>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/file-browser.tsx">
'use client';

import { useState } from 'react';
import {
  useOpenFolderInExplorer,
  useBrowseFolder,
  useBrowseVersions,
  useRestoreVersion,
  VersionEntry,
} from '@/hooks/useSyncthing';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
  FolderOpen,
  X,
  RefreshCw,
  File,
  Folder,
  ChevronRight,
  ChevronLeft,
  ExternalLink,
  Home,
  History,
  RotateCcw,
  Clock,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { toast } from 'sonner';

interface FileBrowserProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  folderId: string;
  folderPath: string;
  folderLabel?: string;
}

interface FileEntry {
  name: string;
  type: 'file' | 'directory';
  size?: number;
  modTime?: string;
  permissions?: string;
}

function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

function formatDate(dateInput: string | number): string {
  try {
    const date =
      typeof dateInput === 'number'
        ? new Date(dateInput * 1000) // Unix timestamp in seconds
        : new Date(dateInput);
    return date.toLocaleDateString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  } catch {
    return String(dateInput);
  }
}

export function FileBrowser({
  open,
  onOpenChange,
  folderId,
  folderPath,
  folderLabel,
}: FileBrowserProps) {
  const [currentPath, setCurrentPath] = useState<string[]>([]);
  const [showVersions, setShowVersions] = useState(false);

  const openInExplorer = useOpenFolderInExplorer();
  const restoreVersion = useRestoreVersion();

  const {
    data: contents,
    isLoading: isLoadingFiles,
    refetch: refetchFiles,
  } = useBrowseFolder(folderId, currentPath.length > 0 ? currentPath.join('/') : undefined);

  const {
    data: versions,
    isLoading: isLoadingVersions,
    refetch: refetchVersions,
  } = useBrowseVersions(folderPath, currentPath.length > 0 ? currentPath.join('/') : undefined);

  if (!open) return null;

  const isLoading = showVersions ? isLoadingVersions : isLoadingFiles;
  const refetch = showVersions ? refetchVersions : refetchFiles;
  const fileEntries = showVersions
    ? (versions as VersionEntry[] | undefined) || []
    : (contents as FileEntry[] | undefined) || [];

  const handleNavigate = (entry: FileEntry | VersionEntry) => {
    if (entry.type === 'directory') {
      setCurrentPath([...currentPath, entry.name]);
    }
  };

  const handleRestoreVersion = async (entry: VersionEntry) => {
    try {
      const versionPath =
        currentPath.length > 0 ? `${currentPath.join('/')}/${entry.name}` : entry.name;
      const originalPath =
        currentPath.length > 0
          ? `${currentPath.join('/')}/${entry.originalName}`
          : entry.originalName;

      await restoreVersion.mutateAsync({
        folderPath,
        versionPath,
        originalName: originalPath,
        overwrite: true,
      });
      toast.success(`Restored ${entry.originalName}`);
    } catch (error) {
      toast.error('Failed to restore file');
    }
  };

  const handleGoBack = () => {
    setCurrentPath(currentPath.slice(0, -1));
  };

  const handleGoHome = () => {
    setCurrentPath([]);
  };

  const handleOpenInExplorer = async () => {
    try {
      const fullPath =
        currentPath.length > 0 ? `${folderPath}/${currentPath.join('/')}` : folderPath;
      await openInExplorer.mutateAsync(fullPath);
      toast.success('Opened in file explorer');
    } catch (error) {
      toast.error('Failed to open in file explorer');
    }
  };

  const breadcrumbs = [
    {
      name: showVersions ? '.stversions' : folderLabel || folderId,
      path: [],
    },
    ...currentPath.map((segment, index) => ({
      name: segment,
      path: currentPath.slice(0, index + 1),
    })),
  ];

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4 backdrop-blur-xs">
      <Card className="bg-background/95 border-border/50 flex max-h-[80vh] w-full max-w-3xl flex-col backdrop-blur-md">
        <CardHeader className="border-border/50 flex flex-row items-center justify-between space-y-0 border-b pb-4">
          <CardTitle className="flex items-center gap-2 text-xl font-semibold">
            {showVersions ? (
              <History className="h-5 w-5 text-amber-500" />
            ) : (
              <FolderOpen className="text-muted-foreground h-5 w-5" />
            )}
            {showVersions ? 'Version History' : 'File Browser'}
          </CardTitle>
          <div className="flex items-center gap-2">
            <Button
              variant={showVersions ? 'default' : 'ghost'}
              size="sm"
              onClick={() => {
                setShowVersions(!showVersions);
                setCurrentPath([]);
              }}
              className={cn(showVersions && 'bg-amber-500/20 text-amber-500 hover:bg-amber-500/30')}
              title={showVersions ? 'Show current files' : 'Show file versions'}
            >
              <History className="mr-1 h-4 w-4" />
              {showVersions ? 'Versions' : 'History'}
            </Button>
            <Button
              variant="ghost"
              size="icon"
              onClick={handleOpenInExplorer}
              disabled={openInExplorer.isPending || showVersions}
              title="Open in system file explorer"
            >
              <ExternalLink className="h-4 w-4" />
            </Button>
            <Button variant="ghost" size="icon" onClick={() => refetch()} disabled={isLoading}>
              <RefreshCw className={cn('h-4 w-4', isLoading && 'animate-spin')} />
            </Button>
            <Button variant="ghost" size="icon" onClick={() => onOpenChange(false)}>
              <X className="h-4 w-4" />
            </Button>
          </div>
        </CardHeader>

        {/* Navigation Bar */}
        <div className="border-border/50 flex items-center gap-2 border-b p-3">
          <Button
            variant="ghost"
            size="icon"
            onClick={handleGoHome}
            disabled={currentPath.length === 0}
            className="h-8 w-8"
          >
            <Home className="h-4 w-4" />
          </Button>
          <Button
            variant="ghost"
            size="icon"
            onClick={handleGoBack}
            disabled={currentPath.length === 0}
            className="h-8 w-8"
          >
            <ChevronLeft className="h-4 w-4" />
          </Button>

          {/* Breadcrumbs */}
          <div className="flex flex-1 items-center gap-1 overflow-x-auto text-sm">
            {breadcrumbs.map((crumb, index) => (
              <div key={index} className="flex items-center">
                {index > 0 && <ChevronRight className="text-muted-foreground mx-1 h-4 w-4" />}
                <button
                  onClick={() => setCurrentPath(crumb.path)}
                  className={cn(
                    'hover:bg-muted/50 max-w-[150px] truncate rounded px-2 py-1 transition-colors',
                    index === breadcrumbs.length - 1
                      ? 'text-foreground font-medium'
                      : 'text-muted-foreground'
                  )}
                  title={crumb.name}
                >
                  {crumb.name}
                </button>
              </div>
            ))}
          </div>
        </div>

        <CardContent className="flex-1 overflow-hidden p-0">
          <div className="h-[400px] overflow-y-auto">
            {isLoading ? (
              <div className="flex h-full items-center justify-center">
                <RefreshCw className="text-muted-foreground h-6 w-6 animate-spin" />
              </div>
            ) : fileEntries.length === 0 ? (
              <div className="text-muted-foreground flex h-full flex-col items-center justify-center">
                {showVersions ? (
                  <>
                    <History className="mb-2 h-12 w-12" />
                    <p>No file versions found</p>
                    <p className="mt-1 text-xs">
                      Enable versioning on this folder to keep file history
                    </p>
                  </>
                ) : (
                  <>
                    <Folder className="mb-2 h-12 w-12" />
                    <p>This folder is empty</p>
                  </>
                )}
              </div>
            ) : (
              <div className="divide-border/30 divide-y">
                {/* Directories first, then files, both alphabetically sorted */}
                {[...fileEntries]
                  .sort((a, b) => {
                    if (a.type !== b.type) {
                      return a.type === 'directory' ? -1 : 1;
                    }
                    return a.name.localeCompare(b.name);
                  })
                  .map((entry, index) => {
                    const versionEntry = entry as VersionEntry;
                    const isVersionFile = showVersions && entry.type === 'file';

                    return (
                      <div
                        key={index}
                        className={cn(
                          'hover:bg-muted/30 group flex items-center gap-3 px-4 py-2 transition-colors',
                          entry.type === 'directory' && 'cursor-pointer'
                        )}
                        onClick={() => entry.type === 'directory' && handleNavigate(entry)}
                      >
                        {entry.type === 'directory' ? (
                          <Folder className="h-5 w-5 shrink-0 text-blue-400" />
                        ) : showVersions ? (
                          <Clock className="h-5 w-5 shrink-0 text-amber-400" />
                        ) : (
                          <File className="text-muted-foreground h-5 w-5 shrink-0" />
                        )}
                        <div className="min-w-0 flex-1">
                          <p className="truncate text-sm font-medium">
                            {showVersions && versionEntry.originalName
                              ? versionEntry.originalName
                              : entry.name}
                          </p>
                          {isVersionFile && versionEntry.versionTime && (
                            <p className="text-xs text-amber-500/70">
                              Version from {versionEntry.versionTime}
                            </p>
                          )}
                        </div>
                        {entry.size !== undefined && entry.type === 'file' && (
                          <span className="text-muted-foreground text-xs">
                            {formatBytes(entry.size)}
                          </span>
                        )}
                        {entry.modTime && !isVersionFile && (
                          <span className="text-muted-foreground hidden text-xs sm:block">
                            {formatDate(entry.modTime)}
                          </span>
                        )}
                        {isVersionFile && (
                          <Button
                            variant="ghost"
                            size="sm"
                            className="text-amber-500 opacity-0 transition-opacity group-hover:opacity-100 hover:bg-amber-500/10 hover:text-amber-400"
                            onClick={(e) => {
                              e.stopPropagation();
                              handleRestoreVersion(versionEntry);
                            }}
                            disabled={restoreVersion.isPending}
                          >
                            <RotateCcw className="mr-1 h-4 w-4" />
                            Restore
                          </Button>
                        )}
                        {entry.type === 'directory' && (
                          <ChevronRight className="text-muted-foreground h-4 w-4" />
                        )}
                      </div>
                    );
                  })}
              </div>
            )}
          </div>
        </CardContent>

        <div className="border-border/50 text-muted-foreground flex items-center justify-between border-t p-3 text-xs">
          <span>{fileEntries.length} items</span>
          <span className="max-w-[300px] truncate" title={folderPath}>
            {folderPath}
          </span>
        </div>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/ignore-patterns-dialog.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useFolderIgnores, useSetFolderIgnores } from '@/hooks/useSyncthing';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { FileX, X, Save, RefreshCw, Plus, Trash2, HelpCircle, FileText } from 'lucide-react';
import { cn } from '@/lib/utils';
import { toast } from 'sonner';

interface IgnorePatternsDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  folderId: string;
  folderLabel?: string;
}

const commonPatterns = [
  { pattern: '.DS_Store', description: 'macOS folder metadata' },
  { pattern: 'Thumbs.db', description: 'Windows thumbnail cache' },
  { pattern: 'desktop.ini', description: 'Windows folder settings' },
  { pattern: 'node_modules', description: 'Node.js dependencies' },
  { pattern: '.git', description: 'Git repository folder' },
  { pattern: '*.tmp', description: 'Temporary files' },
  { pattern: '*.log', description: 'Log files' },
  { pattern: '.env*', description: 'Environment files' },
  { pattern: '__pycache__', description: 'Python bytecode cache' },
  { pattern: '*.pyc', description: 'Python compiled files' },
  { pattern: 'target/', description: 'Rust/Java build output' },
  { pattern: 'dist/', description: 'Build distribution folder' },
  { pattern: 'build/', description: 'Build output folder' },
  { pattern: '.next/', description: 'Next.js build folder' },
  { pattern: '*.bak', description: 'Backup files' },
  { pattern: '~*', description: 'Temporary editor files' },
  { pattern: '#*#', description: 'Emacs auto-save files' },
  { pattern: '.*.swp', description: 'Vim swap files' },
];

export function IgnorePatternsDialog({
  open,
  onOpenChange,
  folderId,
  folderLabel,
}: IgnorePatternsDialogProps) {
  const [patterns, setPatterns] = useState<string[]>([]);
  const [newPattern, setNewPattern] = useState('');
  const [showHelp, setShowHelp] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);

  const { data: ignoreData, isLoading, refetch } = useFolderIgnores(folderId);
  const setIgnoresMutation = useSetFolderIgnores();

  // Initialize patterns from server data
  useEffect(() => {
    if (ignoreData?.ignore) {
      setPatterns(ignoreData.ignore.filter((p: string) => p.trim() !== ''));
      setHasChanges(false);
    }
  }, [ignoreData]);

  if (!open) return null;

  const handleAddPattern = () => {
    const trimmed = newPattern.trim();
    if (!trimmed) return;
    if (patterns.includes(trimmed)) {
      toast.error('Pattern already exists');
      return;
    }
    setPatterns([...patterns, trimmed]);
    setNewPattern('');
    setHasChanges(true);
  };

  const handleRemovePattern = (index: number) => {
    setPatterns(patterns.filter((_, i) => i !== index));
    setHasChanges(true);
  };

  const handleAddCommonPattern = (pattern: string) => {
    if (patterns.includes(pattern)) {
      toast.info('Pattern already added');
      return;
    }
    setPatterns([...patterns, pattern]);
    setHasChanges(true);
  };

  const handleSave = async () => {
    try {
      await setIgnoresMutation.mutateAsync({
        folderId,
        ignorePatterns: patterns,
      });
      toast.success('Ignore patterns saved');
      setHasChanges(false);
    } catch (error) {
      toast.error('Failed to save ignore patterns');
    }
  };

  const handleReset = () => {
    if (ignoreData?.ignore) {
      setPatterns(ignoreData.ignore.filter((p: string) => p.trim() !== ''));
      setHasChanges(false);
    }
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4 backdrop-blur-xs">
      <Card className="bg-background/95 border-border/50 flex max-h-[85vh] w-full max-w-2xl flex-col backdrop-blur-md">
        <CardHeader className="border-border/50 flex flex-row items-center justify-between space-y-0 border-b pb-4">
          <CardTitle className="flex items-center gap-2 text-xl font-semibold">
            <FileX className="text-muted-foreground h-5 w-5" />
            Ignore Patterns
            {folderLabel && (
              <span className="text-muted-foreground text-sm font-normal"> {folderLabel}</span>
            )}
          </CardTitle>
          <div className="flex items-center gap-2">
            <Button variant="ghost" size="icon" onClick={() => setShowHelp(!showHelp)} title="Help">
              <HelpCircle className={cn('h-4 w-4', showHelp && 'text-primary')} />
            </Button>
            <Button variant="ghost" size="icon" onClick={() => refetch()} disabled={isLoading}>
              <RefreshCw className={cn('h-4 w-4', isLoading && 'animate-spin')} />
            </Button>
            <Button variant="ghost" size="icon" onClick={() => onOpenChange(false)}>
              <X className="h-4 w-4" />
            </Button>
          </div>
        </CardHeader>

        {showHelp && (
          <div className="bg-muted/30 border-border/50 border-b p-4 text-sm">
            <h4 className="mb-2 font-medium">Pattern Syntax</h4>
            <ul className="text-muted-foreground space-y-1 text-xs">
              <li>
                 <code className="bg-muted rounded px-1">*</code>  matches any characters except
                path separator
              </li>
              <li>
                 <code className="bg-muted rounded px-1">**</code>  matches any characters
                including path separator
              </li>
              <li>
                 <code className="bg-muted rounded px-1">?</code>  matches a single character
              </li>
              <li>
                 <code className="bg-muted rounded px-1">[abc]</code>  matches any character in
                the brackets
              </li>
              <li>
                 <code className="bg-muted rounded px-1">!</code> prefix  negates the pattern
                (include instead of ignore)
              </li>
              <li>
                 <code className="bg-muted rounded px-1">/</code> prefix  anchors to folder root
              </li>
              <li>
                 <code className="bg-muted rounded px-1">//</code> prefix  comment line
              </li>
            </ul>
          </div>
        )}

        <CardContent className="flex-1 space-y-4 overflow-hidden p-4">
          {/* Add new pattern */}
          <div className="flex gap-2">
            <input
              type="text"
              value={newPattern}
              onChange={(e) => setNewPattern(e.target.value)}
              onKeyDown={(e) => e.key === 'Enter' && handleAddPattern()}
              placeholder="Enter pattern (e.g., *.log or node_modules)"
              className="border-border/50 bg-background/50 placeholder:text-muted-foreground focus:ring-primary/50 h-9 flex-1 rounded-md border px-3 text-sm focus:ring-2 focus:outline-hidden"
            />
            <Button onClick={handleAddPattern} disabled={!newPattern.trim()} size="sm">
              <Plus className="mr-1 h-4 w-4" />
              Add
            </Button>
          </div>

          {/* Current patterns */}
          <div className="space-y-2">
            <h4 className="text-muted-foreground text-sm font-medium">
              Current Patterns ({patterns.length})
            </h4>
            <div className="border-border/30 bg-muted/20 max-h-[200px] space-y-1 overflow-y-auto rounded-md border p-2">
              {isLoading ? (
                <div className="flex items-center justify-center py-4">
                  <RefreshCw className="text-muted-foreground h-5 w-5 animate-spin" />
                </div>
              ) : patterns.length === 0 ? (
                <div className="text-muted-foreground flex flex-col items-center py-4 text-sm">
                  <FileText className="mb-1 h-6 w-6" />
                  <span>No ignore patterns defined</span>
                </div>
              ) : (
                patterns.map((pattern, index) => (
                  <div
                    key={index}
                    className="hover:bg-muted/50 group flex items-center justify-between rounded px-2 py-1"
                  >
                    <code className="font-mono text-sm">{pattern}</code>
                    <Button
                      variant="ghost"
                      size="icon"
                      className="h-6 w-6 opacity-0 transition-opacity group-hover:opacity-100"
                      onClick={() => handleRemovePattern(index)}
                    >
                      <Trash2 className="text-destructive h-3 w-3" />
                    </Button>
                  </div>
                ))
              )}
            </div>
          </div>

          {/* Common patterns */}
          <div className="space-y-2">
            <h4 className="text-muted-foreground text-sm font-medium">Quick Add Common Patterns</h4>
            <div className="flex max-h-[120px] flex-wrap gap-1 overflow-y-auto">
              {commonPatterns.map(({ pattern, description }) => (
                <button
                  key={pattern}
                  onClick={() => handleAddCommonPattern(pattern)}
                  className={cn(
                    'border-border/50 bg-background/50 rounded border px-2 py-1 text-xs',
                    'hover:bg-primary/10 hover:border-primary/50 transition-colors',
                    patterns.includes(pattern) && 'cursor-not-allowed opacity-50'
                  )}
                  disabled={patterns.includes(pattern)}
                  title={description}
                >
                  {pattern}
                </button>
              ))}
            </div>
          </div>
        </CardContent>

        <div className="border-border/50 flex items-center justify-between border-t p-4">
          <div className="text-muted-foreground text-xs">
            {hasChanges && <span className="text-yellow-500"> Unsaved changes</span>}
          </div>
          <div className="flex gap-2">
            <Button variant="outline" onClick={handleReset} disabled={!hasChanges}>
              Reset
            </Button>
            <Button onClick={handleSave} disabled={!hasChanges || setIgnoresMutation.isPending}>
              {setIgnoresMutation.isPending ? (
                <RefreshCw className="mr-2 h-4 w-4 animate-spin" />
              ) : (
                <Save className="mr-2 h-4 w-4" />
              )}
              Save Patterns
            </Button>
          </div>
        </div>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/log-viewer.tsx">
'use client';

import { useState, useEffect, useRef } from 'react';
import { useSystemLogs } from '@/hooks/useSyncthing';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
  RefreshCw,
  X,
  AlertCircle,
  AlertTriangle,
  Info,
  Bug,
  ChevronDown,
  Download,
  Trash2,
} from 'lucide-react';
import { cn } from '@/lib/utils';

interface LogViewerProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

interface LogEntry {
  when?: string;
  level?: string;
  message?: string;
}

type LogLevel = 'all' | 'error' | 'warning' | 'info' | 'debug';

const levelConfig: Record<string, { icon: typeof Info; color: string; bg: string }> = {
  error: { icon: AlertCircle, color: 'text-red-500', bg: 'bg-red-500/10' },
  warning: {
    icon: AlertTriangle,
    color: 'text-yellow-500',
    bg: 'bg-yellow-500/10',
  },
  info: { icon: Info, color: 'text-blue-500', bg: 'bg-blue-500/10' },
  debug: { icon: Bug, color: 'text-gray-500', bg: 'bg-gray-500/10' },
  verbose: { icon: Bug, color: 'text-gray-400', bg: 'bg-gray-400/10' },
};

export function LogViewer({ open, onOpenChange }: LogViewerProps) {
  const [filter, setFilter] = useState<LogLevel>('all');
  const [autoScroll, setAutoScroll] = useState(true);
  const logContainerRef = useRef<HTMLDivElement>(null);

  const { data: logs, isLoading, refetch, isRefetching } = useSystemLogs();

  // Auto-scroll to bottom when new logs arrive
  useEffect(() => {
    if (autoScroll && logContainerRef.current) {
      logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
    }
  }, [logs, autoScroll]);

  if (!open) return null;

  const logEntries = (logs as LogEntry[] | undefined) || [];
  const filteredLogs = logEntries.filter((log: LogEntry) => {
    if (filter === 'all') return true;
    const level = log.level?.toLowerCase() || 'info';
    return level === filter;
  });

  const getLogLevel = (log: { level?: string; message?: string }): string => {
    if (log.level) return log.level.toLowerCase();
    // Try to infer from message
    const msg = log.message?.toLowerCase() || '';
    if (msg.includes('error') || msg.includes('failed')) return 'error';
    if (msg.includes('warning') || msg.includes('warn')) return 'warning';
    return 'info';
  };

  const handleExport = () => {
    if (!logEntries.length) return;
    const content = logEntries
      .map((log: LogEntry) => `[${log.when || ''}] [${log.level || 'INFO'}] ${log.message || ''}`)
      .join('\n');

    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `syncthing-logs-${new Date().toISOString().split('T')[0]}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4 backdrop-blur-xs">
      <Card className="bg-background/95 border-border/50 flex max-h-[80vh] w-full max-w-4xl flex-col backdrop-blur-md">
        <CardHeader className="border-border/50 flex flex-row items-center justify-between space-y-0 border-b pb-4">
          <CardTitle className="flex items-center gap-2 text-xl font-semibold">
            <Bug className="text-muted-foreground h-5 w-5" />
            System Logs
          </CardTitle>
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              onClick={handleExport}
              disabled={!logEntries.length}
              title="Export logs"
            >
              <Download className="h-4 w-4" />
            </Button>
            <Button variant="ghost" size="icon" onClick={() => refetch()} disabled={isRefetching}>
              <RefreshCw className={cn('h-4 w-4', isRefetching && 'animate-spin')} />
            </Button>
            <Button variant="ghost" size="icon" onClick={() => onOpenChange(false)}>
              <X className="h-4 w-4" />
            </Button>
          </div>
        </CardHeader>

        <div className="border-border/50 flex flex-wrap items-center gap-4 border-b p-4">
          {/* Level Filter */}
          <div className="flex items-center gap-2">
            <span className="text-muted-foreground text-sm">Level:</span>
            <div className="flex gap-1">
              {(['all', 'error', 'warning', 'info', 'debug'] as LogLevel[]).map((level) => (
                <Button
                  key={level}
                  variant={filter === level ? 'default' : 'ghost'}
                  size="sm"
                  onClick={() => setFilter(level)}
                  className={cn(
                    'text-xs capitalize',
                    filter === level && 'bg-primary text-primary-foreground'
                  )}
                >
                  {level}
                </Button>
              ))}
            </div>
          </div>

          {/* Auto-scroll toggle */}
          <div className="ml-auto flex items-center gap-2">
            <label className="flex cursor-pointer items-center gap-2">
              <input
                type="checkbox"
                checked={autoScroll}
                onChange={(e) => setAutoScroll(e.target.checked)}
                className="border-border rounded"
              />
              <span className="text-muted-foreground text-sm">Auto-scroll</span>
            </label>
          </div>
        </div>

        <CardContent className="flex-1 overflow-hidden p-0">
          <div ref={logContainerRef} className="h-[400px] overflow-y-auto font-mono text-xs">
            {isLoading ? (
              <div className="flex h-full items-center justify-center">
                <RefreshCw className="text-muted-foreground h-6 w-6 animate-spin" />
              </div>
            ) : filteredLogs.length === 0 ? (
              <div className="text-muted-foreground flex h-full flex-col items-center justify-center">
                <Info className="mb-2 h-8 w-8" />
                <p>No logs to display</p>
                <p className="text-xs">Logs will appear here when Syncthing generates them</p>
              </div>
            ) : (
              <div className="divide-border/30 divide-y">
                {filteredLogs.map((log, index) => {
                  const level = getLogLevel(log);
                  const config = levelConfig[level] || levelConfig.info;
                  const Icon = config.icon;

                  return (
                    <div
                      key={index}
                      className={cn(
                        'hover:bg-muted/30 flex items-start gap-2 p-2 transition-colors',
                        config.bg
                      )}
                    >
                      <Icon className={cn('mt-0.5 h-4 w-4 shrink-0', config.color)} />
                      <div className="min-w-0 flex-1">
                        <div className="text-muted-foreground mb-0.5 flex items-center gap-2 text-[10px]">
                          <span>{log.when ? new Date(log.when).toLocaleTimeString() : ''}</span>
                          <span className={cn('font-medium uppercase', config.color)}>{level}</span>
                        </div>
                        <p className="text-foreground break-all whitespace-pre-wrap">
                          {log.message}
                        </p>
                      </div>
                    </div>
                  );
                })}
              </div>
            )}
          </div>
        </CardContent>

        <div className="border-border/50 text-muted-foreground flex items-center justify-between border-t p-3 text-xs">
          <span>
            Showing {filteredLogs.length} of {logEntries.length} log entries
          </span>
          <Button
            variant="ghost"
            size="sm"
            onClick={() => {
              if (logContainerRef.current) {
                logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
              }
            }}
          >
            <ChevronDown className="mr-1 h-3 w-3" />
            Jump to bottom
          </Button>
        </div>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/providers.tsx">
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactNode, useState, useEffect } from 'react';
import { Toaster } from 'sonner';
import { SyncthingManager } from './syncthing-manager';
import { ErrorBoundary } from './error-boundary';
import DebugPanel from './debug-panel';
import { registerDefaultHealthChecks } from '@/lib/health-monitor';
import { autoRecovery, registerDefaultRecoveryStrategies } from '@/lib/auto-recovery';
import { logger } from '@/lib/logger';

export function Providers({ children }: { children: ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 1000,
            refetchOnWindowFocus: false,
            retry: 3,
            retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
          },
        },
      })
  );

  // Register health checks and auto-recovery on mount
  useEffect(() => {
    logger.info('Eigen application starting', { version: '1.0.0' });
    registerDefaultHealthChecks();
    registerDefaultRecoveryStrategies();

    // Start auto-recovery monitoring
    autoRecovery.startMonitoring(15000); // Check every 15 seconds

    return () => {
      logger.info('Eigen application unmounting');
      autoRecovery.stopMonitoring();
    };
  }, []);

  return (
    <ErrorBoundary>
      <QueryClientProvider client={queryClient}>
        <SyncthingManager>{children}</SyncthingManager>
        <Toaster position="bottom-right" theme="dark" richColors closeButton />
        <DebugPanel />
      </QueryClientProvider>
    </ErrorBoundary>
  );
}
</file>

<file path="src/components/settings-page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useAppStore } from '@/store';
import {
  useSyncthingInstallation,
  useDeviceId,
  useRestartSyncthing,
  useConfig,
  useUpdateOptions,
} from '@/hooks/useSyncthing';
import type { Options } from '@/hooks/useSyncthing';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Skeleton } from '@/components/ui/skeleton';
import {
  Sun,
  Moon,
  Monitor,
  Copy,
  Check,
  Info,
  Palette,
  Server,
  Bell,
  RefreshCw,
  Bug,
  RotateCw,
  Brain,
  Globe,
  Save,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { toast } from 'sonner';
import { LogViewer } from '@/components/log-viewer';
import { FileIndexer } from '@/components/file-indexer';

interface SettingCardProps {
  title: string;
  description: string;
  icon: React.ComponentType<{ className?: string }>;
  children: React.ReactNode;
}

function SettingCard({ title, description, icon: Icon, children }: SettingCardProps) {
  return (
    <Card className="border-slate-800 bg-slate-900/50 backdrop-blur-md">
      <CardHeader className="pb-3">
        <div className="flex items-start gap-3">
          <div className="flex h-10 w-10 items-center justify-center rounded-lg bg-indigo-500/20">
            <Icon className="h-5 w-5 text-indigo-400" />
          </div>
          <div>
            <CardTitle className="text-lg text-white">{title}</CardTitle>
            <CardDescription className="text-slate-400">{description}</CardDescription>
          </div>
        </div>
      </CardHeader>
      <CardContent>{children}</CardContent>
    </Card>
  );
}

function ThemeSelector() {
  const { theme, setTheme } = useAppStore();

  const themes = [
    { value: 'light', label: 'Light', icon: Sun },
    { value: 'dark', label: 'Dark', icon: Moon },
    { value: 'system', label: 'System', icon: Monitor },
  ] as const;

  return (
    <div className="flex gap-2">
      {themes.map(({ value, label, icon: Icon }) => (
        <Button
          key={value}
          variant={theme === value ? 'default' : 'outline-solid'}
          size="sm"
          onClick={() => setTheme(value)}
          className={cn(
            'flex-1 gap-2',
            theme === value
              ? 'bg-indigo-600 hover:bg-indigo-700'
              : 'border-slate-700 bg-slate-800/50 text-slate-300 hover:bg-slate-700'
          )}
        >
          <Icon className="h-4 w-4" />
          {label}
        </Button>
      ))}
    </div>
  );
}

function DeviceIdDisplay() {
  const { data: deviceId, isLoading, isError } = useDeviceId();
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    if (deviceId) {
      await navigator.clipboard.writeText(deviceId);
      setCopied(true);
      toast.success('Device ID copied to clipboard');
      setTimeout(() => setCopied(false), 2000);
    }
  };

  if (isLoading) {
    return <Skeleton className="h-10 w-full" />;
  }

  if (isError || !deviceId) {
    return (
      <div className="rounded-lg border border-red-500/30 bg-red-500/10 p-3 text-sm text-red-400">
        Unable to fetch device ID. Make sure Syncthing is running.
      </div>
    );
  }

  return (
    <div className="flex items-center gap-2">
      <code className="flex-1 truncate rounded-lg bg-slate-800 px-3 py-2 font-mono text-sm text-slate-300">
        {deviceId}
      </code>
      <Button
        variant="outline"
        size="sm"
        onClick={handleCopy}
        className="shrink-0 border-slate-700 bg-slate-800/50 hover:bg-slate-700"
      >
        {copied ? <Check className="h-4 w-4 text-emerald-400" /> : <Copy className="h-4 w-4" />}
      </Button>
    </div>
  );
}

function SyncthingInfo() {
  const { data: installation, isLoading } = useSyncthingInstallation();

  if (isLoading) {
    return (
      <div className="space-y-2">
        <Skeleton className="h-5 w-48" />
        <Skeleton className="h-5 w-64" />
      </div>
    );
  }

  if (!installation?.installed) {
    return (
      <div className="rounded-lg border border-red-500/30 bg-red-500/10 p-3">
        <p className="text-sm font-medium text-red-400">Syncthing not installed</p>
        <p className="mt-1 text-xs text-red-400/70">Install with: sudo apt install syncthing</p>
      </div>
    );
  }

  return (
    <div className="space-y-3">
      <div className="flex items-center justify-between">
        <span className="text-sm text-slate-400">Status</span>
        <Badge variant="success">Installed</Badge>
      </div>
      {installation.version && (
        <div className="flex items-center justify-between">
          <span className="text-sm text-slate-400">Version</span>
          <span className="font-mono text-sm text-white">
            {installation.version.split(' ')[1] || installation.version}
          </span>
        </div>
      )}
      {installation.path && (
        <div className="flex items-center justify-between">
          <span className="text-sm text-slate-400">Path</span>
          <code className="rounded bg-slate-800 px-2 py-0.5 font-mono text-xs text-slate-300">
            {installation.path}
          </code>
        </div>
      )}
    </div>
  );
}

function PollingSettings() {
  const { pollingInterval, setPollingInterval } = useAppStore();

  const intervals = [
    { value: 2000, label: '2 seconds' },
    { value: 5000, label: '5 seconds' },
    { value: 10000, label: '10 seconds' },
    { value: 30000, label: '30 seconds' },
  ];

  return (
    <div className="space-y-3">
      <label className="text-sm text-slate-400">Status polling interval</label>
      <div className="flex flex-wrap gap-2">
        {intervals.map(({ value, label }) => (
          <Button
            key={value}
            variant={pollingInterval === value ? 'default' : 'outline-solid'}
            size="sm"
            onClick={() => {
              setPollingInterval(value);
              toast.success(`Polling interval set to ${label}`);
            }}
            className={cn(
              pollingInterval === value
                ? 'bg-indigo-600 hover:bg-indigo-700'
                : 'border-slate-700 bg-slate-800/50 text-slate-300 hover:bg-slate-700'
            )}
          >
            {label}
          </Button>
        ))}
      </div>
      <p className="text-xs text-slate-500">How often to refresh connection and folder status</p>
    </div>
  );
}

function NotificationSettings() {
  const { nativeNotificationsEnabled, setNativeNotificationsEnabled } = useAppStore();

  return (
    <div className="space-y-3">
      <div className="flex items-center justify-between">
        <div>
          <p className="text-sm text-white">Native Notifications</p>
          <p className="text-xs text-slate-500">Show OS notifications for sync events</p>
        </div>
        <Button
          variant={nativeNotificationsEnabled ? 'default' : 'outline-solid'}
          size="sm"
          onClick={() => {
            setNativeNotificationsEnabled(!nativeNotificationsEnabled);
            toast.success(
              nativeNotificationsEnabled
                ? 'Native notifications disabled'
                : 'Native notifications enabled'
            );
          }}
          className={cn(
            nativeNotificationsEnabled
              ? 'bg-emerald-600 hover:bg-emerald-700'
              : 'border-slate-700 bg-slate-800/50 text-slate-300 hover:bg-slate-700'
          )}
        >
          {nativeNotificationsEnabled ? 'Enabled' : 'Disabled'}
        </Button>
      </div>
      <p className="text-xs text-slate-500">
        Receive desktop notifications when devices connect/disconnect, folders sync, or errors
        occur. In-app toasts are always shown.
      </p>
    </div>
  );
}

function AISettings() {
  const { aiEnabled, setAiEnabled } = useAppStore();

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <div>
          <p className="text-sm text-white">Enable AI Search</p>
          <p className="text-xs text-slate-500">Semantic file search using local AI model</p>
        </div>
        <Button
          variant={aiEnabled ? 'default' : 'outline-solid'}
          size="sm"
          onClick={() => {
            setAiEnabled(!aiEnabled);
            toast.success(
              aiEnabled ? 'AI search disabled' : 'AI search enabled - model will load on next use'
            );
          }}
          className={cn(
            aiEnabled
              ? 'bg-emerald-600 hover:bg-emerald-700'
              : 'border-slate-700 bg-slate-800/50 text-slate-300 hover:bg-slate-700'
          )}
        >
          {aiEnabled ? 'Enabled' : 'Disabled'}
        </Button>
      </div>
      <p className="text-xs text-slate-500">
        AI search uses a local embedding model (all-MiniLM-L6-v2) to enable semantic file search.
        The model runs entirely on your device. Disabling saves memory and CPU resources.
      </p>
      {aiEnabled && (
        <div className="border-t border-slate-800 pt-2">
          <FileIndexer />
        </div>
      )}
    </div>
  );
}

function NetworkSettings() {
  const { data: config, isLoading } = useConfig();
  const updateOptions = useUpdateOptions();

  const [localOptions, setLocalOptions] = useState<Partial<Options>>({});
  const [hasChanges, setHasChanges] = useState(false);

  // Initialize local state from config
  useEffect(() => {
    if (config?.options) {
      setLocalOptions({
        globalAnnounceEnabled: config.options.globalAnnounceEnabled,
        localAnnounceEnabled: config.options.localAnnounceEnabled,
        relaysEnabled: config.options.relaysEnabled,
        maxSendKbps: config.options.maxSendKbps,
        maxRecvKbps: config.options.maxRecvKbps,
        listenAddresses: config.options.listenAddresses,
      });
      setHasChanges(false);
    }
  }, [config?.options]);

  const updateField = <K extends keyof Options>(key: K, value: Options[K]) => {
    setLocalOptions((prev) => ({ ...prev, [key]: value }));
    setHasChanges(true);
  };

  const handleSave = async () => {
    try {
      await updateOptions.mutateAsync(localOptions);
      toast.success('Network settings saved');
      setHasChanges(false);
    } catch (error) {
      toast.error('Failed to save network settings');
    }
  };

  if (isLoading) {
    return (
      <div className="space-y-3">
        <Skeleton className="h-8 w-full" />
        <Skeleton className="h-8 w-full" />
        <Skeleton className="h-8 w-full" />
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* Discovery Toggles */}
      <div className="flex items-center justify-between">
        <div>
          <p className="text-sm text-white">Global Discovery</p>
          <p className="text-xs text-slate-500">Find devices over the internet</p>
        </div>
        <Button
          variant={localOptions.globalAnnounceEnabled ? 'default' : 'outline-solid'}
          size="sm"
          onClick={() => updateField('globalAnnounceEnabled', !localOptions.globalAnnounceEnabled)}
          className={cn(
            localOptions.globalAnnounceEnabled
              ? 'bg-emerald-600 hover:bg-emerald-700'
              : 'border-slate-700 bg-slate-800/50 text-slate-300 hover:bg-slate-700'
          )}
        >
          {localOptions.globalAnnounceEnabled ? 'On' : 'Off'}
        </Button>
      </div>

      <div className="flex items-center justify-between">
        <div>
          <p className="text-sm text-white">Local Discovery</p>
          <p className="text-xs text-slate-500">Find devices on local network</p>
        </div>
        <Button
          variant={localOptions.localAnnounceEnabled ? 'default' : 'outline-solid'}
          size="sm"
          onClick={() => updateField('localAnnounceEnabled', !localOptions.localAnnounceEnabled)}
          className={cn(
            localOptions.localAnnounceEnabled
              ? 'bg-emerald-600 hover:bg-emerald-700'
              : 'border-slate-700 bg-slate-800/50 text-slate-300 hover:bg-slate-700'
          )}
        >
          {localOptions.localAnnounceEnabled ? 'On' : 'Off'}
        </Button>
      </div>

      <div className="flex items-center justify-between">
        <div>
          <p className="text-sm text-white">Relaying</p>
          <p className="text-xs text-slate-500">Use relays when direct connection fails</p>
        </div>
        <Button
          variant={localOptions.relaysEnabled ? 'default' : 'outline-solid'}
          size="sm"
          onClick={() => updateField('relaysEnabled', !localOptions.relaysEnabled)}
          className={cn(
            localOptions.relaysEnabled
              ? 'bg-emerald-600 hover:bg-emerald-700'
              : 'border-slate-700 bg-slate-800/50 text-slate-300 hover:bg-slate-700'
          )}
        >
          {localOptions.relaysEnabled ? 'On' : 'Off'}
        </Button>
      </div>

      {/* Bandwidth Limits */}
      <div className="border-t border-slate-800 pt-2">
        <p className="mb-2 text-sm text-white">Bandwidth Limits</p>
        <div className="grid grid-cols-2 gap-3">
          <div>
            <label className="text-xs text-slate-500">Upload (KB/s)</label>
            <input
              type="number"
              value={localOptions.maxSendKbps ?? 0}
              onChange={(e) => updateField('maxSendKbps', parseInt(e.target.value) || 0)}
              className="mt-1 w-full rounded-lg border border-slate-700 bg-slate-800 px-3 py-2 text-sm text-white focus:border-indigo-500 focus:outline-hidden"
              placeholder="0 = unlimited"
              min={0}
            />
          </div>
          <div>
            <label className="text-xs text-slate-500">Download (KB/s)</label>
            <input
              type="number"
              value={localOptions.maxRecvKbps ?? 0}
              onChange={(e) => updateField('maxRecvKbps', parseInt(e.target.value) || 0)}
              className="mt-1 w-full rounded-lg border border-slate-700 bg-slate-800 px-3 py-2 text-sm text-white focus:border-indigo-500 focus:outline-hidden"
              placeholder="0 = unlimited"
              min={0}
            />
          </div>
        </div>
        <p className="mt-1 text-xs text-slate-500">0 = unlimited bandwidth</p>
      </div>

      {/* Listen Addresses */}
      <div className="border-t border-slate-800 pt-2">
        <label className="text-sm text-white">Listen Addresses</label>
        <input
          type="text"
          value={localOptions.listenAddresses?.join(', ') ?? ''}
          onChange={(e) => {
            const addresses = e.target.value
              .split(',')
              .map((s) => s.trim())
              .filter(Boolean);
            updateField('listenAddresses', addresses.length > 0 ? addresses : ['default']);
          }}
          className="mt-1 w-full rounded-lg border border-slate-700 bg-slate-800 px-3 py-2 text-sm text-white focus:border-indigo-500 focus:outline-hidden"
          placeholder="default, tcp://0.0.0.0:22000"
        />
        <p className="mt-1 text-xs text-slate-500">Comma-separated list of listen addresses</p>
      </div>

      {/* Save Button */}
      {hasChanges && (
        <Button
          variant="default"
          size="sm"
          onClick={handleSave}
          disabled={updateOptions.isPending}
          className="w-full bg-indigo-600 hover:bg-indigo-700"
        >
          {updateOptions.isPending ? (
            <>
              <RefreshCw className="mr-2 h-4 w-4 animate-spin" />
              Saving...
            </>
          ) : (
            <>
              <Save className="mr-2 h-4 w-4" />
              Save Changes
            </>
          )}
        </Button>
      )}
    </div>
  );
}

export function SettingsPage() {
  const [logViewerOpen, setLogViewerOpen] = useState(false);
  const restartSyncthing = useRestartSyncthing();

  const handleRestart = async () => {
    try {
      await restartSyncthing.mutateAsync();
      toast.success('Syncthing is restarting...');
    } catch (error) {
      toast.error('Failed to restart Syncthing');
    }
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold text-white">Settings</h2>
      </div>

      <div className="grid gap-6 md:grid-cols-2">
        {/* Appearance */}
        <SettingCard title="Appearance" description="Customize the look and feel" icon={Palette}>
          <ThemeSelector />
        </SettingCard>

        {/* Syncthing Info */}
        <SettingCard title="Syncthing" description="Backend service information" icon={Server}>
          <SyncthingInfo />
        </SettingCard>

        {/* Device ID */}
        <SettingCard
          title="Device ID"
          description="Share this ID to connect with other devices"
          icon={Info}
        >
          <DeviceIdDisplay />
        </SettingCard>

        {/* Polling Settings */}
        <SettingCard
          title="Refresh Rate"
          description="Configure data polling frequency"
          icon={RefreshCw}
        >
          <PollingSettings />
        </SettingCard>

        {/* Notification Settings */}
        <SettingCard
          title="Notifications"
          description="Configure how you receive alerts"
          icon={Bell}
        >
          <NotificationSettings />
        </SettingCard>

        {/* AI File Index */}
        <SettingCard
          title="AI Search"
          description="Semantic file search powered by AI"
          icon={Brain}
        >
          <AISettings />
        </SettingCard>

        {/* Network Settings */}
        <SettingCard
          title="Network"
          description="Discovery, relays, and bandwidth limits"
          icon={Globe}
        >
          <NetworkSettings />
        </SettingCard>

        {/* System Logs */}
        <SettingCard title="System Logs" description="View Syncthing logs for debugging" icon={Bug}>
          <div className="space-y-3">
            <p className="text-sm text-slate-400">
              View real-time logs from Syncthing for troubleshooting connection issues and errors.
            </p>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setLogViewerOpen(true)}
              className="w-full border-slate-700 bg-slate-800/50 hover:bg-slate-700"
            >
              <Bug className="mr-2 h-4 w-4" />
              Open Log Viewer
            </Button>
          </div>
        </SettingCard>

        {/* System Actions */}
        <SettingCard title="System Actions" description="Control Syncthing service" icon={RotateCw}>
          <div className="space-y-3">
            <p className="text-sm text-slate-400">
              Restart Syncthing to apply configuration changes that require a restart.
            </p>
            <Button
              variant="outline"
              size="sm"
              onClick={handleRestart}
              disabled={restartSyncthing.isPending}
              className="w-full border-orange-500/30 bg-orange-500/10 text-orange-400 hover:bg-orange-500/20"
            >
              {restartSyncthing.isPending ? (
                <>
                  <RefreshCw className="mr-2 h-4 w-4 animate-spin" />
                  Restarting...
                </>
              ) : (
                <>
                  <RotateCw className="mr-2 h-4 w-4" />
                  Restart Syncthing
                </>
              )}
            </Button>
          </div>
        </SettingCard>
      </div>

      {/* About Section */}
      <Card className="border-slate-800 bg-slate-900/50 backdrop-blur-md">
        <CardHeader>
          <CardTitle className="text-white">About Eigen</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex items-center justify-between">
            <div>
              <p className="text-slate-300">A modern Syncthing manager built with Tauri</p>
              <p className="mt-1 text-sm text-slate-500">
                Version 0.1.0  Built with Next.js + Rust
              </p>
            </div>
            <Button
              variant="outline"
              size="sm"
              className="border-slate-700 bg-slate-800/50 hover:bg-slate-700"
              onClick={() => window.open('https://github.com/syncthing/syncthing', '_blank')}
            >
              Syncthing Docs
            </Button>
          </div>
        </CardContent>
      </Card>

      {/* Log Viewer Modal */}
      <LogViewer open={logViewerOpen} onOpenChange={setLogViewerOpen} />
    </div>
  );
}
</file>

<file path="src/components/share-folder-dialog.tsx">
'use client';

import { useState } from 'react';
import { useConfig, useShareFolder } from '@/hooks/useSyncthing';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { X, Laptop, Check } from 'lucide-react';
import { toast } from 'sonner';
import { cn } from '@/lib/utils';

interface ShareFolderDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  folderId: string;
  folderLabel?: string;
}

export function ShareFolderDialog({
  open,
  onOpenChange,
  folderId,
  folderLabel,
}: ShareFolderDialogProps) {
  const [selectedDevice, setSelectedDevice] = useState<string | null>(null);
  const { data: config } = useConfig();
  const shareFolder = useShareFolder();

  const handleShare = async () => {
    if (!selectedDevice) return;

    try {
      await shareFolder.mutateAsync({
        folderId,
        deviceId: selectedDevice,
      });
      toast.success(`Folder shared with device`);
      onOpenChange(false);
      setSelectedDevice(null);
    } catch (error) {
      console.error('Share folder error:', error);
      toast.error(
        `Failed to share folder: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  };

  if (!open) return null;

  // Filter out devices that already have this folder
  const availableDevices = config?.devices?.filter((device) => {
    // Find the current folder config
    const currentFolder = config.folders?.find((f) => f.id === folderId);
    // Check if this device is already in the folder's device list
    // Note: The backend returns 'devices' as an array of objects with 'deviceID'
    const isAlreadyShared = (currentFolder as any)?.devices?.some(
      (d: any) => d.deviceID === device.deviceID
    );
    return !isAlreadyShared;
  });

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-xs">
      <Card className="w-full max-w-md border-slate-700 bg-slate-900 shadow-2xl">
        <CardHeader className="relative">
          <Button
            variant="ghost"
            size="icon"
            onClick={() => onOpenChange(false)}
            className="absolute top-4 right-4 text-slate-400 hover:text-white"
          >
            <X className="h-4 w-4" />
          </Button>
          <CardTitle className="text-xl text-white">Share Folder</CardTitle>
          <CardDescription className="text-slate-400">
            Select a device to sync "{folderLabel || folderId}" with.
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="space-y-2">
            {availableDevices?.length === 0 ? (
              <div className="py-8 text-center text-slate-500">
                No new devices available to share with.
              </div>
            ) : (
              availableDevices?.map((device) => (
                <div
                  key={device.deviceID}
                  onClick={() => setSelectedDevice(device.deviceID)}
                  className={cn(
                    'flex cursor-pointer items-center justify-between rounded-lg border p-3 transition-all',
                    selectedDevice === device.deviceID
                      ? 'border-indigo-500 bg-indigo-500/10'
                      : 'border-slate-700 bg-slate-800 hover:border-slate-600'
                  )}
                >
                  <div className="flex items-center gap-3">
                    <div className="flex h-8 w-8 items-center justify-center rounded bg-slate-700">
                      <Laptop className="h-4 w-4 text-slate-300" />
                    </div>
                    <div className="flex flex-col">
                      <span className="text-sm font-medium text-white">
                        {device.name || 'Unnamed Device'}
                      </span>
                      <span className="font-mono text-[10px] text-slate-500">
                        {device.deviceID.slice(0, 12)}
                        ...
                      </span>
                    </div>
                  </div>
                  {selectedDevice === device.deviceID && (
                    <Check className="h-4 w-4 text-indigo-400" />
                  )}
                </div>
              ))
            )}
          </div>

          <div className="flex justify-end gap-3 pt-2">
            <Button
              variant="outline"
              onClick={() => onOpenChange(false)}
              className="border-slate-700 bg-transparent hover:bg-slate-800"
            >
              Cancel
            </Button>
            <Button
              onClick={handleShare}
              disabled={!selectedDevice || shareFolder.isPending}
              className="bg-indigo-600 hover:bg-indigo-700"
            >
              {shareFolder.isPending ? 'Sharing...' : 'Share'}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/sidebar.tsx">
'use client';

import { useEffect } from 'react';
import { useAppStore } from '@/store';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import {
  LayoutDashboard,
  Folder,
  Laptop,
  Settings,
  ChevronLeft,
  ChevronRight,
  ScrollText,
} from 'lucide-react';
import Image from 'next/image';

const navItems = [
  { id: 'dashboard' as const, label: 'Dashboard', icon: LayoutDashboard },
  { id: 'folders' as const, label: 'Folders', icon: Folder },
  { id: 'devices' as const, label: 'Devices', icon: Laptop },
  { id: 'logs' as const, label: 'Logs', icon: ScrollText },
  { id: 'settings' as const, label: 'Settings', icon: Settings },
];

export function Sidebar() {
  const { sidebarOpen, toggleSidebar, activeTab, setActiveTab } = useAppStore();

  // Listen for navigation events from toast notifications
  useEffect(() => {
    const handleNavigate = (event: CustomEvent<string>) => {
      const tab = event.detail as typeof activeTab;
      if (['dashboard', 'folders', 'devices', 'settings', 'logs'].includes(tab)) {
        setActiveTab(tab);
      }
    };

    window.addEventListener('navigate-to-tab', handleNavigate as EventListener);
    return () => {
      window.removeEventListener('navigate-to-tab', handleNavigate as EventListener);
    };
  }, [setActiveTab]);

  return (
    <aside
      className={cn(
        'flex h-full flex-col border-r border-slate-800 bg-slate-950/50 backdrop-blur-xl transition-all duration-300',
        sidebarOpen ? 'w-64' : 'w-16'
      )}
    >
      {/* Logo */}
      <div className="flex h-16 items-center gap-3 border-b border-slate-800 px-4">
        <Image src="/app_icon.png" alt="Eigen" width={32} height={32} className="rounded-lg" />
        {sidebarOpen && <span className="text-lg font-bold text-white">Eigen</span>}
      </div>

      {/* Navigation */}
      <nav className="flex-1 space-y-1 p-3">
        {navItems.map((item) => (
          <Button
            key={item.id}
            variant="ghost"
            className={cn(
              'w-full justify-start gap-3 text-slate-400 hover:bg-slate-800/50 hover:text-white',
              activeTab === item.id && 'bg-slate-800/50 text-white',
              !sidebarOpen && 'justify-center px-2'
            )}
            onClick={() => setActiveTab(item.id)}
          >
            <item.icon className="h-5 w-5 shrink-0" />
            {sidebarOpen && <span>{item.label}</span>}
          </Button>
        ))}
      </nav>

      {/* Toggle Button */}
      <div className="border-t border-slate-800 p-3">
        <Button
          variant="ghost"
          size="sm"
          className="w-full justify-center text-slate-400 hover:bg-slate-800/50 hover:text-white"
          onClick={toggleSidebar}
        >
          {sidebarOpen ? <ChevronLeft className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />}
        </Button>
      </div>
    </aside>
  );
}
</file>

<file path="src/components/syncthing-manager.tsx">
'use client';

import { useEffect, useRef, useCallback } from 'react';
import { invoke } from '@tauri-apps/api/core';
import {
  useStartSyncthing,
  useSystemStatus,
  useSyncthingInstallation,
  useSyncthingEvents,
  SyncthingEvent,
} from '@/hooks/useSyncthing';
import { useNativeNotifications } from '@/hooks/useNotifications';
import { toast } from 'sonner';

/**
 * Updates the system tray tooltip with current sync status
 */
async function updateTrayStatus(status: string, details: string) {
  try {
    const tooltip = `Eigen - ${status}\n${details}`;
    await invoke('update_tray_status', {
      status,
      tooltip,
    });
  } catch (error) {
    // Silently fail - tray might not be available
    console.debug('Could not update tray status:', error);
  }
}

/**
 * Component that manages Syncthing lifecycle.
 * Checks installation and auto-starts Syncthing when the app loads.
 * Also handles device discovery notifications via the Event API.
 */
// Cooldown period for notifications (in milliseconds)
const DEVICE_NOTIFICATION_COOLDOWN = 60000; // 1 minute
const FOLDER_NOTIFICATION_COOLDOWN = 30000; // 30 seconds - prevent spam for folder sync/error events

export function SyncthingManager({ children }: { children: React.ReactNode }) {
  const { data: installation, isLoading: checkingInstallation } = useSyncthingInstallation();
  const startSyncthing = useStartSyncthing();
  const { data: status, isError } = useSystemStatus();
  const hasAttemptedStart = useRef(false);
  const installationToastShown = useRef(false);
  const connectedToastShown = useRef(false);

  // Track last notification time per device to prevent spam
  const deviceNotificationTimestamps = useRef<Map<string, number>>(new Map());
  // Track last notification time per folder to prevent spam
  const folderNotificationTimestamps = useRef<Map<string, number>>(new Map());

  // Native notifications hook
  const { notifyDeviceEvent, notifyFolderEvent } = useNativeNotifications();

  /**
   * Check if we should show a notification for a device event
   * Returns true if cooldown has passed, false if we should skip
   */
  const shouldNotifyDevice = useCallback((deviceId: string, eventType: string): boolean => {
    const key = `${deviceId}-${eventType}`;
    const now = Date.now();
    const lastNotified = deviceNotificationTimestamps.current.get(key);

    if (lastNotified && now - lastNotified < DEVICE_NOTIFICATION_COOLDOWN) {
      return false;
    }

    deviceNotificationTimestamps.current.set(key, now);
    return true;
  }, []);

  /**
   * Check if we should show a notification for a folder event
   * Returns true if cooldown has passed, false if we should skip
   */
  const shouldNotifyFolder = useCallback((folderId: string, eventType: string): boolean => {
    const key = `${folderId}-${eventType}`;
    const now = Date.now();
    const lastNotified = folderNotificationTimestamps.current.get(key);

    if (lastNotified && now - lastNotified < FOLDER_NOTIFICATION_COOLDOWN) {
      return false;
    }

    folderNotificationTimestamps.current.set(key, now);
    return true;
  }, []);

  // Handle incoming Syncthing events
  const handleEvent = useCallback(
    (event: SyncthingEvent) => {
      switch (event.type) {
        case 'DeviceRejected': {
          // A device tried to connect but isn't in our config
          const deviceName = event.data?.name || event.data?.device?.slice(0, 7) || 'Unknown';
          toast.warning('New Device Wants to Connect', {
            description: `Device ${deviceName} is trying to connect.`,
            duration: 15000,
            action: {
              label: 'View Devices',
              onClick: () => {
                // Navigate to devices tab
                window.dispatchEvent(
                  new CustomEvent('navigate-to-tab', {
                    detail: 'devices',
                  })
                );
              },
            },
          });
          // Also send native notification (shown when window is hidden)
          notifyDeviceEvent('rejected', deviceName);
          break;
        }

        case 'FolderRejected': {
          // A folder was shared to us but isn't in our config
          const folderName = event.data?.folderLabel || event.data?.folder || 'Unknown';
          const fromDevice = event.data?.device?.slice(0, 7) || 'A device';
          toast.info('Folder Shared With You', {
            description: `Device ${fromDevice} wants to share folder "${folderName}".`,
            duration: 15000,
            action: {
              label: 'View Folders',
              onClick: () => {
                window.dispatchEvent(
                  new CustomEvent('navigate-to-tab', {
                    detail: 'folders',
                  })
                );
              },
            },
          });
          // Native notification
          notifyFolderEvent('shared', folderName, fromDevice);
          break;
        }

        case 'DeviceConnected': {
          const deviceId = event.data?.id || 'unknown';
          const deviceName = event.data?.deviceName || event.data?.id?.slice(0, 7) || 'Device';

          // Rate limit notifications per device
          if (!shouldNotifyDevice(deviceId, 'connected')) {
            break;
          }

          toast.success('Device Connected', {
            description: `${deviceName} is now online.`,
            duration: 5000,
          });
          // Native notification
          notifyDeviceEvent('connected', deviceName);
          break;
        }

        case 'DeviceDisconnected': {
          const deviceId = event.data?.id || 'unknown';
          const deviceName = event.data?.deviceName || event.data?.id?.slice(0, 7) || 'Device';

          // Rate limit notifications per device to prevent spam
          if (!shouldNotifyDevice(deviceId, 'disconnected')) {
            break;
          }

          toast.info('Device Disconnected', {
            description: `${deviceName} went offline.`,
            duration: 5000,
          });
          // Native notification
          notifyDeviceEvent('disconnected', deviceName);
          break;
        }

        case 'FolderCompletion':
          // Only show when folder reaches 100% and not recently notified
          if (event.data?.completion === 100) {
            const folderId = event.data?.folder || 'unknown';
            const folderName = event.data?.folder || 'Folder';

            // Rate limit notifications per folder to prevent spam
            if (!shouldNotifyFolder(folderId, 'completion')) {
              break;
            }

            toast.success('Sync Complete', {
              description: `Folder "${folderName}" is now in sync.`,
              duration: 3000,
            });
            // Native notification for sync complete
            notifyFolderEvent('synced', folderName);
          }
          break;

        case 'FolderErrors':
          if (event.data?.errors?.length > 0) {
            const folderId = event.data?.folder || 'unknown';
            const folderName = event.data?.folder || 'Folder';
            const errorCount = event.data.errors.length;

            // Rate limit error notifications per folder to prevent spam
            if (!shouldNotifyFolder(folderId, 'errors')) {
              break;
            }

            toast.error('Sync Errors', {
              description: `Folder "${folderName}" has ${errorCount} error(s).`,
              duration: 10000,
            });
            // Native notification for errors
            notifyFolderEvent('error', folderName, `${errorCount} error(s)`);
          }
          break;
      }
    },
    [notifyDeviceEvent, notifyFolderEvent, shouldNotifyDevice, shouldNotifyFolder]
  );

  // Subscribe to Syncthing events when connected
  const { isPolling } = useSyncthingEvents({
    onEvent: handleEvent,
    enabled: !!status?.myID,
  });

  // Check installation status
  useEffect(() => {
    if (checkingInstallation || installationToastShown.current) return;

    if (installation && !installation.installed) {
      installationToastShown.current = true;
      toast.error('Syncthing not installed', {
        description: 'Please install Syncthing to use this app. Run: sudo apt install syncthing',
        duration: 15000,
        action: {
          label: 'Learn More',
          onClick: () => window.open('https://syncthing.net/downloads/', '_blank'),
        },
      });
    } else if (installation?.installed && installation.version) {
      console.log('Syncthing found:', installation.version, 'at', installation.path);
    }
  }, [installation, checkingInstallation]);

  // Auto-start Syncthing if installed but not responding
  useEffect(() => {
    if (hasAttemptedStart.current) return;
    if (!installation?.installed) return;

    // If we get an error (Syncthing not responding), try to start it
    if (isError && !startSyncthing.isPending) {
      hasAttemptedStart.current = true;

      console.log('Syncthing not responding, attempting to start...');

      startSyncthing.mutate(undefined, {
        onSuccess: (message) => {
          console.log('Syncthing start result:', message);
          toast.success('Starting Syncthing...', {
            description: 'Please wait while Syncthing initializes.',
          });
        },
        onError: (err) => {
          console.error('Failed to start Syncthing:', err);
          toast.error('Failed to start Syncthing', {
            description: err instanceof Error ? err.message : 'Unknown error',
            duration: 10000,
          });
        },
      });
    }
  }, [isError, startSyncthing, installation?.installed]);

  // Show success toast when Syncthing connects
  useEffect(() => {
    if (status?.myID && !connectedToastShown.current) {
      connectedToastShown.current = true;
      toast.success('Connected to Syncthing', {
        description: `Device ID: ${status.myID.slice(0, 7)}...`,
      });
    }
  }, [status?.myID]);

  // Update tray status based on connection and sync state
  useEffect(() => {
    if (!status?.myID) {
      updateTrayStatus('Disconnected', 'Syncthing is not running');
      return;
    }

    // Connected to Syncthing
    const uptime = status.uptime ? Math.floor(status.uptime / 60) : 0;
    const uptimeStr = uptime > 60 ? `${Math.floor(uptime / 60)}h ${uptime % 60}m` : `${uptime}m`;

    if (isPolling) {
      updateTrayStatus('Connected', `Uptime: ${uptimeStr}  Listening for events`);
    } else {
      updateTrayStatus('Connected', `Uptime: ${uptimeStr}`);
    }
  }, [status?.myID, status?.uptime, isPolling]);

  return <>{children}</>;
}
</file>

<file path="src/hooks/useSyncthing.ts">
'use client';

import { invoke } from '@tauri-apps/api/core';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { z } from 'zod';
import { useEffect, useRef, useCallback, useState } from 'react';
import { useAppStore } from '@/store';

// ============================================================================
// Zod Schemas for Type Safety
// ============================================================================

export const SyncthingInfoSchema = z.object({
    installed: z.boolean(),
    version: z.string().nullable().optional(),
    path: z.string().nullable().optional(),
});

export type SyncthingInfo = z.infer<typeof SyncthingInfoSchema>;

export const SystemStatusSchema = z
    .object({
        myID: z.string().optional(),
        uptime: z.number().optional(),
        allPeersConnected: z.boolean().optional(),
        goroutines: z.number().optional(),
        sys: z.number().optional(),
        startTime: z.string().optional(),
    })
    .passthrough();

export const ConnectionInfoSchema = z
    .object({
        connected: z.boolean().optional(),
        paused: z.boolean().optional(),
        address: z.string().optional(),
        type: z.string().optional(),
        clientVersion: z.string().optional(),
        crypto: z.string().optional(),
    })
    .passthrough();

export const ConnectionsSchema = z
    .object({
        total: z
            .object({
                at: z.string().optional(),
                inBytesTotal: z.number().optional(),
                outBytesTotal: z.number().optional(),
            })
            .optional(),
        connections: z.record(z.string(), ConnectionInfoSchema).optional(),
    })
    .passthrough();

// Versioning schema
export const VersioningConfigSchema = z
    .object({
        type: z.string().optional(),
        params: z.record(z.string(), z.string()).optional(),
        cleanupIntervalS: z.number().optional(),
        fsPath: z.string().optional(),
        fsType: z.string().optional(),
    })
    .passthrough();

// Folder device reference schema
export const FolderDeviceSchema = z
    .object({
        deviceID: z.string(),
        introducedBy: z.string().optional(),
        encryptionPassword: z.string().optional(),
    })
    .passthrough();

export const FolderConfigSchema = z
    .object({
        id: z.string(),
        label: z.string().optional(),
        path: z.string().optional(),
        paused: z.boolean().optional(),
        type: z.string().optional(),
        rescanIntervalS: z.number().optional(),
        fsWatcherEnabled: z.boolean().optional(),
        fsWatcherDelayS: z.number().optional(),
        ignorePerms: z.boolean().optional(),
        versioning: VersioningConfigSchema.optional(),
        devices: z.array(FolderDeviceSchema).optional(),
    })
    .passthrough();

export const DeviceConfigSchema = z
    .object({
        deviceID: z.string(),
        name: z.string().optional(),
        paused: z.boolean().optional(),
        addresses: z.array(z.string()).optional(),
        compression: z.string().optional(),
        introducer: z.boolean().optional(),
        autoAcceptFolders: z.boolean().optional(),
        maxSendKbps: z.number().optional(),
        maxRecvKbps: z.number().optional(),
    })
    .passthrough();

// Global options schema
export const OptionsSchema = z
    .object({
        listenAddresses: z.array(z.string()).optional(),
        globalAnnounceServers: z.array(z.string()).optional(),
        globalAnnounceEnabled: z.boolean().optional(),
        localAnnounceEnabled: z.boolean().optional(),
        localAnnouncePort: z.number().optional(),
        localAnnounceMCAddr: z.string().optional(),
        maxSendKbps: z.number().optional(),
        maxRecvKbps: z.number().optional(),
        reconnectionIntervalS: z.number().optional(),
        relaysEnabled: z.boolean().optional(),
        relayReconnectIntervalM: z.number().optional(),
        startBrowser: z.boolean().optional(),
        natEnabled: z.boolean().optional(),
        natLeaseMinutes: z.number().optional(),
        natRenewalMinutes: z.number().optional(),
        natTimeoutSeconds: z.number().optional(),
        urAccepted: z.number().optional(),
        urSeen: z.number().optional(),
        urUniqueId: z.string().optional(),
        urURL: z.string().optional(),
        urPostInsecurely: z.boolean().optional(),
        urInitialDelayS: z.number().optional(),
        autoUpgradeIntervalH: z.number().optional(),
        upgradeToPreReleases: z.boolean().optional(),
        keepTemporariesH: z.number().optional(),
        cacheIgnoredFiles: z.boolean().optional(),
        progressUpdateIntervalS: z.number().optional(),
        limitBandwidthInLan: z.boolean().optional(),
        minHomeDiskFree: z
            .object({
                value: z.number(),
                unit: z.string(),
            })
            .optional(),
        releasesURL: z.string().optional(),
        alwaysLocalNets: z.array(z.string()).optional(),
        overwriteRemoteDeviceNamesOnConnect: z.boolean().optional(),
        tempIndexMinBlocks: z.number().optional(),
        unackedNotificationIDs: z.array(z.string()).optional(),
        trafficClass: z.number().optional(),
        setLowPriority: z.boolean().optional(),
        maxFolderConcurrency: z.number().optional(),
        crashReportingURL: z.string().optional(),
        crashReportingEnabled: z.boolean().optional(),
        stunKeepaliveStartS: z.number().optional(),
        stunKeepaliveMinS: z.number().optional(),
        stunServers: z.array(z.string()).optional(),
        databaseTuning: z.string().optional(),
        maxConcurrentIncomingRequestKiB: z.number().optional(),
        announceLANAddresses: z.boolean().optional(),
        sendFullIndexOnUpgrade: z.boolean().optional(),
        featureFlags: z.array(z.string()).optional(),
        connectionLimitEnough: z.number().optional(),
        connectionLimitMax: z.number().optional(),
        insecureAllowOldTLSVersions: z.boolean().optional(),
    })
    .passthrough();

export const ConfigSchema = z
    .object({
        folders: z.array(FolderConfigSchema).optional(),
        devices: z.array(DeviceConfigSchema).optional(),
        options: OptionsSchema.optional(),
    })
    .passthrough();

export const FolderStatusSchema = z
    .object({
        globalFiles: z.number().optional(),
        globalBytes: z.number().optional(),
        localFiles: z.number().optional(),
        localBytes: z.number().optional(),
        needFiles: z.number().optional(),
        needBytes: z.number().optional(),
        state: z.string().optional(),
        stateChanged: z.string().optional(),
    })
    .passthrough();

// Ignore patterns schema
export const IgnorePatternsSchema = z
    .object({
        ignore: z.array(z.string()).optional(),
        expanded: z.array(z.string()).optional(),
    })
    .passthrough();

// Log entry schema
export const LogEntrySchema = z
    .object({
        when: z.string(),
        message: z.string(),
        level: z.number().optional(),
    })
    .passthrough();

export const SystemLogsSchema = z
    .object({
        messages: z.array(LogEntrySchema).optional(),
    })
    .passthrough();

// Event schema
export const SyncthingEventSchema = z
    .object({
        id: z.number(),
        globalID: z.number().optional(),
        time: z.string(),
        type: z.string(),
        data: z.any(),
    })
    .passthrough();

// ============================================================================
// Types
// ============================================================================

export type SystemStatus = z.infer<typeof SystemStatusSchema>;
export type Connections = z.infer<typeof ConnectionsSchema>;
export type ConnectionInfo = z.infer<typeof ConnectionInfoSchema>;
export type Config = z.infer<typeof ConfigSchema>;
export type Options = z.infer<typeof OptionsSchema>;
export type FolderConfig = z.infer<typeof FolderConfigSchema>;
export type DeviceConfig = z.infer<typeof DeviceConfigSchema>;
export type FolderStatus = z.infer<typeof FolderStatusSchema>;
export type VersioningConfig = z.infer<typeof VersioningConfigSchema>;
export type IgnorePatterns = z.infer<typeof IgnorePatternsSchema>;
export type SystemLogs = z.infer<typeof SystemLogsSchema>;
export type LogEntry = z.infer<typeof LogEntrySchema>;
export type SyncthingEvent = z.infer<typeof SyncthingEventSchema>;

// Advanced folder options
export interface AdvancedFolderOptions {
    folderId: string;
    folderLabel: string;
    folderPath: string;
    versioningType?: 'simple' | 'staggered' | 'trashcan' | 'external' | '';
    versioningParams?: Record<string, string>;
    rescanIntervalS?: number;
    fsWatcherEnabled?: boolean;
    fsWatcherDelayS?: number;
    ignorePerms?: boolean;
}

// Advanced device options
export interface AdvancedDeviceOptions {
    deviceId: string;
    name: string;
    addresses?: string[];
    compression?: 'metadata' | 'always' | 'never';
    introducer?: boolean;
    autoAcceptFolders?: boolean;
    maxSendKbps?: number;
    maxRecvKbps?: number;
}

// ============================================================================
// Query Hooks
// ============================================================================

/**
 * Check if Syncthing is installed on the system
 */
export function useSyncthingInstallation() {
    return useQuery({
        queryKey: ['syncthingInstallation'],
        queryFn: async () => {
            const data = await invoke('check_syncthing_installation');
            return SyncthingInfoSchema.parse(data);
        },
        staleTime: Infinity, // Installation status doesn't change often
        retry: 1,
    });
}

/**
 * Get Syncthing system status with polling
 */
export function useSystemStatus() {
    const pollingInterval = useAppStore((state) => state.pollingInterval);

    return useQuery({
        queryKey: ['systemStatus'],
        queryFn: async () => {
            const data = await invoke('get_system_status');
            return SystemStatusSchema.parse(data);
        },
        refetchInterval: pollingInterval,
        retry: 3,
        retryDelay: 1000,
        refetchOnWindowFocus: false,
        staleTime: pollingInterval - 1000,
    });
}

/**
 * Get Syncthing connections info with polling
 */
export function useConnections() {
    const pollingInterval = useAppStore((state) => state.pollingInterval);

    return useQuery({
        queryKey: ['connections'],
        queryFn: async () => {
            const data = await invoke('get_connections');
            return ConnectionsSchema.parse(data);
        },
        refetchInterval: pollingInterval,
        retry: 3,
        retryDelay: 1000,
        refetchOnWindowFocus: false,
        staleTime: pollingInterval - 1000,
    });
}

/**
 * Get Syncthing configuration
 */
export function useConfig() {
    return useQuery({
        queryKey: ['config'],
        queryFn: async () => {
            const data = await invoke('get_config');
            return ConfigSchema.parse(data);
        },
        refetchInterval: 30000, // Less frequent refresh for config
        refetchOnWindowFocus: false,
        staleTime: 25000,
        retry: 3,
        retryDelay: 1000,
    });
}

/**
 * Get folder status
 */
export function useFolderStatus(folderId: string) {
    const pollingInterval = useAppStore((state) => state.pollingInterval);
    // Folder status polls faster (2x the rate)
    const folderPollingInterval = Math.max(pollingInterval / 2, 1000);

    return useQuery({
        queryKey: ['folderStatus', folderId],
        queryFn: async () => {
            const data = await invoke('get_folder_status', { folderId });
            return FolderStatusSchema.parse(data);
        },
        refetchInterval: folderPollingInterval,
        enabled: !!folderId,
        retry: 3,
        retryDelay: 1000,
    });
}

// ============================================================================
// Mutation Hooks
// ============================================================================

/**
 * Start Syncthing sidecar
 */
export function useStartSyncthing() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async () => {
            return await invoke<string>('start_syncthing_sidecar');
        },
        onSuccess: () => {
            // Wait a bit for syncthing to start, then refetch
            setTimeout(() => {
                queryClient.invalidateQueries({ queryKey: ['systemStatus'] });
                queryClient.invalidateQueries({ queryKey: ['connections'] });
                queryClient.invalidateQueries({ queryKey: ['config'] });
            }, 2000);
        },
    });
}

/**
 * Stop Syncthing sidecar
 */
export function useStopSyncthing() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async () => {
            return await invoke<string>('stop_syncthing_sidecar');
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['systemStatus'] });
            queryClient.invalidateQueries({ queryKey: ['connections'] });
        },
    });
}

/**
 * Pause a folder with optimistic updates
 */
export function usePauseFolder() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (folderId: string) => {
            await invoke('pause_folder', { folderId });
        },
        onMutate: async (folderId) => {
            // Cancel outgoing refetches
            await queryClient.cancelQueries({ queryKey: ['config'] });

            // Snapshot previous value
            const previousConfig = queryClient.getQueryData<Config>(['config']);

            // Optimistically update
            queryClient.setQueryData<Config>(['config'], (old) => {
                if (!old?.folders) return old;
                return {
                    ...old,
                    folders: old.folders.map((folder) =>
                        folder.id === folderId ? { ...folder, paused: true } : folder
                    ),
                };
            });

            return { previousConfig };
        },
        onError: (_err, _folderId, context) => {
            // Rollback on error
            if (context?.previousConfig) {
                queryClient.setQueryData(['config'], context.previousConfig);
            }
        },
        onSettled: () => {
            queryClient.invalidateQueries({ queryKey: ['config'] });
        },
    });
}

/**
 * Resume a folder with optimistic updates
 */
export function useResumeFolder() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (folderId: string) => {
            await invoke('resume_folder', { folderId });
        },
        onMutate: async (folderId) => {
            await queryClient.cancelQueries({ queryKey: ['config'] });

            const previousConfig = queryClient.getQueryData<Config>(['config']);

            queryClient.setQueryData<Config>(['config'], (old) => {
                if (!old?.folders) return old;
                return {
                    ...old,
                    folders: old.folders.map((folder) =>
                        folder.id === folderId ? { ...folder, paused: false } : folder
                    ),
                };
            });

            return { previousConfig };
        },
        onError: (_err, _folderId, context) => {
            if (context?.previousConfig) {
                queryClient.setQueryData(['config'], context.previousConfig);
            }
        },
        onSettled: () => {
            queryClient.invalidateQueries({ queryKey: ['config'] });
        },
    });
}

/**
 * Rescan a folder
 */
export function useRescanFolder() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (folderId: string) => {
            await invoke('rescan_folder', { folderId });
        },
        onSettled: () => {
            queryClient.invalidateQueries({ queryKey: ['folderStatus'] });
        },
    });
}

// ============================================================================
// Device Management
// ============================================================================

/**
 * Get this device's ID
 */
export function useDeviceId() {
    return useQuery({
        queryKey: ['deviceId'],
        queryFn: async () => {
            return await invoke<string>('get_device_id');
        },
        staleTime: Infinity,
        retry: 3,
    });
}

/**
 * Add a new device
 */
export function useAddDevice() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({ deviceId, name }: { deviceId: string; name?: string }) => {
            await invoke('add_device', { deviceId, name: name || deviceId.slice(0, 7) });
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['config'] });
            queryClient.invalidateQueries({ queryKey: ['connections'] });
        },
    });
}

/**
 * Remove a device
 */
export function useRemoveDevice() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (deviceId: string) => {
            await invoke('remove_device', { deviceId });
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['config'] });
            queryClient.invalidateQueries({ queryKey: ['connections'] });
        },
    });
}

/**
 * Pause a device with optimistic updates
 */
export function usePauseDevice() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (deviceId: string) => {
            await invoke('pause_device', { deviceId });
        },
        onMutate: async (deviceId) => {
            await queryClient.cancelQueries({ queryKey: ['config'] });

            const previousConfig = queryClient.getQueryData<Config>(['config']);

            queryClient.setQueryData<Config>(['config'], (old) => {
                if (!old?.devices) return old;
                return {
                    ...old,
                    devices: old.devices.map((device) =>
                        device.deviceID === deviceId ? { ...device, paused: true } : device
                    ),
                };
            });

            return { previousConfig };
        },
        onError: (_err, _deviceId, context) => {
            if (context?.previousConfig) {
                queryClient.setQueryData(['config'], context.previousConfig);
            }
        },
        onSettled: () => {
            queryClient.invalidateQueries({ queryKey: ['config'] });
            queryClient.invalidateQueries({ queryKey: ['connections'] });
        },
    });
}

/**
 * Resume a device with optimistic updates
 */
export function useResumeDevice() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (deviceId: string) => {
            await invoke('resume_device', { deviceId });
        },
        onMutate: async (deviceId) => {
            await queryClient.cancelQueries({ queryKey: ['config'] });

            const previousConfig = queryClient.getQueryData<Config>(['config']);

            queryClient.setQueryData<Config>(['config'], (old) => {
                if (!old?.devices) return old;
                return {
                    ...old,
                    devices: old.devices.map((device) =>
                        device.deviceID === deviceId ? { ...device, paused: false } : device
                    ),
                };
            });

            return { previousConfig };
        },
        onError: (_err, _deviceId, context) => {
            if (context?.previousConfig) {
                queryClient.setQueryData(['config'], context.previousConfig);
            }
        },
        onSettled: () => {
            queryClient.invalidateQueries({ queryKey: ['config'] });
            queryClient.invalidateQueries({ queryKey: ['connections'] });
        },
    });
}

// ============================================================================
// Folder Management
// ============================================================================

/**
 * Add a new folder
 */
export function useAddFolder() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({
            folderId,
            folderLabel,
            folderPath,
        }: {
            folderId: string;
            folderLabel: string;
            folderPath: string;
        }) => {
            await invoke('add_folder', { folderId, folderLabel, folderPath });
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['config'] });
        },
    });
}

/**
 * Remove a folder
 */
export function useRemoveFolder() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (folderId: string) => {
            await invoke('remove_folder', { folderId });
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['config'] });
            queryClient.invalidateQueries({ queryKey: ['folderStatus'] });
        },
    });
}

/**
 * Share a folder with a device
 */
export function useShareFolder() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({ folderId, deviceId }: { folderId: string; deviceId: string }) => {
            await invoke('share_folder', { folderId, deviceId });
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['config'] });
            // Also invalidate folder status as it might change from "Up to Date" to "Syncing"
            queryClient.invalidateQueries({ queryKey: ['folderStatus'] });
        },
    });
}

/**
 * Unshare a folder from a device with optimistic updates
 */
export function useUnshareFolder() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({ folderId, deviceId }: { folderId: string; deviceId: string }) => {
            await invoke('unshare_folder', { folderId, deviceId });
        },
        onMutate: async ({ folderId, deviceId }) => {
            await queryClient.cancelQueries({ queryKey: ['config'] });

            const previousConfig = queryClient.getQueryData<Config>(['config']);

            queryClient.setQueryData<Config>(['config'], (old) => {
                if (!old?.folders) return old;
                return {
                    ...old,
                    folders: old.folders.map((folder) => {
                        if (folder.id !== folderId) return folder;
                        return {
                            ...folder,
                            devices: folder.devices?.filter((d) => d.deviceID !== deviceId) || [],
                        };
                    }),
                };
            });

            return { previousConfig };
        },
        onError: (_err, _variables, context) => {
            if (context?.previousConfig) {
                queryClient.setQueryData(['config'], context.previousConfig);
            }
        },
        onSettled: () => {
            queryClient.invalidateQueries({ queryKey: ['config'] });
            queryClient.invalidateQueries({ queryKey: ['folderStatus'] });
        },
    });
}

// ============================================================================
// Advanced Folder Management
// ============================================================================

/**
 * Add a folder with advanced options
 */
export function useAddFolderAdvanced() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (options: AdvancedFolderOptions) => {
            await invoke('add_folder_advanced', {
                folderId: options.folderId,
                folderLabel: options.folderLabel,
                folderPath: options.folderPath,
                versioningType: options.versioningType || null,
                versioningParams: options.versioningParams || null,
                rescanIntervalS: options.rescanIntervalS || null,
                fsWatcherEnabled: options.fsWatcherEnabled ?? null,
                fsWatcherDelayS: options.fsWatcherDelayS || null,
                ignorePerms: options.ignorePerms ?? null,
            });
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['config'] });
        },
    });
}

/**
 * Get detailed folder configuration
 */
export function useFolderConfig(folderId: string) {
    return useQuery({
        queryKey: ['folderConfig', folderId],
        queryFn: async () => {
            const data = await invoke('get_folder_config', { folderId });
            return FolderConfigSchema.parse(data);
        },
        enabled: !!folderId,
        staleTime: 30000,
    });
}

/**
 * Update folder configuration
 */
export function useUpdateFolderConfig() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({
            folderId,
            updates,
        }: {
            folderId: string;
            updates: Partial<FolderConfig>;
        }) => {
            await invoke('update_folder_config', { folderId, updates });
        },
        onSuccess: (_data, { folderId }) => {
            queryClient.invalidateQueries({ queryKey: ['config'] });
            queryClient.invalidateQueries({ queryKey: ['folderConfig', folderId] });
        },
    });
}

// ============================================================================
// Ignore Patterns (.stignore)
// ============================================================================

/**
 * Get ignore patterns for a folder
 */
export function useFolderIgnores(folderId: string) {
    return useQuery({
        queryKey: ['folderIgnores', folderId],
        queryFn: async () => {
            const data = await invoke('get_folder_ignores', { folderId });
            return IgnorePatternsSchema.parse(data);
        },
        enabled: !!folderId,
        staleTime: 30000,
    });
}

/**
 * Set ignore patterns for a folder
 */
export function useSetFolderIgnores() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({
            folderId,
            ignorePatterns,
        }: {
            folderId: string;
            ignorePatterns: string[];
        }) => {
            await invoke('set_folder_ignores', { folderId, ignorePatterns });
        },
        onSuccess: (_data, { folderId }) => {
            queryClient.invalidateQueries({ queryKey: ['folderIgnores', folderId] });
        },
    });
}

// ============================================================================
// System Logs
// ============================================================================

/**
 * Get system logs
 */
export function useSystemLogs(since?: string) {
    return useQuery({
        queryKey: ['systemLogs', since],
        queryFn: async () => {
            const data = await invoke('get_system_logs', { since: since || null });
            return SystemLogsSchema.parse(data);
        },
        refetchInterval: 10000, // Refresh every 10 seconds
        staleTime: 5000,
    });
}

// ============================================================================
// Event API for Real-Time Updates
// ============================================================================

/**
 * Hook for real-time Syncthing events using long-polling
 */
export function useSyncthingEvents(options?: {
    onEvent?: (event: SyncthingEvent) => void;
    enabled?: boolean;
}) {
    const queryClient = useQueryClient();
    const lastEventIdRef = useRef<number>(0);
    const [events, setEvents] = useState<SyncthingEvent[]>([]);
    const [isPolling, setIsPolling] = useState(false);
    const abortControllerRef = useRef<AbortController | null>(null);
    const enabled = options?.enabled ?? true;

    const pollEvents = useCallback(async () => {
        if (!enabled) return;

        setIsPolling(true);

        try {
            const data = await invoke<SyncthingEvent[]>('get_events', {
                since: lastEventIdRef.current,
                limit: 100,
                timeout: 30,
            });

            if (Array.isArray(data) && data.length > 0) {
                const parsedEvents = data.map((e) => SyncthingEventSchema.parse(e));

                // Update last event ID
                const maxId = Math.max(...parsedEvents.map((e) => e.id));
                if (maxId > lastEventIdRef.current) {
                    lastEventIdRef.current = maxId;
                }

                setEvents((prev) => [...prev.slice(-100), ...parsedEvents]);

                // Call event handler for each event
                parsedEvents.forEach((event) => {
                    options?.onEvent?.(event);

                    // Invalidate queries based on event type
                    switch (event.type) {
                        case 'StateChanged':
                        case 'FolderCompletion':
                        case 'FolderSummary':
                            queryClient.invalidateQueries({ queryKey: ['folderStatus'] });
                            break;
                        case 'DeviceConnected':
                        case 'DeviceDisconnected':
                        case 'DevicePaused':
                        case 'DeviceResumed':
                            queryClient.invalidateQueries({ queryKey: ['connections'] });
                            break;
                        case 'ConfigSaved':
                            queryClient.invalidateQueries({ queryKey: ['config'] });
                            break;
                        case 'ItemStarted':
                        case 'ItemFinished':
                            queryClient.invalidateQueries({ queryKey: ['folderStatus'] });
                            break;
                    }
                });
            }
        } catch (error) {
            // Only log actual errors, not aborts or empty responses
            const isAbortError = error instanceof DOMException && error.name === 'AbortError';
            const isNullish = error === null || error === undefined;
            const isEmptyError =
                error &&
                typeof error === 'object' &&
                !Array.isArray(error) &&
                (Object.keys(error as object).length === 0 || JSON.stringify(error) === '{}');

            // Also check for timeout errors which are expected during long polling
            const errorStr = String(error);
            const errorJson = JSON.stringify(error);
            const isTimeoutError = errorStr.includes('timeout') || errorStr.includes('Timeout');

            // Check for connection errors when Syncthing isn't running
            const isConnectionError = errorStr.includes('Connection') || errorStr.includes('connection') ||
                errorStr.includes('ECONNREFUSED') || errorStr.includes('NetworkError');

            // Check for parse errors (Syncthing returning unexpected data)
            const isParseError = errorJson.includes('ParseError') || errorJson.includes('decoding') ||
                errorStr.includes('ParseError') || errorStr.includes('decoding');

            // Skip logging for expected non-error conditions
            if (isAbortError || isEmptyError || isNullish || isTimeoutError || isConnectionError || isParseError) {
                return;
            }

            // Only log if it's a real unexpected error
            if (process.env.NODE_ENV === 'development') {
                console.warn('Event polling error:', error);
            }
        } finally {
            setIsPolling(false);
        }
    }, [enabled, queryClient, options]);

    useEffect(() => {
        if (!enabled) return;

        let timeoutId: ReturnType<typeof setTimeout>;

        const poll = async () => {
            await pollEvents();
            // Schedule next poll
            timeoutId = setTimeout(poll, 1000);
        };

        poll();

        return () => {
            clearTimeout(timeoutId);
            abortControllerRef.current?.abort();
        };
    }, [enabled, pollEvents]);

    return {
        events,
        isPolling,
        clearEvents: () => setEvents([]),
    };
}

// ============================================================================
// Advanced Device Management
// ============================================================================

/**
 * Add device with advanced options
 */
export function useAddDeviceAdvanced() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (options: AdvancedDeviceOptions) => {
            await invoke('add_device_advanced', {
                deviceId: options.deviceId,
                name: options.name,
                addresses: options.addresses || null,
                compression: options.compression || null,
                introducer: options.introducer ?? null,
                autoAcceptFolders: options.autoAcceptFolders ?? null,
                maxSendKbps: options.maxSendKbps || null,
                maxRecvKbps: options.maxRecvKbps || null,
            });
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['config'] });
            queryClient.invalidateQueries({ queryKey: ['connections'] });
        },
    });
}

/**
 * Get detailed device configuration
 */
export function useDeviceConfig(deviceId: string) {
    return useQuery({
        queryKey: ['deviceConfig', deviceId],
        queryFn: async () => {
            const data = await invoke('get_device_config', { deviceId });
            return DeviceConfigSchema.parse(data);
        },
        enabled: !!deviceId,
        staleTime: 30000,
    });
}

/**
 * Update device configuration
 */
export function useUpdateDeviceConfig() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({
            deviceId,
            updates,
        }: {
            deviceId: string;
            updates: Partial<DeviceConfig>;
        }) => {
            await invoke('update_device_config', { deviceId, updates });
        },
        onSuccess: (_data, { deviceId }) => {
            queryClient.invalidateQueries({ queryKey: ['config'] });
            queryClient.invalidateQueries({ queryKey: ['deviceConfig', deviceId] });
            queryClient.invalidateQueries({ queryKey: ['connections'] });
        },
    });
}

// ============================================================================
// System Management
// ============================================================================

/**
 * Restart Syncthing
 */
export function useRestartSyncthing() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async () => {
            await invoke('restart_syncthing');
        },
        onSuccess: () => {
            // Wait for restart and then refetch everything
            setTimeout(() => {
                queryClient.invalidateQueries({ queryKey: ['systemStatus'] });
                queryClient.invalidateQueries({ queryKey: ['config'] });
                queryClient.invalidateQueries({ queryKey: ['connections'] });
            }, 3000);
        },
    });
}

// ============================================================================
// File Browser Integration
// ============================================================================

/**
 * Open folder in system file explorer
 */
export function useOpenFolderInExplorer() {
    return useMutation({
        mutationFn: async (folderPath: string) => {
            await invoke('open_folder_in_explorer', { folderPath });
        },
    });
}

/**
 * Browse folder contents
 */
export function useBrowseFolder(folderId: string, prefix?: string) {
    return useQuery({
        queryKey: ['browseFolder', folderId, prefix],
        queryFn: async () => {
            const data = await invoke('browse_folder', {
                folderId,
                prefix: prefix || null,
            });
            return data as Record<string, unknown>[];
        },
        enabled: !!folderId,
        staleTime: 10000,
    });
}

// ============================================================================
// Conflict Resolution
// ============================================================================

export interface ConflictFile {
    name: string;
    original: string;
    size: number;
    modTime?: number;
}

/**
 * Scan folder for conflict files
 */
export function useScanConflicts(folderPath: string) {
    return useQuery({
        queryKey: ['conflicts', folderPath],
        queryFn: async () => {
            const data = await invoke<ConflictFile[]>('scan_for_conflicts', { folderPath });
            return data;
        },
        enabled: !!folderPath,
        staleTime: 30000,
    });
}

/**
 * Delete a conflict file (keep original)
 */
export function useDeleteConflict() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({
            folderPath,
            conflictFile,
        }: {
            folderPath: string;
            conflictFile: string;
        }) => {
            await invoke('delete_conflict_file', { folderPath, conflictFile });
        },
        onSuccess: (_data, { folderPath }) => {
            queryClient.invalidateQueries({ queryKey: ['conflicts', folderPath] });
        },
    });
}

/**
 * Resolve conflict by keeping the conflict version
 */
export function useResolveConflictKeepConflict() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({
            folderPath,
            originalFile,
            conflictFile,
        }: {
            folderPath: string;
            originalFile: string;
            conflictFile: string;
        }) => {
            await invoke('resolve_conflict_keep_conflict', { folderPath, originalFile, conflictFile });
        },
        onSuccess: (_data, { folderPath }) => {
            queryClient.invalidateQueries({ queryKey: ['conflicts', folderPath] });
        },
    });
}

// ============================================================================
// File Versioning
// ============================================================================

export interface VersionEntry {
    name: string;
    originalName: string;
    type: 'file' | 'directory';
    size?: number;
    modTime?: number;
    versionTime?: string;
}

/**
 * Browse .stversions folder for old file versions
 */
export function useBrowseVersions(folderPath: string, prefix?: string) {
    return useQuery({
        queryKey: ['versions', folderPath, prefix],
        queryFn: async () => {
            const data = await invoke<VersionEntry[]>('browse_versions', {
                folderPath,
                prefix: prefix || null,
            });
            return data;
        },
        enabled: !!folderPath,
        staleTime: 10000,
    });
}

/**
 * Restore a versioned file to its original location
 */
export function useRestoreVersion() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({
            folderPath,
            versionPath,
            originalName,
            overwrite = false,
        }: {
            folderPath: string;
            versionPath: string;
            originalName: string;
            overwrite?: boolean;
        }) => {
            await invoke('restore_version', {
                folderPath,
                versionPath,
                originalName,
                overwrite,
            });
        },
        onSuccess: (_data, { folderPath }) => {
            queryClient.invalidateQueries({ queryKey: ['versions', folderPath] });
            queryClient.invalidateQueries({ queryKey: ['browseFolder'] });
        },
    });
}

// ============================================================================
// Global Options
// ============================================================================

/**
 * Update global Syncthing options (network settings, discovery, etc.)
 */
export function useUpdateOptions() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (options: Partial<Options>) => {
            await invoke('update_options', { options });
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['config'] });
        },
    });
}

// ============================================================================
// Syncthing Lifecycle
// ============================================================================

/**
 * Hook to manage Syncthing lifecycle - auto-starts on mount
 */
export function useSyncthingLifecycle() {
    const startMutation = useStartSyncthing();
    const { data: status, isError, error } = useSystemStatus();

    return {
        start: startMutation.mutate,
        isStarting: startMutation.isPending,
        startError: startMutation.error,
        isRunning: !!status?.myID,
        isConnecting: !status?.myID && !isError,
        connectionError: isError ? error : null,
    };
}
</file>

<file path="src/lib/health-monitor.ts">
// src/lib/health-monitor.ts
import { logger } from './logger';
import { invoke } from '@tauri-apps/api/core';

interface HealthCheck {
    name: string;
    check: () => Promise<boolean>;
    interval: number;
    critical?: boolean;
}

interface HealthStatus {
    name: string;
    healthy: boolean;
    lastCheck: Date;
    lastSuccess?: Date;
    lastFailure?: Date;
    consecutiveFailures: number;
    error?: string;
}

type HealthListener = (status: Map<string, HealthStatus>) => void;

export class HealthMonitor {
    private checks: Map<string, HealthCheck> = new Map();
    private status: Map<string, HealthStatus> = new Map();
    private intervals: Map<string, ReturnType<typeof setInterval>> = new Map();
    private listeners: Set<HealthListener> = new Set();

    /**
     * Register a health check
     */
    register(check: HealthCheck) {
        this.checks.set(check.name, check);
        this.status.set(check.name, {
            name: check.name,
            healthy: true,
            lastCheck: new Date(),
            consecutiveFailures: 0,
        });

        // Start periodic checks
        this.startCheck(check);

        logger.info(`Health check registered: ${check.name}`, {
            interval: check.interval,
            critical: check.critical,
        });
    }

    /**
     * Unregister a health check
     */
    unregister(name: string) {
        const interval = this.intervals.get(name);
        if (interval) {
            clearInterval(interval);
            this.intervals.delete(name);
        }
        this.checks.delete(name);
        this.status.delete(name);
        logger.info(`Health check unregistered: ${name}`);
    }

    /**
     * Start periodic health check
     */
    private startCheck(check: HealthCheck) {
        // Run immediately
        this.runCheck(check);

        // Schedule periodic runs
        const interval = setInterval(() => {
            this.runCheck(check);
        }, check.interval);

        this.intervals.set(check.name, interval);
    }

    /**
     * Run a single health check
     */
    private async runCheck(check: HealthCheck) {
        const currentStatus = this.status.get(check.name);
        if (!currentStatus) return;

        const startTime = Date.now();

        try {
            const result = await Promise.race([
                check.check(),
                new Promise<boolean>((_, reject) =>
                    setTimeout(() => reject(new Error('Health check timeout')), 10000)
                ),
            ]);

            const duration = Date.now() - startTime;

            if (result) {
                // Success
                const wasUnhealthy = !currentStatus.healthy;
                this.status.set(check.name, {
                    ...currentStatus,
                    healthy: true,
                    lastCheck: new Date(),
                    lastSuccess: new Date(),
                    consecutiveFailures: 0,
                    error: undefined,
                });

                if (wasUnhealthy) {
                    logger.info(`Health check recovered: ${check.name}`, { duration });
                }
            } else {
                // Failed
                this.handleFailure(check, currentStatus, 'Check returned false');
            }
        } catch (error) {
            this.handleFailure(
                check,
                currentStatus,
                error instanceof Error ? error.message : 'Unknown error'
            );
        }

        // Notify listeners
        this.notifyListeners();
    }

    /**
     * Handle check failure
     */
    private handleFailure(check: HealthCheck, currentStatus: HealthStatus, error: string) {
        const consecutiveFailures = currentStatus.consecutiveFailures + 1;

        this.status.set(check.name, {
            ...currentStatus,
            healthy: false,
            lastCheck: new Date(),
            lastFailure: new Date(),
            consecutiveFailures,
            error,
        });

        // Only log warning on first few failures to reduce noise
        if (consecutiveFailures <= 3) {
            logger.warn(`Health check failed: ${check.name}`, {
                error,
                consecutiveFailures,
                critical: check.critical,
            });
        }

        // Alert on critical failures - only log once when threshold is reached
        // (not on every subsequent failure)
        if (check.critical && consecutiveFailures === 3) {
            const hint =
                check.name === 'syncthing-api'
                    ? 'Syncthing may not be running. Please ensure Syncthing is started.'
                    : undefined;
            logger.error(`CRITICAL: Health check failing repeatedly: ${check.name}`, {
                consecutiveFailures,
                ...(hint && { hint }),
            });
        }
    }

    /**
     * Subscribe to health status changes
     */
    subscribe(listener: HealthListener) {
        this.listeners.add(listener);
        // Immediately notify with current status
        listener(new Map(this.status));

        // Return unsubscribe function
        return () => {
            this.listeners.delete(listener);
        };
    }

    /**
     * Notify all listeners
     */
    private notifyListeners() {
        this.listeners.forEach((listener) => {
            try {
                listener(new Map(this.status));
            } catch (error) {
                logger.error('Health monitor listener error', {
                    error: error instanceof Error ? error.message : String(error),
                });
            }
        });
    }

    /**
     * Get current health status
     */
    getStatus(): Map<string, HealthStatus> {
        return new Map(this.status);
    }

    /**
     * Get status for a specific check
     */
    getCheckStatus(name: string): HealthStatus | undefined {
        return this.status.get(name);
    }

    /**
     * Check if system is healthy
     */
    isHealthy(): boolean {
        return Array.from(this.status.values()).every((s) => s.healthy);
    }

    /**
     * Check if critical services are healthy
     */
    isCriticalHealthy(): boolean {
        return Array.from(this.status.entries()).every(([name, status]) => {
            const check = this.checks.get(name);
            return !check?.critical || status.healthy;
        });
    }

    /**
     * Get summary
     */
    getSummary() {
        const all = Array.from(this.status.values());
        return {
            total: all.length,
            healthy: all.filter((s) => s.healthy).length,
            unhealthy: all.filter((s) => !s.healthy).length,
            critical: all.filter((s) => {
                const check = this.checks.get(s.name);
                return check?.critical && !s.healthy;
            }).length,
        };
    }

    /**
     * Force run all health checks
     */
    async runAllChecks(): Promise<void> {
        const checks = Array.from(this.checks.values());
        await Promise.all(checks.map((check) => this.runCheck(check)));
    }

    /**
     * Stop all health checks
     */
    stop() {
        this.intervals.forEach((interval) => clearInterval(interval));
        this.intervals.clear();
        logger.info('Health monitor stopped');
    }

    /**
     * Restart all health checks
     */
    restart() {
        this.stop();
        this.checks.forEach((check) => this.startCheck(check));
        logger.info('Health monitor restarted');
    }
}

// Global health monitor instance
export const healthMonitor = new HealthMonitor();

// Register default checks
export function registerDefaultHealthChecks(_apiKey?: string) {
    // Syncthing API check - use Tauri invoke instead of direct fetch
    healthMonitor.register({
        name: 'syncthing-api',
        check: async () => {
            try {
                // Use the same Tauri command that the UI uses
                const result = await invoke('get_system_status');
                return result !== null && result !== undefined;
            } catch {
                return false;
            }
        },
        interval: 10000,
        critical: true,
    });

    // IndexedDB check
    healthMonitor.register({
        name: 'indexeddb',
        check: async () => {
            try {
                const request = indexedDB.open('health-check', 1);
                return new Promise((resolve) => {
                    request.onsuccess = () => {
                        request.result.close();
                        resolve(true);
                    };
                    request.onerror = () => resolve(false);
                });
            } catch {
                return false;
            }
        },
        interval: 60000,
    });

    // Memory check (browser only)
    if (typeof window !== 'undefined' && 'memory' in performance) {
        healthMonitor.register({
            name: 'memory',
            check: async () => {
                const memory = (
                    performance as Performance & {
                        memory?: { usedJSHeapSize: number; jsHeapSizeLimit: number };
                    }
                ).memory;
                if (memory) {
                    const usedPercent = (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100;
                    return usedPercent < 90; // Alert if over 90%
                }
                return true;
            },
            interval: 30000,
        });
    }

    logger.info('Default health checks registered');
}

export type { HealthCheck, HealthStatus };
</file>

<file path="src-tauri/Cargo.toml">
[package]
name = "eigen"
version = "0.1.0"
description = "Eigen - A Modern Syncthing Manager"
authors = ["Eigen Team"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

# Clippy lints for better code quality
[lints.rust]
unsafe_code = "warn"

[lints.clippy]
all = "warn"
pedantic = "warn"
nursery = "warn"
# Allow common patterns
module_name_repetitions = "allow"
must_use_candidate = "allow"
missing_errors_doc = "allow"
missing_panics_doc = "allow"
too_many_lines = "allow"

[lib]
# The `_lib` suffix may seem redundant but it is necessary
# to make the lib name unique and wouldn't conflict with the bin name.
# This seems to be only an issue on Windows, see https://github.com/rust-lang/cargo/issues/8519
name = "eigen_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2", features = [] }

[dependencies]
tauri = { version = "2", features = ["tray-icon", "image-png"] }
tauri-plugin-opener = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
reqwest = { version = "0.12", features = ["json"] }
tokio = { version = "1", features = ["full"] }
rand = "0.8"
uuid = { version = "1", features = ["v4"] }
log = "0.4"
env_logger = "0.11"
thiserror = "1"
open = "5"
tauri-plugin-notification = "2.3.3"
tauri-plugin-dialog = "2.4.2"
tauri-plugin-shell = "2.3.3"
image = "0.25"
</file>

<file path="src-tauri/tauri.conf.json">
{
  "$schema": "https://schema.tauri.app/config/2",
  "productName": "Eigen",
  "version": "0.1.0",
  "identifier": "com.eigen.sync",
  "build": {
    "beforeDevCommand": "pnpm dev",
    "devUrl": "http://localhost:3000",
    "beforeBuildCommand": "pnpm build",
    "frontendDist": "../out"
  },
  "app": {
    "windows": [
      {
        "title": "Eigen - Syncthing Manager",
        "width": 1200,
        "height": 800,
        "minWidth": 800,
        "minHeight": 600,
        "resizable": true,
        "fullscreen": false,
        "transparent": false,
        "decorations": true,
        "maximizable": true
      }
    ],
    "security": {
      "csp": null
    }
  },
  "bundle": {
    "active": true,
    "targets": "all",
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ],
    "externalBin": ["binaries/syncthing"]
  }
}
</file>

<file path="package.json">
{
  "name": "eigen",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "next dev --webpack --port 3000",
    "dev:turbo": "next dev --turbopack --port 3000",
    "build": "next build",
    "start": "next start",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier --write .",
    "format:check": "prettier --check .",
    "type-check": "tsc --noEmit",
    "check": "pnpm lint && pnpm format:check && pnpm type-check",
    "tauri": "tauri",
    "tauri:lint": "cd src-tauri && cargo clippy --all-targets --all-features -- -D warnings",
    "tauri:fmt": "cd src-tauri && cargo fmt --all",
    "tauri:fmt:check": "cd src-tauri && cargo fmt --all -- --check",
    "tauri:check": "cd src-tauri && cargo check --all-targets",
    "download:syncthing": "node scripts/download-syncthing.js",
    "prebuild": "node scripts/download-syncthing.js"
  },
  "dependencies": {
    "@tanstack/react-query": "^5.90.11",
    "@tauri-apps/api": "^2",
    "@tauri-apps/plugin-dialog": "^2.4.2",
    "@tauri-apps/plugin-notification": "^2.3.3",
    "@tauri-apps/plugin-opener": "^2",
    "@tauri-apps/plugin-shell": "^2.3.3",
    "@xenova/transformers": "^2.17.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "framer-motion": "^12.23.24",
    "idb": "^8.0.3",
    "lucide-react": "^0.555.0",
    "next": "^16.0.5",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "sonner": "^2.0.7",
    "tailwind-merge": "^3.4.0",
    "zod": "^4.1.13",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@next/eslint-plugin-next": "^16.0.5",
    "@tailwindcss/postcss": "^4.1.17",
    "@tauri-apps/cli": "^2",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "@types/three": "^0.181.0",
    "@typescript-eslint/eslint-plugin": "^8.48.0",
    "@typescript-eslint/parser": "^8.48.0",
    "autoprefixer": "^10.4.22",
    "eslint": "^9.39.1",
    "eslint-config-next": "^16.0.5",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-prettier": "^5.5.4",
    "eslint-plugin-react": "^7.37.5",
    "eslint-plugin-react-hooks": "^7.0.1",
    "globals": "^16.5.0",
    "postcss": "^8.5.6",
    "prettier": "^3.7.3",
    "prettier-plugin-tailwindcss": "^0.7.1",
    "tailwindcss": "^4.1.17",
    "typescript": "~5.9.3"
  }
}
</file>

<file path="README.md">
# Eigen

## Features## Recommended IDE Setup

-  **Native Performance** - Built with Rust/Tauri for blazing fast performance- [VS Code](https://code.visualstudio.com/) + [Tauri](https://marketplace.visualstudio.com/items?itemName=tauri-apps.tauri-vscode) + [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer)

-  **Modern UI** - Beautiful glassmorphism design with dark theme
-  **3D Network Visualization** - Interactive network topology using React Three Fiber
-  **Real-time Updates** - Live sync status with TanStack Query polling
-  **Secure** - API keys managed internally by Rust backend
-  **Type-Safe** - End-to-end type safety with TypeScript and Zod

## Tech Stack

### Frontend

- **Next.js 15** - React framework with static export
- **Tailwind CSS** - Utility-first styling
- **TanStack Query** - Server state management
- **Zustand** - Client state management
- **React Three Fiber** - 3D visualizations
- **Lucide Icons** - Beautiful icons

### Backend

- **Tauri v2** - Rust-based desktop framework
- **Reqwest** - HTTP client for Syncthing API
- **Tokio** - Async runtime
- **Serde** - Serialization/deserialization

## Prerequisites

- [Node.js](https://nodejs.org/) (v18+)
- [pnpm](https://pnpm.io/) (v8+)
- [Rust](https://www.rust-lang.org/tools/install)
- [Syncthing](https://syncthing.net/) installed and accessible in PATH

### Linux Dependencies (Ubuntu/Debian)

```bash
sudo apt update
sudo apt install -y libwebkit2gtk-4.1-dev libgtk-3-dev libayatana-appindicator3-dev librsvg2-dev
```

## Development

### Install Dependencies

```bash
pnpm install
```

### Run Development Server

```bash
pnpm tauri dev
```

### Build for Production

```bash
pnpm tauri build
```

## Project Structure

```
eigen/
 src/                      # Next.js frontend
    app/                  # App router pages
    components/           # React components
       ui/              # shadcn/ui components
       network-graph.tsx # 3D network visualization
       folder-list.tsx   # Folder management
       device-list.tsx   # Device management
       ...
    hooks/               # Custom React hooks
    lib/                 # Utility functions
    store/               # Zustand stores
 src-tauri/               # Rust backend
    src/
       lib.rs           # Tauri commands
    Cargo.toml           # Rust dependencies
    tauri.conf.json      # Tauri configuration
 package.json
```

## Architecture

Eigen follows a "Thin Client" architecture:

1. **Frontend (Next.js SSG)**: Pure UI rendering and visualization
2. **Backend (Rust/Tauri)**: Manages Syncthing process, proxies API requests, handles native features

### Data Flow

```
User Action  React Component  TanStack Query  Tauri IPC  Rust Backend  Syncthing REST API
                                              
User UI  React Component  TanStack Query  Tauri IPC  Rust Backend  Syncthing Response
```

## Features

### Dashboard

- Real-time sync status
- Network topology visualization
- Upload/download statistics
- Folder and device overview

### Folders

- View all synced folders
- Pause/resume sync
- Force rescan
- Sync status indicators

### Devices

- Connected device list
- Connection status
- Device information

## License

MIT
</file>

</files>
