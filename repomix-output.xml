This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: tsconfig.tsbuildinfo
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
public/
  tauri.svg
  vite.svg
scripts/
  download-syncthing.js
src/
  app/
    globals.css
    layout.tsx
    page.tsx
  components/
    ui/
      badge.tsx
      button.tsx
      card.tsx
      motion.tsx
      skeleton.tsx
    add-device-dialog.tsx
    add-folder-dialog.tsx
    ai-search-bar.tsx
    conflict-resolver.tsx
    device-list.tsx
    file-browser.tsx
    file-indexer.tsx
    folder-list.tsx
    header.tsx
    ignore-patterns-dialog.tsx
    log-viewer.tsx
    logs-page.tsx
    main-content.tsx
    network-graph.tsx
    providers.tsx
    settings-page.tsx
    share-folder-dialog.tsx
    sidebar.tsx
    stats-overview.tsx
    syncthing-manager.tsx
  hooks/
    useAISearch.ts
    useNotifications.ts
    useSyncthing.ts
  lib/
    db.ts
    utils.ts
  store/
    index.ts
  workers/
    ai.worker.ts
src-tauri/
  capabilities/
    default.json
  src/
    commands.rs
    lib.rs
    main.rs
  .gitignore
  build.rs
  Cargo.toml
  tauri.conf.json
.gitattributes
.gitignore
next-env.d.ts
next.config.mjs
package.json
postcss.config.cjs
README.md
tailwind.config.cjs
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="public/tauri.svg">
<svg width="206" height="231" viewBox="0 0 206 231" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M143.143 84C143.143 96.1503 133.293 106 121.143 106C108.992 106 99.1426 96.1503 99.1426 84C99.1426 71.8497 108.992 62 121.143 62C133.293 62 143.143 71.8497 143.143 84Z" fill="#FFC131"/>
<ellipse cx="84.1426" cy="147" rx="22" ry="22" transform="rotate(180 84.1426 147)" fill="#24C8DB"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M166.738 154.548C157.86 160.286 148.023 164.269 137.757 166.341C139.858 160.282 141 153.774 141 147C141 144.543 140.85 142.121 140.558 139.743C144.975 138.204 149.215 136.139 153.183 133.575C162.73 127.404 170.292 118.608 174.961 108.244C179.63 97.8797 181.207 86.3876 179.502 75.1487C177.798 63.9098 172.884 53.4021 165.352 44.8883C157.82 36.3744 147.99 30.2165 137.042 27.1546C126.095 24.0926 114.496 24.2568 103.64 27.6274C92.7839 30.998 83.1319 37.4317 75.8437 46.1553C74.9102 47.2727 74.0206 48.4216 73.176 49.5993C61.9292 50.8488 51.0363 54.0318 40.9629 58.9556C44.2417 48.4586 49.5653 38.6591 56.679 30.1442C67.0505 17.7298 80.7861 8.57426 96.2354 3.77762C111.685 -1.01901 128.19 -1.25267 143.769 3.10474C159.348 7.46215 173.337 16.2252 184.056 28.3411C194.775 40.457 201.767 55.4101 204.193 71.404C206.619 87.3978 204.374 103.752 197.73 118.501C191.086 133.25 180.324 145.767 166.738 154.548ZM41.9631 74.275L62.5557 76.8042C63.0459 72.813 63.9401 68.9018 65.2138 65.1274C57.0465 67.0016 49.2088 70.087 41.9631 74.275Z" fill="#FFC131"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M38.4045 76.4519C47.3493 70.6709 57.2677 66.6712 67.6171 64.6132C65.2774 70.9669 64 77.8343 64 85.0001C64 87.1434 64.1143 89.26 64.3371 91.3442C60.0093 92.8732 55.8533 94.9092 51.9599 97.4256C42.4128 103.596 34.8505 112.392 30.1816 122.756C25.5126 133.12 23.9357 144.612 25.6403 155.851C27.3449 167.09 32.2584 177.598 39.7906 186.112C47.3227 194.626 57.153 200.784 68.1003 203.846C79.0476 206.907 90.6462 206.743 101.502 203.373C112.359 200.002 122.011 193.568 129.299 184.845C130.237 183.722 131.131 182.567 131.979 181.383C143.235 180.114 154.132 176.91 164.205 171.962C160.929 182.49 155.596 192.319 148.464 200.856C138.092 213.27 124.357 222.426 108.907 227.222C93.458 232.019 76.9524 232.253 61.3736 227.895C45.7948 223.538 31.8055 214.775 21.0867 202.659C10.3679 190.543 3.37557 175.59 0.949823 159.596C-1.47592 143.602 0.768139 127.248 7.41237 112.499C14.0566 97.7497 24.8183 85.2327 38.4045 76.4519ZM163.062 156.711L163.062 156.711C162.954 156.773 162.846 156.835 162.738 156.897C162.846 156.835 162.954 156.773 163.062 156.711Z" fill="#24C8DB"/>
</svg>
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="scripts/download-syncthing.js">
#!/usr/bin/env node
/**
 * Downloads the Syncthing binary for the current platform
 * and places it in the src-tauri/binaries folder with the correct target triple name.
 */

import { execSync } from 'child_process';
import fs from 'fs';
import https from 'https';
import path from 'path';
import { fileURLToPath } from 'url';
import { createGunzip } from 'zlib';
import { pipeline } from 'stream/promises';
import { createWriteStream } from 'fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SYNCTHING_VERSION = 'v1.27.12';

// Map of Rust target triples to Syncthing release names
const PLATFORM_MAP = {
	'x86_64-unknown-linux-gnu': { os: 'linux', arch: 'amd64' },
	'aarch64-unknown-linux-gnu': { os: 'linux', arch: 'arm64' },
	'x86_64-apple-darwin': { os: 'macos', arch: 'amd64' },
	'aarch64-apple-darwin': { os: 'macos', arch: 'arm64' },
	'x86_64-pc-windows-msvc': { os: 'windows', arch: 'amd64' },
};

async function getTargetTriple() {
	const rustInfo = execSync('rustc -vV').toString();
	const match = /host: (\S+)/.exec(rustInfo);
	if (!match) {
		throw new Error('Failed to determine platform target triple');
	}
	return match[1];
}

async function downloadFile(url, destPath) {
	return new Promise((resolve, reject) => {
		const file = createWriteStream(destPath);
		https
			.get(url, (response) => {
				if (
					response.statusCode === 302 ||
					response.statusCode === 301
				) {
					// Follow redirect
					https
						.get(response.headers.location, (redirectResponse) => {
							redirectResponse.pipe(file);
							file.on('finish', () => {
								file.close();
								resolve();
							});
						})
						.on('error', reject);
				} else {
					response.pipe(file);
					file.on('finish', () => {
						file.close();
						resolve();
					});
				}
			})
			.on('error', reject);
	});
}

async function extractTarGz(tarGzPath, destDir) {
	execSync(`tar -xzf "${tarGzPath}" -C "${destDir}"`);
}

async function extractZip(zipPath, destDir) {
	execSync(`unzip -o "${zipPath}" -d "${destDir}"`);
}

async function main() {
	try {
		const targetTriple = await getTargetTriple();
		console.log(`Target triple: ${targetTriple}`);

		const platformInfo = PLATFORM_MAP[targetTriple];
		if (!platformInfo) {
			throw new Error(`Unsupported platform: ${targetTriple}`);
		}

		const binariesDir = path.join(__dirname, '..', 'src-tauri', 'binaries');
		const tempDir = path.join(__dirname, '..', 'temp');

		// Create directories
		fs.mkdirSync(binariesDir, { recursive: true });
		fs.mkdirSync(tempDir, { recursive: true });

		const extension = platformInfo.os === 'windows' ? '.exe' : '';
		const archiveExt = platformInfo.os === 'windows' ? 'zip' : 'tar.gz';
		const archiveName = `syncthing-${platformInfo.os}-${platformInfo.arch}-${SYNCTHING_VERSION}`;
		const downloadUrl = `https://github.com/syncthing/syncthing/releases/download/${SYNCTHING_VERSION}/${archiveName}.${archiveExt}`;

		console.log(
			`Downloading Syncthing ${SYNCTHING_VERSION} for ${platformInfo.os}-${platformInfo.arch}...`
		);
		console.log(`URL: ${downloadUrl}`);

		const archivePath = path.join(tempDir, `${archiveName}.${archiveExt}`);

		// Download the archive
		await downloadFile(downloadUrl, archivePath);
		console.log('Download complete.');

		// Extract
		console.log('Extracting...');
		if (platformInfo.os === 'windows') {
			await extractZip(archivePath, tempDir);
		} else {
			await extractTarGz(archivePath, tempDir);
		}

		// Move binary to binaries folder with correct name
		const sourceBinary = path.join(
			tempDir,
			archiveName,
			`syncthing${extension}`
		);
		const destBinary = path.join(
			binariesDir,
			`syncthing-${targetTriple}${extension}`
		);

		console.log(`Moving binary to ${destBinary}`);
		fs.copyFileSync(sourceBinary, destBinary);

		// Make executable on Unix
		if (platformInfo.os !== 'windows') {
			fs.chmodSync(destBinary, 0o755);
		}

		// Cleanup
		fs.rmSync(tempDir, { recursive: true, force: true });

		console.log('Syncthing binary installed successfully!');
		console.log(`Binary location: ${destBinary}`);
	} catch (error) {
		console.error('Error:', error.message);
		process.exit(1);
	}
}

main();
</file>

<file path="src/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
	:root {
		--background: 222.2 84% 4.9%;
		--foreground: 210 40% 98%;
		--card: 222.2 84% 4.9%;
		--card-foreground: 210 40% 98%;
		--popover: 222.2 84% 4.9%;
		--popover-foreground: 210 40% 98%;
		--primary: 217.2 91.2% 59.8%;
		--primary-foreground: 222.2 47.4% 11.2%;
		--secondary: 217.2 32.6% 17.5%;
		--secondary-foreground: 210 40% 98%;
		--muted: 217.2 32.6% 17.5%;
		--muted-foreground: 215 20.2% 65.1%;
		--accent: 217.2 32.6% 17.5%;
		--accent-foreground: 210 40% 98%;
		--destructive: 0 62.8% 30.6%;
		--destructive-foreground: 210 40% 98%;
		--border: 217.2 32.6% 17.5%;
		--input: 217.2 32.6% 17.5%;
		--ring: 224.3 76.3% 48%;
		--radius: 0.75rem;
	}
}

@layer base {
	* {
		@apply border-border;
	}

	body {
		@apply bg-background text-foreground;
	}

	/* Custom scrollbar styles */
	::-webkit-scrollbar {
		width: 8px;
		height: 8px;
	}

	::-webkit-scrollbar-track {
		@apply bg-slate-900;
	}

	::-webkit-scrollbar-thumb {
		@apply rounded-full bg-slate-700;
	}

	::-webkit-scrollbar-thumb:hover {
		@apply bg-slate-600;
	}
}

/* Glassmorphism utilities */
@layer utilities {
	.glass {
		@apply bg-slate-900/50 backdrop-blur-xl border border-slate-800;
	}

	.glass-card {
		@apply rounded-xl bg-slate-900/50 backdrop-blur-xl border border-slate-800 shadow-xl;
	}
}

/* Animation utilities */
@layer utilities {
	.animate-glow {
		animation: glow 2s ease-in-out infinite alternate;
	}

	@keyframes glow {
		from {
			box-shadow: 0 0 5px rgb(99 102 241 / 0.5);
		}
		to {
			box-shadow: 0 0 20px rgb(99 102 241 / 0.8);
		}
	}
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import { Providers } from '@/components/providers';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
	title: 'Eigen - Modern Syncthing Manager',
	description:
		'A beautiful, modern Syncthing manager built with Tauri and Next.js',
	icons: {
		icon: [
			{ url: '/favicon.ico', sizes: '32x32' },
			{ url: '/icon-192.png', sizes: '192x192', type: 'image/png' },
			{ url: '/icon-512.png', sizes: '512x512', type: 'image/png' },
		],
		apple: '/apple-touch-icon.png',
	},
};

export default function RootLayout({
	children,
}: {
	children: React.ReactNode;
}) {
	return (
		<html lang='en' className='dark'>
			<body className={`${inter.className} bg-slate-950 antialiased`}>
				<Providers>{children}</Providers>
			</body>
		</html>
	);
}
</file>

<file path="src/app/page.tsx">
'use client';

import { Sidebar } from '@/components/sidebar';
import { Header } from '@/components/header';
import { MainContent } from '@/components/main-content';

export default function Home() {
	return (
		<div className='flex h-screen w-screen overflow-hidden bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950'>
			<Sidebar />
			<div className='flex flex-1 flex-col overflow-hidden'>
				<Header />
				<MainContent />
			</div>
		</div>
	);
}
</file>

<file path="src/components/ui/badge.tsx">
import * as React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';

const badgeVariants = cva(
	'inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
	{
		variants: {
			variant: {
				default:
					'border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80',
				secondary:
					'border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80',
				destructive:
					'border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80',
				outline: 'text-foreground',
				success:
					'border-transparent bg-emerald-500/20 text-emerald-400 shadow',
				warning:
					'border-transparent bg-amber-500/20 text-amber-400 shadow',
			},
		},
		defaultVariants: {
			variant: 'default',
		},
	}
);

export interface BadgeProps
	extends React.HTMLAttributes<HTMLDivElement>,
		VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
	return (
		<div className={cn(badgeVariants({ variant }), className)} {...props} />
	);
}

export { Badge, badgeVariants };
</file>

<file path="src/components/ui/button.tsx">
import * as React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';

const buttonVariants = cva(
	'inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0',
	{
		variants: {
			variant: {
				default:
					'bg-primary text-primary-foreground shadow hover:bg-primary/90',
				destructive:
					'bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90',
				outline:
					'border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground',
				secondary:
					'bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80',
				ghost: 'hover:bg-accent hover:text-accent-foreground',
				link: 'text-primary underline-offset-4 hover:underline',
			},
			size: {
				default: 'h-9 px-4 py-2',
				sm: 'h-8 rounded-md px-3 text-xs',
				lg: 'h-10 rounded-md px-8',
				icon: 'h-9 w-9',
			},
		},
		defaultVariants: {
			variant: 'default',
			size: 'default',
		},
	}
);

export interface ButtonProps
	extends React.ButtonHTMLAttributes<HTMLButtonElement>,
		VariantProps<typeof buttonVariants> {
	asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
	({ className, variant, size, ...props }, ref) => {
		return (
			<button
				className={cn(buttonVariants({ variant, size, className }))}
				ref={ref}
				{...props}
			/>
		);
	}
);
Button.displayName = 'Button';

export { Button, buttonVariants };
</file>

<file path="src/components/ui/card.tsx">
import * as React from 'react';
import { cn } from '@/lib/utils';

const Card = React.forwardRef<
	HTMLDivElement,
	React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
	<div
		ref={ref}
		className={cn(
			'rounded-xl border bg-card text-card-foreground shadow',
			className
		)}
		{...props}
	/>
));
Card.displayName = 'Card';

const CardHeader = React.forwardRef<
	HTMLDivElement,
	React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
	<div
		ref={ref}
		className={cn('flex flex-col space-y-1.5 p-6', className)}
		{...props}
	/>
));
CardHeader.displayName = 'CardHeader';

const CardTitle = React.forwardRef<
	HTMLParagraphElement,
	React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
	<h3
		ref={ref}
		className={cn('font-semibold leading-none tracking-tight', className)}
		{...props}
	/>
));
CardTitle.displayName = 'CardTitle';

const CardDescription = React.forwardRef<
	HTMLParagraphElement,
	React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
	<p
		ref={ref}
		className={cn('text-sm text-muted-foreground', className)}
		{...props}
	/>
));
CardDescription.displayName = 'CardDescription';

const CardContent = React.forwardRef<
	HTMLDivElement,
	React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
	<div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
));
CardContent.displayName = 'CardContent';

const CardFooter = React.forwardRef<
	HTMLDivElement,
	React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
	<div
		ref={ref}
		className={cn('flex items-center p-6 pt-0', className)}
		{...props}
	/>
));
CardFooter.displayName = 'CardFooter';

export {
	Card,
	CardHeader,
	CardFooter,
	CardTitle,
	CardDescription,
	CardContent,
};
</file>

<file path="src/components/ui/motion.tsx">
'use client';

import { motion, Variants } from 'framer-motion';
import { ReactNode } from 'react';

// Animation variants for cards
export const cardVariants: Variants = {
	hidden: {
		opacity: 0,
		y: 20,
		scale: 0.95,
	},
	visible: {
		opacity: 1,
		y: 0,
		scale: 1,
		transition: {
			type: 'spring',
			stiffness: 300,
			damping: 30,
		},
	},
	exit: {
		opacity: 0,
		y: -10,
		scale: 0.95,
		transition: {
			duration: 0.2,
		},
	},
};

// Animation variants for list items with stagger
export const listContainerVariants: Variants = {
	hidden: { opacity: 0 },
	visible: {
		opacity: 1,
		transition: {
			staggerChildren: 0.08,
			delayChildren: 0.1,
		},
	},
};

export const listItemVariants: Variants = {
	hidden: {
		opacity: 0,
		x: -20,
	},
	visible: {
		opacity: 1,
		x: 0,
		transition: {
			type: 'spring',
			stiffness: 400,
			damping: 25,
		},
	},
};

// Animation variants for page transitions
export const pageVariants: Variants = {
	hidden: {
		opacity: 0,
		y: 10,
	},
	visible: {
		opacity: 1,
		y: 0,
		transition: {
			duration: 0.3,
			ease: 'easeOut',
		},
	},
	exit: {
		opacity: 0,
		y: -10,
		transition: {
			duration: 0.2,
		},
	},
};

// Fade in animation
export const fadeInVariants: Variants = {
	hidden: { opacity: 0 },
	visible: {
		opacity: 1,
		transition: {
			duration: 0.4,
		},
	},
};

// Scale animation for buttons and interactive elements
export const scaleVariants: Variants = {
	initial: { scale: 1 },
	hover: { scale: 1.02 },
	tap: { scale: 0.98 },
};

// Animated container component for lists
interface MotionListProps {
	children: ReactNode;
	className?: string;
}

export function MotionList({ children, className }: MotionListProps) {
	return (
		<motion.div
			variants={listContainerVariants}
			initial='hidden'
			animate='visible'
			className={className}
		>
			{children}
		</motion.div>
	);
}

// Animated item for list children
interface MotionItemProps {
	children: ReactNode;
	className?: string;
}

export function MotionItem({ children, className }: MotionItemProps) {
	return (
		<motion.div variants={listItemVariants} className={className}>
			{children}
		</motion.div>
	);
}

// Animated page wrapper
interface MotionPageProps {
	children: ReactNode;
	className?: string;
}

export function MotionPage({ children, className }: MotionPageProps) {
	return (
		<motion.div
			variants={pageVariants}
			initial='hidden'
			animate='visible'
			exit='exit'
			className={className}
		>
			{children}
		</motion.div>
	);
}

// Animated card wrapper
interface MotionCardProps {
	children: ReactNode;
	className?: string;
	layoutId?: string;
}

export function MotionCard({ children, className, layoutId }: MotionCardProps) {
	return (
		<motion.div
			variants={cardVariants}
			initial='hidden'
			animate='visible'
			exit='exit'
			layoutId={layoutId}
			whileHover={{
				y: -4,
				transition: { type: 'spring', stiffness: 400, damping: 25 },
			}}
			className={className}
		>
			{children}
		</motion.div>
	);
}

// Pulse animation for status indicators
export function PulseIndicator({
	color = 'bg-emerald-500',
	size = 'sm',
}: {
	color?: string;
	size?: 'sm' | 'md' | 'lg';
}) {
	const sizes = {
		sm: 'h-2 w-2',
		md: 'h-3 w-3',
		lg: 'h-4 w-4',
	};

	return (
		<span className='relative flex'>
			<motion.span
				className={`absolute inline-flex h-full w-full rounded-full ${color} opacity-75`}
				animate={{
					scale: [1, 1.5, 1],
					opacity: [0.75, 0, 0.75],
				}}
				transition={{
					duration: 2,
					repeat: Infinity,
					ease: 'easeInOut',
				}}
			/>
			<span
				className={`relative inline-flex rounded-full ${color} ${sizes[size]}`}
			/>
		</span>
	);
}

// Export motion components for direct use
export { motion };
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from '@/lib/utils';

function Skeleton({
	className,
	...props
}: React.HTMLAttributes<HTMLDivElement>) {
	return (
		<div
			className={cn('animate-pulse rounded-md bg-primary/10', className)}
			{...props}
		/>
	);
}

export { Skeleton };
</file>

<file path="src/components/add-device-dialog.tsx">
'use client';

import { useState } from 'react';
import {
	Card,
	CardContent,
	CardHeader,
	CardTitle,
	CardDescription,
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { useDeviceId, useAddDeviceAdvanced } from '@/hooks/useSyncthing';
import {
	Copy,
	Check,
	Plus,
	X,
	QrCode,
	Loader2,
	ChevronDown,
	ChevronUp,
	Gauge,
	Network,
	Settings2,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { toast } from 'sonner';

interface AddDeviceDialogProps {
	open: boolean;
	onClose: () => void;
}

type CompressionType = 'metadata' | 'always' | 'never';

const compressionOptions: {
	value: CompressionType;
	label: string;
	description: string;
}[] = [
	{
		value: 'metadata',
		label: 'Metadata Only',
		description: 'Compress only metadata (recommended)',
	},
	{
		value: 'always',
		label: 'Always',
		description: 'Compress all data (slower, saves bandwidth)',
	},
	{
		value: 'never',
		label: 'Never',
		description: 'No compression (fastest, uses more bandwidth)',
	},
];

export function AddDeviceDialog({ open, onClose }: AddDeviceDialogProps) {
	const [remoteDeviceId, setRemoteDeviceId] = useState('');
	const [deviceName, setDeviceName] = useState('');
	const [copied, setCopied] = useState(false);
	const [showAdvanced, setShowAdvanced] = useState(false);

	// Advanced options
	const [addresses, setAddresses] = useState('dynamic');
	const [compression, setCompression] = useState<CompressionType>('metadata');
	const [introducer, setIntroducer] = useState(false);
	const [autoAcceptFolders, setAutoAcceptFolders] = useState(false);
	const [maxSendKbps, setMaxSendKbps] = useState<number>(0);
	const [maxRecvKbps, setMaxRecvKbps] = useState<number>(0);

	const { data: localDeviceId, isLoading: deviceIdLoading } = useDeviceId();
	const addDevice = useAddDeviceAdvanced();

	const handleCopyId = async () => {
		if (localDeviceId) {
			await navigator.clipboard.writeText(localDeviceId);
			setCopied(true);
			toast.success('Device ID copied to clipboard');
			setTimeout(() => setCopied(false), 2000);
		}
	};

	const handleAddDevice = async () => {
		if (!remoteDeviceId.trim()) {
			toast.error('Please enter a Device ID');
			return;
		}

		try {
			await addDevice.mutateAsync({
				deviceId: remoteDeviceId.trim().toUpperCase(),
				name: deviceName.trim() || 'Unnamed Device',
				addresses: addresses
					.split(',')
					.map((a) => a.trim())
					.filter(Boolean),
				compression,
				introducer,
				autoAcceptFolders,
				maxSendKbps: maxSendKbps > 0 ? maxSendKbps : undefined,
				maxRecvKbps: maxRecvKbps > 0 ? maxRecvKbps : undefined,
			});
			toast.success('Device added successfully');
			resetForm();
			onClose();
		} catch (error) {
			toast.error('Failed to add device');
		}
	};

	const resetForm = () => {
		setRemoteDeviceId('');
		setDeviceName('');
		setShowAdvanced(false);
		setAddresses('dynamic');
		setCompression('metadata');
		setIntroducer(false);
		setAutoAcceptFolders(false);
		setMaxSendKbps(0);
		setMaxRecvKbps(0);
	};

	if (!open) return null;

	return (
		<div className='fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm'>
			<Card className='w-full max-w-lg border-slate-700 bg-slate-900 shadow-2xl'>
				<CardHeader className='relative'>
					<Button
						variant='ghost'
						size='icon'
						onClick={onClose}
						className='absolute right-4 top-4 text-slate-400 hover:text-white'
					>
						<X className='h-4 w-4' />
					</Button>
					<CardTitle className='text-xl text-white'>
						Connect a Device
					</CardTitle>
					<CardDescription className='text-slate-400'>
						Share your Device ID with another device, or enter their
						Device ID to connect.
					</CardDescription>
				</CardHeader>
				<CardContent className='space-y-6'>
					{/* Your Device ID Section */}
					<div className='space-y-3'>
						<label className='text-sm font-medium text-slate-300'>
							Your Device ID
						</label>
						<p className='text-xs text-slate-500'>
							Share this ID with other devices you want to connect
							to.
						</p>
						<div className='flex gap-2'>
							<div
								className={cn(
									'flex-1 rounded-lg border border-slate-700 bg-slate-800 p-3',
									'font-mono text-xs text-slate-300 break-all'
								)}
							>
								{deviceIdLoading ? (
									<span className='text-slate-500'>
										Loading...
									</span>
								) : (
									localDeviceId || 'Unable to get Device ID'
								)}
							</div>
							<Button
								variant='outline'
								size='icon'
								onClick={handleCopyId}
								disabled={!localDeviceId}
								className='shrink-0 border-slate-700 bg-slate-800 hover:bg-slate-700'
							>
								{copied ? (
									<Check className='h-4 w-4 text-emerald-400' />
								) : (
									<Copy className='h-4 w-4' />
								)}
							</Button>
						</div>
					</div>

					<div className='relative'>
						<div className='absolute inset-0 flex items-center'>
							<span className='w-full border-t border-slate-700' />
						</div>
						<div className='relative flex justify-center text-xs uppercase'>
							<span className='bg-slate-900 px-2 text-slate-500'>
								Add Remote Device
							</span>
						</div>
					</div>

					{/* Add Remote Device Section */}
					<div className='space-y-4'>
						<div className='space-y-2'>
							<label className='text-sm font-medium text-slate-300'>
								Remote Device ID
							</label>
							<input
								type='text'
								value={remoteDeviceId}
								onChange={(e) =>
									setRemoteDeviceId(e.target.value)
								}
								placeholder='XXXXXXX-XXXXXXX-XXXXXXX-XXXXXXX-XXXXXXX-XXXXXXX-XXXXXXX-XXXXXXX'
								className={cn(
									'w-full rounded-lg border border-slate-700 bg-slate-800 px-3 py-2',
									'font-mono text-sm text-white placeholder:text-slate-600',
									'focus:border-violet-500 focus:outline-none focus:ring-1 focus:ring-violet-500'
								)}
							/>
						</div>
						<div className='space-y-2'>
							<label className='text-sm font-medium text-slate-300'>
								Device Name{' '}
								<span className='text-slate-500'>
									(optional)
								</span>
							</label>
							<input
								type='text'
								value={deviceName}
								onChange={(e) => setDeviceName(e.target.value)}
								placeholder='e.g., My Laptop, Phone, etc.'
								className={cn(
									'w-full rounded-lg border border-slate-700 bg-slate-800 px-3 py-2',
									'text-sm text-white placeholder:text-slate-600',
									'focus:border-violet-500 focus:outline-none focus:ring-1 focus:ring-violet-500'
								)}
							/>
						</div>
					</div>

					{/* Advanced Options Toggle */}
					<button
						type='button'
						onClick={() => setShowAdvanced(!showAdvanced)}
						className='flex items-center gap-2 text-sm text-slate-400 hover:text-slate-300 transition-colors'
					>
						<Settings2 className='h-4 w-4' />
						Advanced Settings
						{showAdvanced ? (
							<ChevronUp className='h-4 w-4' />
						) : (
							<ChevronDown className='h-4 w-4' />
						)}
					</button>

					{/* Advanced Options */}
					{showAdvanced && (
						<div className='space-y-4 p-4 rounded-lg border border-slate-700 bg-slate-800/50'>
							{/* Addresses */}
							<div className='space-y-2'>
								<label className='text-sm font-medium text-slate-300 flex items-center gap-2'>
									<Network className='h-4 w-4' />
									Addresses
								</label>
								<input
									type='text'
									value={addresses}
									onChange={(e) =>
										setAddresses(e.target.value)
									}
									placeholder='dynamic, tcp://hostname:port'
									className={cn(
										'w-full rounded-lg border border-slate-700 bg-slate-800 px-3 py-2',
										'text-sm text-white placeholder:text-slate-600',
										'focus:border-violet-500 focus:outline-none focus:ring-1 focus:ring-violet-500'
									)}
								/>
								<p className='text-xs text-slate-500'>
									Use "dynamic" for auto-discovery, or specify
									addresses like tcp://hostname:22000
								</p>
							</div>

							{/* Compression */}
							<div className='space-y-2'>
								<label className='text-sm font-medium text-slate-300'>
									Compression
								</label>
								<div className='grid grid-cols-3 gap-2'>
									{compressionOptions.map((option) => (
										<button
											key={option.value}
											type='button'
											onClick={() =>
												setCompression(option.value)
											}
											className={cn(
												'p-2 rounded-lg border text-left transition-all',
												compression === option.value
													? 'border-violet-500 bg-violet-500/20 text-violet-300'
													: 'border-slate-700 bg-slate-800 text-slate-400 hover:border-slate-600'
											)}
										>
											<div className='text-sm font-medium'>
												{option.label}
											</div>
										</button>
									))}
								</div>
							</div>

							{/* Rate Limits */}
							<div className='grid grid-cols-2 gap-4'>
								<div className='space-y-2'>
									<label className='text-sm font-medium text-slate-300 flex items-center gap-2'>
										<Gauge className='h-4 w-4' />
										Upload Limit (KB/s)
									</label>
									<input
										type='number'
										value={maxSendKbps || ''}
										onChange={(e) =>
											setMaxSendKbps(
												parseInt(e.target.value) || 0
											)
										}
										placeholder='0 = unlimited'
										min={0}
										className={cn(
											'w-full rounded-lg border border-slate-700 bg-slate-800 px-3 py-2',
											'text-sm text-white placeholder:text-slate-600',
											'focus:border-violet-500 focus:outline-none focus:ring-1 focus:ring-violet-500'
										)}
									/>
								</div>
								<div className='space-y-2'>
									<label className='text-sm font-medium text-slate-300 flex items-center gap-2'>
										<Gauge className='h-4 w-4' />
										Download Limit (KB/s)
									</label>
									<input
										type='number'
										value={maxRecvKbps || ''}
										onChange={(e) =>
											setMaxRecvKbps(
												parseInt(e.target.value) || 0
											)
										}
										placeholder='0 = unlimited'
										min={0}
										className={cn(
											'w-full rounded-lg border border-slate-700 bg-slate-800 px-3 py-2',
											'text-sm text-white placeholder:text-slate-600',
											'focus:border-violet-500 focus:outline-none focus:ring-1 focus:ring-violet-500'
										)}
									/>
								</div>
							</div>

							{/* Introducer & Auto-accept */}
							<div className='space-y-3'>
								<label className='flex items-center gap-3 cursor-pointer'>
									<input
										type='checkbox'
										checked={introducer}
										onChange={(e) =>
											setIntroducer(e.target.checked)
										}
										className='rounded border-slate-600 bg-slate-800 text-violet-500 focus:ring-violet-500'
									/>
									<div>
										<div className='text-sm font-medium text-slate-300'>
											Introducer
										</div>
										<div className='text-xs text-slate-500'>
											This device can introduce us to
											other devices
										</div>
									</div>
								</label>
								<label className='flex items-center gap-3 cursor-pointer'>
									<input
										type='checkbox'
										checked={autoAcceptFolders}
										onChange={(e) =>
											setAutoAcceptFolders(
												e.target.checked
											)
										}
										className='rounded border-slate-600 bg-slate-800 text-violet-500 focus:ring-violet-500'
									/>
									<div>
										<div className='text-sm font-medium text-slate-300'>
											Auto-accept Folders
										</div>
										<div className='text-xs text-slate-500'>
											Automatically accept folder share
											invitations from this device
										</div>
									</div>
								</label>
							</div>
						</div>
					)}

					<div className='flex justify-end gap-3 pt-2'>
						<Button
							variant='outline'
							onClick={onClose}
							className='border-slate-700 bg-transparent hover:bg-slate-800'
						>
							Cancel
						</Button>
						<Button
							onClick={handleAddDevice}
							disabled={
								!remoteDeviceId.trim() || addDevice.isPending
							}
							className='bg-violet-600 hover:bg-violet-700'
						>
							{addDevice.isPending ? (
								<>
									<Loader2 className='mr-2 h-4 w-4 animate-spin' />
									Adding...
								</>
							) : (
								<>
									<Plus className='mr-2 h-4 w-4' />
									Add Device
								</>
							)}
						</Button>
					</div>
				</CardContent>
			</Card>
		</div>
	);
}

export function MyDeviceId() {
	const { data: localDeviceId, isLoading } = useDeviceId();
	const [copied, setCopied] = useState(false);

	const handleCopy = async () => {
		if (localDeviceId) {
			await navigator.clipboard.writeText(localDeviceId);
			setCopied(true);
			toast.success('Device ID copied to clipboard');
			setTimeout(() => setCopied(false), 2000);
		}
	};

	return (
		<Card className='border-slate-800 bg-slate-900/50 backdrop-blur-md'>
			<CardHeader className='pb-3'>
				<div className='flex items-center justify-between'>
					<div>
						<CardTitle className='text-lg text-white'>
							This Device
						</CardTitle>
						<CardDescription className='text-slate-500'>
							Share this ID to connect other devices
						</CardDescription>
					</div>
					<div className='flex items-center gap-2'>
						<QrCode className='h-5 w-5 text-slate-500' />
					</div>
				</div>
			</CardHeader>
			<CardContent>
				<div className='flex gap-2'>
					<div className='flex-1 rounded-lg border border-slate-700 bg-slate-800 p-3 font-mono text-xs text-slate-300 break-all'>
						{isLoading ? (
							<span className='text-slate-500'>Loading...</span>
						) : (
							localDeviceId || 'Unable to get Device ID'
						)}
					</div>
					<Button
						variant='outline'
						size='icon'
						onClick={handleCopy}
						disabled={!localDeviceId}
						className='shrink-0 border-slate-700 bg-slate-800 hover:bg-slate-700'
					>
						{copied ? (
							<Check className='h-4 w-4 text-emerald-400' />
						) : (
							<Copy className='h-4 w-4' />
						)}
					</Button>
				</div>
			</CardContent>
		</Card>
	);
}
</file>

<file path="src/components/add-folder-dialog.tsx">
'use client';

import { useState } from 'react';
import { useAddFolderAdvanced } from '@/hooks/useSyncthing';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
	FolderPlus,
	X,
	ChevronDown,
	ChevronUp,
	History,
	Clock,
	Trash2,
	Terminal,
	FolderOpen,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { toast } from 'sonner';
import { open as openDialog } from '@tauri-apps/plugin-dialog';

interface AddFolderDialogProps {
	open: boolean;
	onOpenChange: (open: boolean) => void;
}

type VersioningType = '' | 'simple' | 'staggered' | 'trashcan' | 'external';

const versioningOptions = [
	{
		value: '' as VersioningType,
		label: 'No Versioning',
		description: 'Deleted or modified files are not preserved',
		icon: X,
	},
	{
		value: 'simple' as VersioningType,
		label: 'Simple',
		description: 'Keep a specified number of old versions',
		icon: History,
	},
	{
		value: 'staggered' as VersioningType,
		label: 'Staggered',
		description: 'Smart versioning: more frequent recent, sparse older',
		icon: Clock,
	},
	{
		value: 'trashcan' as VersioningType,
		label: 'Trash Can',
		description: 'Move deleted files to .stversions folder',
		icon: Trash2,
	},
	{
		value: 'external' as VersioningType,
		label: 'External',
		description: 'Use an external command for versioning',
		icon: Terminal,
	},
];

export function AddFolderDialog({ open, onOpenChange }: AddFolderDialogProps) {
	const [folderId, setFolderId] = useState('');
	const [folderLabel, setFolderLabel] = useState('');
	const [folderPath, setFolderPath] = useState('');
	const [showAdvanced, setShowAdvanced] = useState(false);
	const [versioning, setVersioning] = useState<{
		type: VersioningType;
		params: Record<string, string>;
	}>({ type: '', params: {} });
	const [rescanInterval, setRescanInterval] = useState(3600);
	const [fsWatcherEnabled, setFsWatcherEnabled] = useState(true);
	const [fsWatcherDelay, setFsWatcherDelay] = useState(10);
	const [ignorePerms, setIgnorePerms] = useState(false);

	const addFolder = useAddFolderAdvanced();

	const handleSubmit = async (e: React.FormEvent) => {
		e.preventDefault();
		if (!folderId.trim()) {
			toast.error('Folder ID is required');
			return;
		}
		if (!folderPath.trim()) {
			toast.error('Folder path is required');
			return;
		}

		try {
			await addFolder.mutateAsync({
				folderId: folderId.trim(),
				folderLabel: folderLabel.trim() || folderId.trim(),
				folderPath: folderPath.trim(),
				versioningType: versioning.type || undefined,
				versioningParams:
					Object.keys(versioning.params).length > 0
						? versioning.params
						: undefined,
				rescanIntervalS: rescanInterval,
				fsWatcherEnabled,
				fsWatcherDelayS: fsWatcherDelay,
				ignorePerms,
			});
			toast.success('Folder added successfully');
			handleClose();
		} catch (err) {
			toast.error('Failed to add folder');
		}
	};

	const handleClose = () => {
		setFolderId('');
		setFolderLabel('');
		setFolderPath('');
		setShowAdvanced(false);
		setVersioning({ type: '', params: {} });
		setRescanInterval(3600);
		setFsWatcherEnabled(true);
		setFsWatcherDelay(10);
		setIgnorePerms(false);
		onOpenChange(false);
	};

	const updateVersioningType = (type: VersioningType) => {
		const defaultParams: Record<VersioningType, Record<string, string>> = {
			'': {},
			simple: { keep: '5' },
			staggered: { maxAge: '31536000' },
			trashcan: { cleanoutDays: '0' },
			external: { command: '' },
		};
		setVersioning({ type, params: defaultParams[type] });
	};

	if (!open) return null;

	return (
		<div className='fixed inset-0 z-50 flex items-center justify-center py-8'>
			<div
				className='absolute inset-0 bg-black/60 backdrop-blur-sm'
				onClick={handleClose}
			/>
			<Card className='relative z-10 w-full max-w-lg border-slate-700 bg-slate-900/95 backdrop-blur mx-4 max-h-[90vh] overflow-y-auto'>
				<CardHeader className='pb-4'>
					<div className='flex items-center justify-between'>
						<div className='flex items-center gap-3'>
							<div className='flex h-10 w-10 items-center justify-center rounded-lg bg-indigo-500/20'>
								<FolderPlus className='h-5 w-5 text-indigo-400' />
							</div>
							<div>
								<CardTitle className='text-white'>
									Add Folder
								</CardTitle>
								<p className='text-sm text-slate-400'>
									Share a folder with your devices
								</p>
							</div>
						</div>
						<Button
							variant='ghost'
							size='sm'
							onClick={handleClose}
							className='text-slate-400 hover:text-white'
						>
							<X className='h-4 w-4' />
						</Button>
					</div>
				</CardHeader>
				<CardContent>
					<form onSubmit={handleSubmit} className='space-y-4'>
						<div className='space-y-2'>
							<label className='text-sm font-medium text-slate-300'>
								Folder ID *
							</label>
							<input
								type='text'
								value={folderId}
								onChange={(e) => setFolderId(e.target.value)}
								placeholder='my-folder'
								className='w-full rounded-lg border border-slate-700 bg-slate-800 px-3 py-2 text-white placeholder:text-slate-500 focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500'
							/>
							<p className='text-xs text-slate-500'>
								Unique identifier for this folder
							</p>
						</div>

						<div className='space-y-2'>
							<label className='text-sm font-medium text-slate-300'>
								Label
							</label>
							<input
								type='text'
								value={folderLabel}
								onChange={(e) => setFolderLabel(e.target.value)}
								placeholder='My Folder'
								className='w-full rounded-lg border border-slate-700 bg-slate-800 px-3 py-2 text-white placeholder:text-slate-500 focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500'
							/>
							<p className='text-xs text-slate-500'>
								Human-readable name (optional)
							</p>
						</div>

						<div className='space-y-2'>
							<label className='text-sm font-medium text-slate-300'>
								Path *
							</label>
							<div className='flex gap-2'>
								<input
									type='text'
									value={folderPath}
									onChange={(e) =>
										setFolderPath(e.target.value)
									}
									placeholder='/home/user/sync-folder'
									className='flex-1 rounded-lg border border-slate-700 bg-slate-800 px-3 py-2 font-mono text-sm text-white placeholder:text-slate-500 focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500'
								/>
								<Button
									type='button'
									variant='outline'
									onClick={async () => {
										try {
											const selected = await openDialog({
												directory: true,
												multiple: false,
												title: 'Select Folder to Sync',
											});
											if (selected) {
												setFolderPath(
													selected as string
												);
											}
										} catch (err) {
											console.error(
												'Failed to open folder picker:',
												err
											);
										}
									}}
									className='border-slate-700 bg-slate-800 text-slate-300 hover:bg-slate-700 hover:text-white'
								>
									<FolderOpen className='h-4 w-4' />
								</Button>
							</div>
							<p className='text-xs text-slate-500'>
								Absolute path to the folder
							</p>
						</div>

						<Button
							type='button'
							variant='ghost'
							onClick={() => setShowAdvanced(!showAdvanced)}
							className='w-full justify-between text-slate-300 hover:text-white'
						>
							<span>Advanced Options</span>
							{showAdvanced ? (
								<ChevronUp className='h-4 w-4' />
							) : (
								<ChevronDown className='h-4 w-4' />
							)}
						</Button>

						{showAdvanced && (
							<div className='space-y-4 rounded-lg border border-slate-700 bg-slate-800/50 p-4'>
								<div className='space-y-2'>
									<label className='text-sm font-medium text-slate-300'>
										File Versioning
									</label>
									<div className='grid gap-2'>
										{versioningOptions.map((option) => {
											const Icon = option.icon;
											return (
												<button
													key={option.value}
													type='button'
													onClick={() =>
														updateVersioningType(
															option.value
														)
													}
													className={cn(
														'flex items-start gap-3 rounded-lg border p-3 text-left transition-colors',
														versioning.type ===
															option.value
															? 'border-indigo-500 bg-indigo-500/10'
															: 'border-slate-700 hover:border-slate-600'
													)}
												>
													<Icon
														className={cn(
															'h-4 w-4 mt-0.5',
															versioning.type ===
																option.value
																? 'text-indigo-400'
																: 'text-slate-500'
														)}
													/>
													<div>
														<p
															className={cn(
																'text-sm font-medium',
																versioning.type ===
																	option.value
																	? 'text-white'
																	: 'text-slate-300'
															)}
														>
															{option.label}
														</p>
														<p className='text-xs text-slate-500'>
															{option.description}
														</p>
													</div>
												</button>
											);
										})}
									</div>
								</div>

								{versioning.type === 'simple' && (
									<div className='space-y-2 pl-6'>
										<label className='text-sm text-slate-400'>
											Versions to keep
										</label>
										<input
											type='number'
											min='1'
											value={
												versioning.params.keep || '5'
											}
											onChange={(e) =>
												setVersioning({
													...versioning,
													params: {
														keep: e.target.value,
													},
												})
											}
											className='w-full rounded border border-slate-700 bg-slate-800 px-3 py-2 text-white'
										/>
									</div>
								)}

								{versioning.type === 'staggered' && (
									<div className='space-y-2 pl-6'>
										<label className='text-sm text-slate-400'>
											Max age (seconds)
										</label>
										<select
											value={
												versioning.params.maxAge ||
												'31536000'
											}
											onChange={(e) =>
												setVersioning({
													...versioning,
													params: {
														maxAge: e.target.value,
													},
												})
											}
											className='w-full rounded border border-slate-700 bg-slate-800 px-3 py-2 text-white'
										>
											<option value='86400'>1 day</option>
											<option value='604800'>
												1 week
											</option>
											<option value='2592000'>
												30 days
											</option>
											<option value='31536000'>
												1 year
											</option>
											<option value='0'>Forever</option>
										</select>
									</div>
								)}

								{versioning.type === 'trashcan' && (
									<div className='space-y-2 pl-6'>
										<label className='text-sm text-slate-400'>
											Clean out after (days, 0 = never)
										</label>
										<input
											type='number'
											min='0'
											value={
												versioning.params
													.cleanoutDays || '0'
											}
											onChange={(e) =>
												setVersioning({
													...versioning,
													params: {
														cleanoutDays:
															e.target.value,
													},
												})
											}
											className='w-full rounded border border-slate-700 bg-slate-800 px-3 py-2 text-white'
										/>
									</div>
								)}

								{versioning.type === 'external' && (
									<div className='space-y-2 pl-6'>
										<label className='text-sm text-slate-400'>
											Command
										</label>
										<input
											type='text'
											value={
												versioning.params.command || ''
											}
											onChange={(e) =>
												setVersioning({
													...versioning,
													params: {
														command: e.target.value,
													},
												})
											}
											placeholder='/path/to/command %FOLDER_PATH% %FILE_PATH%'
											className='w-full rounded border border-slate-700 bg-slate-800 px-3 py-2 font-mono text-sm text-white'
										/>
									</div>
								)}

								<div className='space-y-2'>
									<label className='text-sm font-medium text-slate-300'>
										Rescan Interval
									</label>
									<select
										value={rescanInterval}
										onChange={(e) =>
											setRescanInterval(
												parseInt(e.target.value)
											)
										}
										className='w-full rounded border border-slate-700 bg-slate-800 px-3 py-2 text-white'
									>
										<option value={60}>1 minute</option>
										<option value={300}>5 minutes</option>
										<option value={900}>15 minutes</option>
										<option value={3600}>1 hour</option>
										<option value={86400}>24 hours</option>
									</select>
								</div>

								<div className='space-y-3'>
									<label className='flex items-center gap-3'>
										<input
											type='checkbox'
											checked={fsWatcherEnabled}
											onChange={(e) =>
												setFsWatcherEnabled(
													e.target.checked
												)
											}
											className='h-4 w-4 rounded border-slate-600 bg-slate-800 text-indigo-500'
										/>
										<div>
											<span className='text-sm text-slate-300'>
												Enable File Watcher
											</span>
											<p className='text-xs text-slate-500'>
												Detect changes immediately
											</p>
										</div>
									</label>

									<label className='flex items-center gap-3'>
										<input
											type='checkbox'
											checked={ignorePerms}
											onChange={(e) =>
												setIgnorePerms(e.target.checked)
											}
											className='h-4 w-4 rounded border-slate-600 bg-slate-800 text-indigo-500'
										/>
										<div>
											<span className='text-sm text-slate-300'>
												Ignore Permissions
											</span>
											<p className='text-xs text-slate-500'>
												Useful for FAT/NTFS filesystems
											</p>
										</div>
									</label>
								</div>
							</div>
						)}

						<div className='flex gap-3 pt-4'>
							<Button
								type='button'
								variant='outline'
								onClick={handleClose}
								className='flex-1 border-slate-700 text-slate-300 hover:bg-slate-800'
							>
								Cancel
							</Button>
							<Button
								type='submit'
								disabled={addFolder.isPending}
								className='flex-1 bg-indigo-600 hover:bg-indigo-700'
							>
								{addFolder.isPending
									? 'Adding...'
									: 'Add Folder'}
							</Button>
						</div>
					</form>
				</CardContent>
			</Card>
		</div>
	);
}
</file>

<file path="src/components/ai-search-bar.tsx">
'use client';

/**
 * AISearchBar - Semantic file search component powered by transformers.js
 */

import { useState, useCallback, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
	Search,
	Sparkles,
	Loader2,
	Brain,
	X,
	FileText,
	Folder,
	AlertCircle,
} from 'lucide-react';
import { useAISearch, type AIStatus } from '@/hooks/useAISearch';
import { useAppStore } from '@/store';
import { cn } from '@/lib/utils';

interface SearchResult {
	path: string;
	score: number;
}

interface AISearchBarProps {
	onResultSelect?: (path: string) => void;
	className?: string;
}

export function AISearchBar({ onResultSelect, className }: AISearchBarProps) {
	const [query, setQuery] = useState('');
	const [results, setResults] = useState<SearchResult[]>([]);
	const [isSearching, setIsSearching] = useState(false);
	const [showResults, setShowResults] = useState(false);
	const [selectedIndex, setSelectedIndex] = useState(0);
	const inputRef = useRef<HTMLInputElement>(null);
	const resultsRef = useRef<HTMLDivElement>(null);

	const aiEnabled = useAppStore((state) => state.aiEnabled);
	const { status, statusMessage, isReady, initialize, search, progress } =
		useAISearch({ enabled: aiEnabled });

	// Initialize AI model when component mounts (only if enabled)
	useEffect(() => {
		if (aiEnabled && status === 'idle') {
			initialize();
		}
	}, [aiEnabled, status, initialize]);

	// Search with debounce
	useEffect(() => {
		if (!aiEnabled || !query.trim() || !isReady) {
			setResults([]);
			return;
		}

		const timer = setTimeout(async () => {
			setIsSearching(true);
			try {
				const searchResults = await search(query);
				setResults(searchResults);
				setSelectedIndex(0);
			} catch (error) {
				console.error('Search error:', error);
			} finally {
				setIsSearching(false);
			}
		}, 300);

		return () => clearTimeout(timer);
	}, [query, isReady, search]);

	// Keyboard navigation
	const handleKeyDown = useCallback(
		(e: React.KeyboardEvent) => {
			if (!showResults || results.length === 0) return;

			switch (e.key) {
				case 'ArrowDown':
					e.preventDefault();
					setSelectedIndex((i) =>
						Math.min(i + 1, results.length - 1)
					);
					break;
				case 'ArrowUp':
					e.preventDefault();
					setSelectedIndex((i) => Math.max(i - 1, 0));
					break;
				case 'Enter':
					e.preventDefault();
					if (results[selectedIndex]) {
						onResultSelect?.(results[selectedIndex].path);
						setShowResults(false);
						setQuery('');
					}
					break;
				case 'Escape':
					e.preventDefault();
					setShowResults(false);
					break;
			}
		},
		[showResults, results, selectedIndex, onResultSelect]
	);

	// Close results when clicking outside
	useEffect(() => {
		const handleClickOutside = (e: MouseEvent) => {
			if (
				resultsRef.current &&
				!resultsRef.current.contains(e.target as Node) &&
				inputRef.current &&
				!inputRef.current.contains(e.target as Node)
			) {
				setShowResults(false);
			}
		};

		document.addEventListener('mousedown', handleClickOutside);
		return () =>
			document.removeEventListener('mousedown', handleClickOutside);
	}, []);

	const getStatusIcon = () => {
		switch (status) {
			case 'loading':
				return (
					<Loader2 className='h-4 w-4 animate-spin text-primary' />
				);
			case 'ready':
				return <Sparkles className='h-4 w-4 text-primary' />;
			case 'error':
				return <AlertCircle className='h-4 w-4 text-destructive' />;
			case 'disabled':
				return <Brain className='h-4 w-4 text-muted-foreground/50' />;
			default:
				return <Brain className='h-4 w-4 text-muted-foreground' />;
		}
	};

	const getFileName = (path: string) => {
		const parts = path.split('/');
		return parts[parts.length - 1];
	};

	const getParentPath = (path: string) => {
		const parts = path.split('/');
		return parts.slice(0, -1).join('/');
	};

	return (
		<div className={cn('relative', className)}>
			{/* Search Input */}
			<div className='relative'>
				<Search className='absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground' />
				<input
					ref={inputRef}
					type='text'
					value={query}
					onChange={(e) => {
						setQuery(e.target.value);
						setShowResults(true);
					}}
					onFocus={() => setShowResults(true)}
					onKeyDown={handleKeyDown}
					placeholder={
						!aiEnabled
							? 'AI search disabled'
							: isReady
							? 'Search files semantically...'
							: 'Loading AI model...'
					}
					disabled={status === 'loading' || status === 'disabled'}
					className={cn(
						'w-full pl-10 pr-20 py-2 rounded-lg',
						'bg-muted/50 border border-border',
						'text-sm placeholder:text-muted-foreground',
						'focus:outline-none focus:ring-2 focus:ring-primary/20 focus:border-primary',
						'disabled:opacity-50 disabled:cursor-not-allowed',
						'transition-all duration-200'
					)}
				/>

				{/* Status indicator */}
				<div className='absolute right-3 top-1/2 -translate-y-1/2 flex items-center gap-2'>
					{isSearching && (
						<Loader2 className='h-4 w-4 animate-spin' />
					)}
					{query && (
						<button
							onClick={() => {
								setQuery('');
								setResults([]);
							}}
							className='p-1 hover:bg-muted rounded'
						>
							<X className='h-3 w-3' />
						</button>
					)}
					{getStatusIcon()}
				</div>
			</div>

			{/* Status message during loading */}
			{status === 'loading' && (
				<motion.div
					initial={{ opacity: 0, y: -10 }}
					animate={{ opacity: 1, y: 0 }}
					className='absolute top-full left-0 right-0 mt-2 p-3 bg-card border border-border rounded-lg shadow-lg'
				>
					<div className='flex items-center gap-3'>
						<Loader2 className='h-5 w-5 animate-spin text-primary' />
						<div>
							<p className='text-sm font-medium'>
								Loading AI Model
							</p>
							<p className='text-xs text-muted-foreground'>
								{statusMessage}
							</p>
						</div>
					</div>
					{progress && (
						<div className='mt-2'>
							<div className='h-1 bg-muted rounded-full overflow-hidden'>
								<motion.div
									className='h-full bg-primary'
									initial={{ width: 0 }}
									animate={{
										width: `${
											(progress.current /
												progress.total) *
											100
										}%`,
									}}
								/>
							</div>
						</div>
					)}
				</motion.div>
			)}

			{/* Search Results */}
			<AnimatePresence>
				{showResults && results.length > 0 && (
					<motion.div
						ref={resultsRef}
						initial={{ opacity: 0, y: -10 }}
						animate={{ opacity: 1, y: 0 }}
						exit={{ opacity: 0, y: -10 }}
						className='absolute top-full left-0 right-0 mt-2 bg-card border border-border rounded-lg shadow-lg max-h-[400px] overflow-y-auto z-50'
					>
						<div className='p-2'>
							<p className='text-xs text-muted-foreground px-2 py-1'>
								{results.length} results  Powered by AI
							</p>
						</div>
						<div className='border-t border-border'>
							{results.map((result, index) => (
								<motion.button
									key={result.path}
									initial={{ opacity: 0, x: -10 }}
									animate={{ opacity: 1, x: 0 }}
									transition={{ delay: index * 0.05 }}
									onClick={() => {
										onResultSelect?.(result.path);
										setShowResults(false);
										setQuery('');
									}}
									className={cn(
										'w-full px-4 py-3 flex items-start gap-3 text-left',
										'hover:bg-muted/50 transition-colors',
										index === selectedIndex && 'bg-muted'
									)}
								>
									<FileText className='h-5 w-5 text-muted-foreground shrink-0 mt-0.5' />
									<div className='flex-1 min-w-0'>
										<p className='text-sm font-medium truncate'>
											{getFileName(result.path)}
										</p>
										<p className='text-xs text-muted-foreground truncate'>
											{getParentPath(result.path)}
										</p>
									</div>
									<div className='shrink-0'>
										<span className='text-xs px-2 py-1 rounded bg-primary/10 text-primary'>
											{Math.round(result.score * 100)}%
										</span>
									</div>
								</motion.button>
							))}
						</div>
					</motion.div>
				)}
			</AnimatePresence>

			{/* No results */}
			<AnimatePresence>
				{showResults &&
					query &&
					!isSearching &&
					results.length === 0 &&
					isReady && (
						<motion.div
							initial={{ opacity: 0, y: -10 }}
							animate={{ opacity: 1, y: 0 }}
							exit={{ opacity: 0, y: -10 }}
							className='absolute top-full left-0 right-0 mt-2 p-6 bg-card border border-border rounded-lg shadow-lg text-center'
						>
							<Search className='h-8 w-8 text-muted-foreground mx-auto mb-2' />
							<p className='text-sm text-muted-foreground'>
								No files found
							</p>
							<p className='text-xs text-muted-foreground mt-1'>
								Try indexing your files first
							</p>
						</motion.div>
					)}
			</AnimatePresence>
		</div>
	);
}
</file>

<file path="src/components/conflict-resolver.tsx">
'use client';

import { useState } from 'react';
import {
	useScanConflicts,
	useDeleteConflict,
	useResolveConflictKeepConflict,
	ConflictFile,
} from '@/hooks/useSyncthing';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
	AlertTriangle,
	X,
	RefreshCw,
	Trash2,
	Check,
	FileWarning,
	File,
	Clock,
	HardDrive,
} from 'lucide-react';
import { cn, formatBytes } from '@/lib/utils';
import { toast } from 'sonner';

interface ConflictResolverProps {
	open: boolean;
	onOpenChange: (open: boolean) => void;
	folderId: string;
	folderPath: string;
	folderLabel?: string;
}

function formatDate(timestamp?: number): string {
	if (!timestamp) return 'Unknown';
	try {
		return new Date(timestamp * 1000).toLocaleDateString(undefined, {
			year: 'numeric',
			month: 'short',
			day: 'numeric',
			hour: '2-digit',
			minute: '2-digit',
		});
	} catch {
		return 'Unknown';
	}
}

function ConflictCard({
	conflict,
	folderPath,
	onResolve,
}: {
	conflict: ConflictFile;
	folderPath: string;
	onResolve: () => void;
}) {
	const deleteConflict = useDeleteConflict();
	const keepConflict = useResolveConflictKeepConflict();
	const [isResolving, setIsResolving] = useState(false);

	const handleKeepOriginal = async () => {
		setIsResolving(true);
		try {
			await deleteConflict.mutateAsync({
				folderPath,
				conflictFile: conflict.name,
			});
			toast.success('Conflict resolved - kept original file');
			onResolve();
		} catch (error) {
			toast.error('Failed to resolve conflict');
		} finally {
			setIsResolving(false);
		}
	};

	const handleKeepConflict = async () => {
		setIsResolving(true);
		try {
			await keepConflict.mutateAsync({
				folderPath,
				originalFile: conflict.original,
				conflictFile: conflict.name,
			});
			toast.success('Conflict resolved - kept newer version');
			onResolve();
		} catch (error) {
			toast.error('Failed to resolve conflict');
		} finally {
			setIsResolving(false);
		}
	};

	return (
		<div className='rounded-lg border border-amber-500/30 bg-amber-500/5 p-4'>
			<div className='flex items-start gap-3'>
				<div className='flex h-10 w-10 shrink-0 items-center justify-center rounded-lg bg-amber-500/20'>
					<FileWarning className='h-5 w-5 text-amber-400' />
				</div>
				<div className='min-w-0 flex-1'>
					<div className='flex items-start justify-between gap-2'>
						<div className='min-w-0'>
							<p className='truncate font-medium text-white'>
								{conflict.original}
							</p>
							<p className='mt-1 truncate text-xs text-slate-400'>
								Conflict: {conflict.name}
							</p>
						</div>
					</div>

					<div className='mt-3 flex flex-wrap items-center gap-4 text-xs text-slate-400'>
						<span className='flex items-center gap-1'>
							<HardDrive className='h-3 w-3' />
							{formatBytes(conflict.size)}
						</span>
						{conflict.modTime && (
							<span className='flex items-center gap-1'>
								<Clock className='h-3 w-3' />
								{formatDate(conflict.modTime)}
							</span>
						)}
					</div>

					<div className='mt-4 flex flex-wrap gap-2'>
						<Button
							variant='outline'
							size='sm'
							onClick={handleKeepOriginal}
							disabled={isResolving}
							className='border-red-500/30 bg-red-500/10 text-red-400 hover:bg-red-500/20'
						>
							{isResolving ? (
								<RefreshCw className='mr-1 h-3 w-3 animate-spin' />
							) : (
								<Trash2 className='mr-1 h-3 w-3' />
							)}
							Keep Original
						</Button>
						<Button
							variant='outline'
							size='sm'
							onClick={handleKeepConflict}
							disabled={isResolving}
							className='border-emerald-500/30 bg-emerald-500/10 text-emerald-400 hover:bg-emerald-500/20'
						>
							{isResolving ? (
								<RefreshCw className='mr-1 h-3 w-3 animate-spin' />
							) : (
								<Check className='mr-1 h-3 w-3' />
							)}
							Keep This Version
						</Button>
					</div>
				</div>
			</div>
		</div>
	);
}

export function ConflictResolver({
	open,
	onOpenChange,
	folderId,
	folderPath,
	folderLabel,
}: ConflictResolverProps) {
	const {
		data: conflicts,
		isLoading,
		refetch,
		isRefetching,
	} = useScanConflicts(folderPath);

	if (!open) return null;

	const conflictList = conflicts || [];

	return (
		<div className='fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm'>
			<Card className='w-full max-w-2xl max-h-[80vh] flex flex-col bg-background/95 backdrop-blur-md border-border/50'>
				<CardHeader className='flex flex-row items-center justify-between space-y-0 pb-4 border-b border-border/50'>
					<CardTitle className='text-xl font-semibold flex items-center gap-2'>
						<AlertTriangle className='h-5 w-5 text-amber-400' />
						Conflict Resolution
						{conflictList.length > 0 && (
							<span className='ml-2 rounded-full bg-amber-500/20 px-2 py-0.5 text-xs text-amber-400'>
								{conflictList.length}
							</span>
						)}
					</CardTitle>
					<div className='flex items-center gap-2'>
						<Button
							variant='ghost'
							size='icon'
							onClick={() => refetch()}
							disabled={isLoading || isRefetching}
						>
							<RefreshCw
								className={cn(
									'h-4 w-4',
									(isLoading || isRefetching) &&
										'animate-spin'
								)}
							/>
						</Button>
						<Button
							variant='ghost'
							size='icon'
							onClick={() => onOpenChange(false)}
						>
							<X className='h-4 w-4' />
						</Button>
					</div>
				</CardHeader>

				<CardContent className='flex-1 overflow-y-auto p-4'>
					<div className='mb-4'>
						<p className='text-sm text-slate-400'>
							Folder:{' '}
							<span className='text-white'>
								{folderLabel || folderId}
							</span>
						</p>
						<p className='mt-1 text-xs text-slate-500'>
							{folderPath}
						</p>
					</div>

					{isLoading ? (
						<div className='flex flex-col items-center justify-center py-12 text-center'>
							<RefreshCw className='h-8 w-8 animate-spin text-slate-400' />
							<p className='mt-4 text-sm text-slate-400'>
								Scanning for conflicts...
							</p>
						</div>
					) : conflictList.length === 0 ? (
						<div className='flex flex-col items-center justify-center py-12 text-center'>
							<div className='flex h-16 w-16 items-center justify-center rounded-full bg-emerald-500/20'>
								<Check className='h-8 w-8 text-emerald-400' />
							</div>
							<p className='mt-4 text-lg font-medium text-white'>
								No Conflicts
							</p>
							<p className='mt-2 text-sm text-slate-400'>
								This folder has no file conflicts to resolve.
							</p>
						</div>
					) : (
						<div className='space-y-3'>
							<p className='text-sm text-slate-400'>
								{conflictList.length} conflict
								{conflictList.length !== 1 ? 's' : ''} found.
								Choose which version to keep for each file.
							</p>
							{conflictList.map((conflict) => (
								<ConflictCard
									key={conflict.name}
									conflict={conflict}
									folderPath={folderPath}
									onResolve={() => refetch()}
								/>
							))}
						</div>
					)}
				</CardContent>

				<div className='border-t border-border/50 p-4'>
					<div className='flex justify-between items-center'>
						<p className='text-xs text-slate-500'>
							Conflicts occur when the same file is modified on
							multiple devices simultaneously.
						</p>
						<Button
							variant='outline'
							size='sm'
							onClick={() => onOpenChange(false)}
						>
							Close
						</Button>
					</div>
				</div>
			</Card>
		</div>
	);
}
</file>

<file path="src/components/device-list.tsx">
'use client';

import { useState } from 'react';
import {
	useConfig,
	useConnections,
	useRemoveDevice,
	usePauseDevice,
	useResumeDevice,
	useSystemStatus,
} from '@/hooks/useSyncthing';
import {
	Card,
	CardContent,
	CardHeader,
	CardTitle,
	CardDescription,
} from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Skeleton } from '@/components/ui/skeleton';
import {
	Laptop,
	Smartphone,
	Server,
	Wifi,
	WifiOff,
	Plus,
	Trash2,
	Loader2,
	Pause,
	Play,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { AddDeviceDialog, MyDeviceId } from './add-device-dialog';
import { toast } from 'sonner';

function DeviceCard({
	device,
	connectionInfo,
	isLocalDevice,
}: {
	device: { deviceID: string; name?: string; paused?: boolean };
	connectionInfo?: {
		connected?: boolean;
		address?: string;
		type?: string;
		clientVersion?: string;
	};
	isLocalDevice?: boolean;
}) {
	const removeDevice = useRemoveDevice();
	const pauseDevice = usePauseDevice();
	const resumeDevice = useResumeDevice();
	// Local device is always "connected" (it's this machine!)
	const isConnected = isLocalDevice ? true : connectionInfo?.connected;
	const isPaused = device.paused;

	const handleRemove = async () => {
		if (
			confirm(
				`Remove device "${
					device.name || device.deviceID.slice(0, 12)
				}"?`
			)
		) {
			try {
				await removeDevice.mutateAsync(device.deviceID);
				toast.success('Device removed');
			} catch {
				toast.error('Failed to remove device');
			}
		}
	};

	const handlePauseResume = async () => {
		try {
			if (isPaused) {
				await resumeDevice.mutateAsync(device.deviceID);
				toast.success(
					`Resumed syncing with ${device.name || 'device'}`
				);
			} else {
				await pauseDevice.mutateAsync(device.deviceID);
				toast.success(`Paused syncing with ${device.name || 'device'}`);
			}
		} catch {
			toast.error(`Failed to ${isPaused ? 'resume' : 'pause'} device`);
		}
	};

	const isPauseResumePending =
		pauseDevice.isPending || resumeDevice.isPending;

	const getDeviceIcon = () => {
		const type = connectionInfo?.type?.toLowerCase() || '';
		if (type.includes('mobile') || type.includes('phone')) {
			return Smartphone;
		}
		if (type.includes('server')) {
			return Server;
		}
		return Laptop;
	};

	const DeviceIcon = getDeviceIcon();

	return (
		<Card
			className={cn(
				'border-slate-800 bg-slate-900/50 backdrop-blur-md transition-all group',
				isPaused && 'opacity-60',
				isConnected && 'border-emerald-500/30'
			)}
		>
			<CardHeader className='pb-3'>
				<div className='flex items-start justify-between'>
					<div className='flex items-center gap-3'>
						<div
							className={cn(
								'flex h-10 w-10 items-center justify-center rounded-lg',
								isConnected
									? 'bg-emerald-500/20'
									: isLocalDevice
									? 'bg-violet-500/20'
									: 'bg-slate-700/50'
							)}
						>
							<DeviceIcon
								className={cn(
									'h-5 w-5',
									isConnected
										? 'text-emerald-400'
										: isLocalDevice
										? 'text-violet-400'
										: 'text-slate-400'
								)}
							/>
						</div>
						<div className='min-w-0 flex-1'>
							<CardTitle className='truncate text-lg text-white flex items-center gap-2'>
								{device.name || 'Unknown Device'}
								{isLocalDevice && (
									<Badge
										variant='outline'
										className='text-xs border-violet-500/50 text-violet-400'
									>
										This Device
									</Badge>
								)}
							</CardTitle>
							<CardDescription className='font-mono text-xs text-slate-500'>
								{device.deviceID.slice(0, 12)}...
							</CardDescription>
						</div>
					</div>
					<div className='flex items-center gap-2'>
						{isPaused && <Badge variant='secondary'>Paused</Badge>}
						{isConnected ? (
							<Wifi className='h-4 w-4 text-emerald-400' />
						) : (
							<WifiOff className='h-4 w-4 text-slate-500' />
						)}
						{!isLocalDevice && (
							<>
								<Button
									variant='ghost'
									size='icon'
									onClick={handlePauseResume}
									disabled={isPauseResumePending}
									className='h-8 w-8 opacity-0 group-hover:opacity-100 transition-opacity text-slate-400 hover:text-amber-400 hover:bg-amber-500/10'
									title={
										isPaused
											? 'Resume syncing'
											: 'Pause syncing'
									}
								>
									{isPauseResumePending ? (
										<Loader2 className='h-4 w-4 animate-spin' />
									) : isPaused ? (
										<Play className='h-4 w-4' />
									) : (
										<Pause className='h-4 w-4' />
									)}
								</Button>
								<Button
									variant='ghost'
									size='icon'
									onClick={handleRemove}
									disabled={removeDevice.isPending}
									className='h-8 w-8 opacity-0 group-hover:opacity-100 transition-opacity text-slate-400 hover:text-red-400 hover:bg-red-500/10'
								>
									{removeDevice.isPending ? (
										<Loader2 className='h-4 w-4 animate-spin' />
									) : (
										<Trash2 className='h-4 w-4' />
									)}
								</Button>
							</>
						)}
					</div>
				</div>
			</CardHeader>
			<CardContent>
				<div className='grid grid-cols-2 gap-4 text-sm'>
					<div>
						<p className='text-slate-400'>Status</p>
						<p className='font-medium text-white'>
							{isConnected ? 'Connected' : 'Disconnected'}
						</p>
					</div>
					{connectionInfo?.address && (
						<div>
							<p className='text-slate-400'>Address</p>
							<p className='truncate font-mono text-xs text-white'>
								{connectionInfo.address}
							</p>
						</div>
					)}
					{connectionInfo?.clientVersion && (
						<div>
							<p className='text-slate-400'>Version</p>
							<p className='font-medium text-white'>
								{connectionInfo.clientVersion}
							</p>
						</div>
					)}
					{connectionInfo?.type && (
						<div>
							<p className='text-slate-400'>Connection</p>
							<p className='font-medium text-white'>
								{connectionInfo.type}
							</p>
						</div>
					)}
				</div>
			</CardContent>
		</Card>
	);
}

export function DeviceList() {
	const [showAddDialog, setShowAddDialog] = useState(false);
	const {
		data: config,
		isLoading: configLoading,
		isError: configError,
		isFetching: configFetching,
	} = useConfig();
	const { data: connections, isLoading: connectionsLoading } =
		useConnections();
	const { data: systemStatus } = useSystemStatus();

	// Only show skeleton on initial load, not on refetches
	const isInitialLoading = (configLoading || connectionsLoading) && !config;

	// Get local device ID from system status (this is the correct way)
	const localDeviceId = systemStatus?.myID;

	// Render content based on state
	const renderContent = () => {
		if (isInitialLoading) {
			return (
				<div className='grid gap-4 md:grid-cols-2 lg:grid-cols-3'>
					{[1, 2, 3].map((i) => (
						<Card
							key={i}
							className='border-slate-800 bg-slate-900/50'
						>
							<CardHeader>
								<div className='flex items-center gap-3'>
									<Skeleton className='h-10 w-10 rounded-lg' />
									<div className='space-y-2'>
										<Skeleton className='h-5 w-32' />
										<Skeleton className='h-3 w-24' />
									</div>
								</div>
							</CardHeader>
							<CardContent>
								<div className='space-y-2'>
									<Skeleton className='h-4 w-full' />
									<Skeleton className='h-4 w-3/4' />
								</div>
							</CardContent>
						</Card>
					))}
				</div>
			);
		}

		if (configError || !config?.devices?.length) {
			return (
				<Card className='border-slate-800 bg-slate-900/50 backdrop-blur-md'>
					<CardContent className='flex flex-col items-center justify-center py-12'>
						<Laptop className='mb-4 h-12 w-12 text-slate-600' />
						<p className='text-lg font-medium text-slate-300'>
							No devices configured
						</p>
						<p className='text-sm text-slate-500'>
							Add devices to start syncing
						</p>
					</CardContent>
				</Card>
			);
		}

		return (
			<div className='grid gap-4 md:grid-cols-2 lg:grid-cols-3'>
				{config.devices.map((device) => (
					<DeviceCard
						key={device.deviceID}
						device={device}
						connectionInfo={
							connections?.connections?.[device.deviceID]
						}
						isLocalDevice={device.deviceID === localDeviceId}
					/>
				))}
			</div>
		);
	};

	return (
		<div className='space-y-4'>
			<div className='flex items-center justify-end gap-2'>
				{configFetching && !isInitialLoading && (
					<Loader2 className='h-4 w-4 animate-spin text-slate-500' />
				)}
				<Button
					onClick={() => setShowAddDialog(true)}
					className='bg-violet-600 hover:bg-violet-700'
					disabled={isInitialLoading}
				>
					<Plus className='mr-2 h-4 w-4' />
					Add Device
				</Button>
			</div>
			{renderContent()}
			{/* Dialog is always rendered to preserve state */}
			<AddDeviceDialog
				open={showAddDialog}
				onClose={() => setShowAddDialog(false)}
			/>
		</div>
	);
}
</file>

<file path="src/components/file-browser.tsx">
'use client';

import { useState } from 'react';
import {
	useOpenFolderInExplorer,
	useBrowseFolder,
	useBrowseVersions,
	useRestoreVersion,
	VersionEntry,
} from '@/hooks/useSyncthing';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
	FolderOpen,
	X,
	RefreshCw,
	File,
	Folder,
	ChevronRight,
	ChevronLeft,
	ExternalLink,
	Home,
	History,
	RotateCcw,
	Clock,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { toast } from 'sonner';

interface FileBrowserProps {
	open: boolean;
	onOpenChange: (open: boolean) => void;
	folderId: string;
	folderPath: string;
	folderLabel?: string;
}

interface FileEntry {
	name: string;
	type: 'file' | 'directory';
	size?: number;
	modTime?: string;
	permissions?: string;
}

function formatBytes(bytes: number): string {
	if (bytes === 0) return '0 B';
	const k = 1024;
	const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
	const i = Math.floor(Math.log(bytes) / Math.log(k));
	return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

function formatDate(dateInput: string | number): string {
	try {
		const date =
			typeof dateInput === 'number'
				? new Date(dateInput * 1000) // Unix timestamp in seconds
				: new Date(dateInput);
		return date.toLocaleDateString(undefined, {
			year: 'numeric',
			month: 'short',
			day: 'numeric',
			hour: '2-digit',
			minute: '2-digit',
		});
	} catch {
		return String(dateInput);
	}
}

export function FileBrowser({
	open,
	onOpenChange,
	folderId,
	folderPath,
	folderLabel,
}: FileBrowserProps) {
	const [currentPath, setCurrentPath] = useState<string[]>([]);
	const [showVersions, setShowVersions] = useState(false);

	const openInExplorer = useOpenFolderInExplorer();
	const restoreVersion = useRestoreVersion();

	const {
		data: contents,
		isLoading: isLoadingFiles,
		refetch: refetchFiles,
	} = useBrowseFolder(
		folderId,
		currentPath.length > 0 ? currentPath.join('/') : undefined
	);

	const {
		data: versions,
		isLoading: isLoadingVersions,
		refetch: refetchVersions,
	} = useBrowseVersions(
		folderPath,
		currentPath.length > 0 ? currentPath.join('/') : undefined
	);

	if (!open) return null;

	const isLoading = showVersions ? isLoadingVersions : isLoadingFiles;
	const refetch = showVersions ? refetchVersions : refetchFiles;
	const fileEntries = showVersions
		? (versions as VersionEntry[] | undefined) || []
		: (contents as FileEntry[] | undefined) || [];

	const handleNavigate = (entry: FileEntry | VersionEntry) => {
		if (entry.type === 'directory') {
			setCurrentPath([...currentPath, entry.name]);
		}
	};

	const handleRestoreVersion = async (entry: VersionEntry) => {
		try {
			const versionPath =
				currentPath.length > 0
					? `${currentPath.join('/')}/${entry.name}`
					: entry.name;
			const originalPath =
				currentPath.length > 0
					? `${currentPath.join('/')}/${entry.originalName}`
					: entry.originalName;

			await restoreVersion.mutateAsync({
				folderPath,
				versionPath,
				originalName: originalPath,
				overwrite: true,
			});
			toast.success(`Restored ${entry.originalName}`);
		} catch (error) {
			toast.error('Failed to restore file');
		}
	};

	const handleGoBack = () => {
		setCurrentPath(currentPath.slice(0, -1));
	};

	const handleGoHome = () => {
		setCurrentPath([]);
	};

	const handleOpenInExplorer = async () => {
		try {
			const fullPath =
				currentPath.length > 0
					? `${folderPath}/${currentPath.join('/')}`
					: folderPath;
			await openInExplorer.mutateAsync(fullPath);
			toast.success('Opened in file explorer');
		} catch (error) {
			toast.error('Failed to open in file explorer');
		}
	};

	const breadcrumbs = [
		{
			name: showVersions ? '.stversions' : folderLabel || folderId,
			path: [],
		},
		...currentPath.map((segment, index) => ({
			name: segment,
			path: currentPath.slice(0, index + 1),
		})),
	];

	return (
		<div className='fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm'>
			<Card className='w-full max-w-3xl max-h-[80vh] flex flex-col bg-background/95 backdrop-blur-md border-border/50'>
				<CardHeader className='flex flex-row items-center justify-between space-y-0 pb-4 border-b border-border/50'>
					<CardTitle className='text-xl font-semibold flex items-center gap-2'>
						{showVersions ? (
							<History className='h-5 w-5 text-amber-500' />
						) : (
							<FolderOpen className='h-5 w-5 text-muted-foreground' />
						)}
						{showVersions ? 'Version History' : 'File Browser'}
					</CardTitle>
					<div className='flex items-center gap-2'>
						<Button
							variant={showVersions ? 'default' : 'ghost'}
							size='sm'
							onClick={() => {
								setShowVersions(!showVersions);
								setCurrentPath([]);
							}}
							className={cn(
								showVersions &&
									'bg-amber-500/20 text-amber-500 hover:bg-amber-500/30'
							)}
							title={
								showVersions
									? 'Show current files'
									: 'Show file versions'
							}
						>
							<History className='h-4 w-4 mr-1' />
							{showVersions ? 'Versions' : 'History'}
						</Button>
						<Button
							variant='ghost'
							size='icon'
							onClick={handleOpenInExplorer}
							disabled={openInExplorer.isPending || showVersions}
							title='Open in system file explorer'
						>
							<ExternalLink className='h-4 w-4' />
						</Button>
						<Button
							variant='ghost'
							size='icon'
							onClick={() => refetch()}
							disabled={isLoading}
						>
							<RefreshCw
								className={cn(
									'h-4 w-4',
									isLoading && 'animate-spin'
								)}
							/>
						</Button>
						<Button
							variant='ghost'
							size='icon'
							onClick={() => onOpenChange(false)}
						>
							<X className='h-4 w-4' />
						</Button>
					</div>
				</CardHeader>

				{/* Navigation Bar */}
				<div className='p-3 border-b border-border/50 flex items-center gap-2'>
					<Button
						variant='ghost'
						size='icon'
						onClick={handleGoHome}
						disabled={currentPath.length === 0}
						className='h-8 w-8'
					>
						<Home className='h-4 w-4' />
					</Button>
					<Button
						variant='ghost'
						size='icon'
						onClick={handleGoBack}
						disabled={currentPath.length === 0}
						className='h-8 w-8'
					>
						<ChevronLeft className='h-4 w-4' />
					</Button>

					{/* Breadcrumbs */}
					<div className='flex items-center gap-1 overflow-x-auto flex-1 text-sm'>
						{breadcrumbs.map((crumb, index) => (
							<div key={index} className='flex items-center'>
								{index > 0 && (
									<ChevronRight className='h-4 w-4 text-muted-foreground mx-1' />
								)}
								<button
									onClick={() => setCurrentPath(crumb.path)}
									className={cn(
										'px-2 py-1 rounded hover:bg-muted/50 transition-colors truncate max-w-[150px]',
										index === breadcrumbs.length - 1
											? 'text-foreground font-medium'
											: 'text-muted-foreground'
									)}
									title={crumb.name}
								>
									{crumb.name}
								</button>
							</div>
						))}
					</div>
				</div>

				<CardContent className='flex-1 overflow-hidden p-0'>
					<div className='h-[400px] overflow-y-auto'>
						{isLoading ? (
							<div className='flex items-center justify-center h-full'>
								<RefreshCw className='h-6 w-6 animate-spin text-muted-foreground' />
							</div>
						) : fileEntries.length === 0 ? (
							<div className='flex flex-col items-center justify-center h-full text-muted-foreground'>
								{showVersions ? (
									<>
										<History className='h-12 w-12 mb-2' />
										<p>No file versions found</p>
										<p className='text-xs mt-1'>
											Enable versioning on this folder to
											keep file history
										</p>
									</>
								) : (
									<>
										<Folder className='h-12 w-12 mb-2' />
										<p>This folder is empty</p>
									</>
								)}
							</div>
						) : (
							<div className='divide-y divide-border/30'>
								{/* Directories first, then files, both alphabetically sorted */}
								{[...fileEntries]
									.sort((a, b) => {
										if (a.type !== b.type) {
											return a.type === 'directory'
												? -1
												: 1;
										}
										return a.name.localeCompare(b.name);
									})
									.map((entry, index) => {
										const versionEntry =
											entry as VersionEntry;
										const isVersionFile =
											showVersions &&
											entry.type === 'file';

										return (
											<div
												key={index}
												className={cn(
													'flex items-center gap-3 px-4 py-2 hover:bg-muted/30 transition-colors group',
													entry.type ===
														'directory' &&
														'cursor-pointer'
												)}
												onClick={() =>
													entry.type ===
														'directory' &&
													handleNavigate(entry)
												}
											>
												{entry.type === 'directory' ? (
													<Folder className='h-5 w-5 text-blue-400 flex-shrink-0' />
												) : showVersions ? (
													<Clock className='h-5 w-5 text-amber-400 flex-shrink-0' />
												) : (
													<File className='h-5 w-5 text-muted-foreground flex-shrink-0' />
												)}
												<div className='flex-1 min-w-0'>
													<p className='text-sm font-medium truncate'>
														{showVersions &&
														versionEntry.originalName
															? versionEntry.originalName
															: entry.name}
													</p>
													{isVersionFile &&
														versionEntry.versionTime && (
															<p className='text-xs text-amber-500/70'>
																Version from{' '}
																{
																	versionEntry.versionTime
																}
															</p>
														)}
												</div>
												{entry.size !== undefined &&
													entry.type === 'file' && (
														<span className='text-xs text-muted-foreground'>
															{formatBytes(
																entry.size
															)}
														</span>
													)}
												{entry.modTime &&
													!isVersionFile && (
														<span className='text-xs text-muted-foreground hidden sm:block'>
															{formatDate(
																entry.modTime
															)}
														</span>
													)}
												{isVersionFile && (
													<Button
														variant='ghost'
														size='sm'
														className='opacity-0 group-hover:opacity-100 transition-opacity text-amber-500 hover:text-amber-400 hover:bg-amber-500/10'
														onClick={(e) => {
															e.stopPropagation();
															handleRestoreVersion(
																versionEntry
															);
														}}
														disabled={
															restoreVersion.isPending
														}
													>
														<RotateCcw className='h-4 w-4 mr-1' />
														Restore
													</Button>
												)}
												{entry.type === 'directory' && (
													<ChevronRight className='h-4 w-4 text-muted-foreground' />
												)}
											</div>
										);
									})}
							</div>
						)}
					</div>
				</CardContent>

				<div className='p-3 border-t border-border/50 flex items-center justify-between text-xs text-muted-foreground'>
					<span>{fileEntries.length} items</span>
					<span className='truncate max-w-[300px]' title={folderPath}>
						{folderPath}
					</span>
				</div>
			</Card>
		</div>
	);
}
</file>

<file path="src/components/file-indexer.tsx">
'use client';

/**
 * FileIndexer - Component for indexing files into IndexedDB with AI embeddings
 */

import { useState, useCallback, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
	Brain,
	RefreshCw,
	Loader2,
	CheckCircle2,
	AlertCircle,
	Database,
	Sparkles,
	Trash2,
} from 'lucide-react';
import { useConfig } from '@/hooks/useSyncthing';
import { useAISearch } from '@/hooks/useAISearch';
import { useAppStore } from '@/store';
import { invoke } from '@tauri-apps/api/core';
import {
	bulkUpsertFiles,
	getFileCount,
	clearFilesForFolder,
	getFilesWithoutEmbeddings,
	getAllEmbeddings,
	clearAllData,
	type FileMetadata,
} from '@/lib/db';
import { cn } from '@/lib/utils';

interface IndexingStatus {
	phase: 'idle' | 'scanning' | 'storing' | 'embedding' | 'complete' | 'error';
	message: string;
	folderId?: string;
	progress?: { current: number; total: number };
}

interface BrowseFile {
	name: string;
	size: number;
	modTime: string;
	type: string;
}

export function FileIndexer() {
	const [status, setStatus] = useState<IndexingStatus>({
		phase: 'idle',
		message: '',
	});
	const [totalFiles, setTotalFiles] = useState(0);
	const [totalEmbeddings, setTotalEmbeddings] = useState(0);

	const { data: config } = useConfig();
	const folders = config?.folders || [];

	const aiEnabled = useAppStore((state) => state.aiEnabled);
	const {
		status: aiStatus,
		isReady,
		initialize,
		indexFiles,
		progress: embeddingProgress,
	} = useAISearch({ enabled: aiEnabled });

	// Update stats on mount
	useEffect(() => {
		updateStats();
	}, []);

	// Update stats
	const updateStats = useCallback(async () => {
		try {
			const count = await getFileCount();
			setTotalFiles(count);
			const embeddings = await getAllEmbeddings();
			setTotalEmbeddings(embeddings.length);
		} catch (e) {
			console.error('Error updating stats:', e);
		}
	}, []);

	// Index a single folder
	const indexFolder = useCallback(
		async (folderId: string, folderLabel: string, folderPath: string) => {
			setStatus({
				phase: 'scanning',
				message: `Scanning ${folderLabel}...`,
				folderId,
			});

			try {
				// Get files from Syncthing using browse_folder command
				const files = await invoke<BrowseFile[]>('browse_folder', {
					folderId,
					prefix: null,
				});

				if (!files || files.length === 0) {
					return [];
				}

				setStatus({
					phase: 'storing',
					message: `Storing ${files.length} files from ${folderLabel}...`,
					folderId,
					progress: { current: 0, total: files.length },
				});

				// Clear existing files for this folder
				await clearFilesForFolder(folderId);

				// Transform to FileMetadata
				const fileMetadata: FileMetadata[] = files.map((f) => ({
					path: `${folderPath}/${f.name}`,
					name: f.name.split('/').pop() || f.name,
					folderId,
					folderPath,
					size: f.size || 0,
					modified: new Date(f.modTime || Date.now()).getTime(),
					isDirectory: f.type === 'directory' || f.name.endsWith('/'),
					extension: f.name.includes('.')
						? f.name.split('.').pop()
						: undefined,
					indexed: Date.now(),
				}));

				// Store in IndexedDB
				await bulkUpsertFiles(fileMetadata);

				setStatus({
					phase: 'storing',
					message: `Stored ${files.length} files from ${folderLabel}`,
					folderId,
					progress: { current: files.length, total: files.length },
				});

				return fileMetadata.filter((f) => !f.isDirectory);
			} catch (error) {
				console.error(`Error indexing folder ${folderId}:`, error);
				throw error;
			}
		},
		[]
	);

	// Index all folders
	const indexAllFolders = useCallback(async () => {
		if (!folders || folders.length === 0) {
			setStatus({ phase: 'error', message: 'No folders to index' });
			return;
		}

		const allFiles: { path: string; name: string }[] = [];

		try {
			for (const folder of folders) {
				if (!folder.path) continue;
				const files = await indexFolder(
					folder.id,
					folder.label || folder.id,
					folder.path
				);
				allFiles.push(
					...files.map((f) => ({ path: f.path, name: f.name }))
				);
			}

			await updateStats();

			// Generate embeddings if AI is ready
			if (isReady && allFiles.length > 0) {
				setStatus({
					phase: 'embedding',
					message: `Generating embeddings for ${allFiles.length} files...`,
					progress: { current: 0, total: allFiles.length },
				});

				await indexFiles(allFiles);
				await updateStats();
			}

			setStatus({
				phase: 'complete',
				message: `Indexed ${allFiles.length} files from ${folders.length} folders`,
			});
		} catch (error) {
			setStatus({
				phase: 'error',
				message:
					error instanceof Error ? error.message : 'Indexing failed',
			});
		}
	}, [folders, indexFolder, isReady, indexFiles, updateStats]);

	// Generate embeddings for files without them
	const generateMissingEmbeddings = useCallback(async () => {
		if (!isReady) {
			await initialize();
			return;
		}

		try {
			const filesWithoutEmbeddings = await getFilesWithoutEmbeddings();

			if (filesWithoutEmbeddings.length === 0) {
				setStatus({
					phase: 'complete',
					message: 'All files already have embeddings',
				});
				return;
			}

			setStatus({
				phase: 'embedding',
				message: `Generating embeddings for ${filesWithoutEmbeddings.length} files...`,
				progress: { current: 0, total: filesWithoutEmbeddings.length },
			});

			await indexFiles(
				filesWithoutEmbeddings.map((f) => ({
					path: f.path,
					name: f.name,
				}))
			);
			await updateStats();

			setStatus({
				phase: 'complete',
				message: `Generated embeddings for ${filesWithoutEmbeddings.length} files`,
			});
		} catch (error) {
			setStatus({
				phase: 'error',
				message:
					error instanceof Error
						? error.message
						: 'Embedding generation failed',
			});
		}
	}, [isReady, initialize, indexFiles, updateStats]);

	// Clear all indexed data
	const clearIndex = useCallback(async () => {
		try {
			await clearAllData();
			await updateStats();
			setStatus({
				phase: 'complete',
				message: 'Index cleared',
			});
		} catch (error) {
			setStatus({
				phase: 'error',
				message: 'Failed to clear index',
			});
		}
	}, [updateStats]);

	const isWorking =
		status.phase === 'scanning' ||
		status.phase === 'storing' ||
		status.phase === 'embedding';
	const currentProgress =
		status.phase === 'embedding' ? embeddingProgress : status.progress;

	return (
		<div className='p-4 bg-card border border-border rounded-lg'>
			<div className='flex items-center gap-2 mb-4'>
				<Brain className='h-5 w-5 text-primary' />
				<h3 className='font-semibold'>AI File Index</h3>
			</div>

			{/* Stats */}
			<div className='grid grid-cols-2 gap-3 mb-4'>
				<div className='p-3 bg-muted/50 rounded-lg'>
					<div className='flex items-center gap-2 text-sm text-muted-foreground mb-1'>
						<Database className='h-4 w-4' />
						<span>Indexed Files</span>
					</div>
					<p className='text-2xl font-bold'>
						{totalFiles.toLocaleString()}
					</p>
				</div>
				<div className='p-3 bg-muted/50 rounded-lg'>
					<div className='flex items-center gap-2 text-sm text-muted-foreground mb-1'>
						<Sparkles className='h-4 w-4' />
						<span>Embeddings</span>
					</div>
					<p className='text-2xl font-bold'>
						{totalEmbeddings.toLocaleString()}
					</p>
				</div>
			</div>

			{/* AI Status */}
			<div
				className={cn(
					'flex items-center gap-2 p-2 rounded-lg mb-4',
					aiStatus === 'ready'
						? 'bg-green-500/10 text-green-600'
						: aiStatus === 'loading'
						? 'bg-blue-500/10 text-blue-600'
						: aiStatus === 'error'
						? 'bg-red-500/10 text-red-600'
						: 'bg-muted/50 text-muted-foreground'
				)}
			>
				{aiStatus === 'loading' && (
					<Loader2 className='h-4 w-4 animate-spin' />
				)}
				{aiStatus === 'ready' && <CheckCircle2 className='h-4 w-4' />}
				{aiStatus === 'error' && <AlertCircle className='h-4 w-4' />}
				{aiStatus === 'idle' && <Brain className='h-4 w-4' />}
				<span className='text-sm'>
					{aiStatus === 'ready'
						? 'AI Model Ready'
						: aiStatus === 'loading'
						? 'Loading AI Model...'
						: aiStatus === 'error'
						? 'AI Model Error'
						: 'AI Model Idle'}
				</span>
			</div>

			{/* Status */}
			<AnimatePresence mode='wait'>
				{status.phase !== 'idle' && (
					<motion.div
						initial={{ opacity: 0, height: 0 }}
						animate={{ opacity: 1, height: 'auto' }}
						exit={{ opacity: 0, height: 0 }}
						className='mb-4'
					>
						<div
							className={cn(
								'flex items-center gap-2 p-3 rounded-lg',
								status.phase === 'complete'
									? 'bg-green-500/10 text-green-600'
									: status.phase === 'error'
									? 'bg-red-500/10 text-red-600'
									: 'bg-blue-500/10 text-blue-600'
							)}
						>
							{isWorking && (
								<Loader2 className='h-4 w-4 animate-spin' />
							)}
							{status.phase === 'complete' && (
								<CheckCircle2 className='h-4 w-4' />
							)}
							{status.phase === 'error' && (
								<AlertCircle className='h-4 w-4' />
							)}
							<span className='text-sm flex-1'>
								{status.message}
							</span>
						</div>

						{currentProgress && (
							<div className='mt-2'>
								<div className='flex justify-between text-xs text-muted-foreground mb-1'>
									<span>Progress</span>
									<span>
										{currentProgress.current} /{' '}
										{currentProgress.total}
									</span>
								</div>
								<div className='h-2 bg-muted rounded-full overflow-hidden'>
									<motion.div
										className='h-full bg-primary'
										initial={{ width: 0 }}
										animate={{
											width: `${
												(currentProgress.current /
													currentProgress.total) *
												100
											}%`,
										}}
									/>
								</div>
							</div>
						)}
					</motion.div>
				)}
			</AnimatePresence>

			{/* Actions */}
			<div className='flex flex-wrap gap-2'>
				<button
					onClick={indexAllFolders}
					disabled={isWorking || !folders?.length}
					className={cn(
						'flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-medium',
						'bg-primary text-primary-foreground',
						'hover:bg-primary/90 transition-colors',
						'disabled:opacity-50 disabled:cursor-not-allowed'
					)}
				>
					{isWorking ? (
						<Loader2 className='h-4 w-4 animate-spin' />
					) : (
						<RefreshCw className='h-4 w-4' />
					)}
					Reindex All Folders
				</button>

				<button
					onClick={generateMissingEmbeddings}
					disabled={isWorking || !isReady}
					className={cn(
						'flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-medium',
						'bg-secondary text-secondary-foreground',
						'hover:bg-secondary/80 transition-colors',
						'disabled:opacity-50 disabled:cursor-not-allowed'
					)}
				>
					<Sparkles className='h-4 w-4' />
					Generate Embeddings
				</button>

				<button
					onClick={clearIndex}
					disabled={isWorking}
					className={cn(
						'flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-medium',
						'bg-destructive/10 text-destructive',
						'hover:bg-destructive/20 transition-colors',
						'disabled:opacity-50 disabled:cursor-not-allowed'
					)}
				>
					<Trash2 className='h-4 w-4' />
					Clear Index
				</button>
			</div>

			{/* Help text */}
			<p className='text-xs text-muted-foreground mt-4'>
				Index your synced folders to enable AI-powered semantic file
				search. The AI model runs locally in your browser for privacy.
			</p>
		</div>
	);
}
</file>

<file path="src/components/folder-list.tsx">
'use client';

import { useState } from 'react';
import {
	useConfig,
	useFolderStatus,
	usePauseFolder,
	useResumeFolder,
	useRescanFolder,
	useRemoveFolder,
	useOpenFolderInExplorer,
	useUnshareFolder,
	useSystemStatus,
} from '@/hooks/useSyncthing';
import {
	Card,
	CardContent,
	CardHeader,
	CardTitle,
	CardDescription,
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Skeleton } from '@/components/ui/skeleton';
import { formatBytes } from '@/lib/utils';
import {
	Folder,
	Pause,
	Play,
	RefreshCw,
	Trash2,
	Plus,
	Share2,
	FileX,
	FolderOpen,
	ExternalLink,
	AlertTriangle,
	Users,
	X,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { AddFolderDialog } from '@/components/add-folder-dialog';
import { ShareFolderDialog } from '@/components/share-folder-dialog';
import { IgnorePatternsDialog } from '@/components/ignore-patterns-dialog';
import { FileBrowser } from '@/components/file-browser';
import { ConflictResolver } from '@/components/conflict-resolver';
import { toast } from 'sonner';

function FolderCard({
	folder,
	devices,
	localDeviceId,
	onShare,
	onIgnorePatterns,
	onBrowse,
	onConflicts,
}: {
	folder: {
		id: string;
		label?: string;
		path?: string;
		paused?: boolean;
		devices?: { deviceID: string }[];
	};
	devices: { deviceID: string; name?: string }[];
	localDeviceId?: string;
	onShare: (id: string, label?: string) => void;
	onIgnorePatterns: (id: string, label?: string) => void;
	onBrowse: (id: string, path: string, label?: string) => void;
	onConflicts: (id: string, path: string, label?: string) => void;
}) {
	const { data: status, isLoading } = useFolderStatus(folder.id);
	const pauseFolder = usePauseFolder();
	const resumeFolder = useResumeFolder();
	const rescanFolder = useRescanFolder();
	const removeFolder = useRemoveFolder();
	const openInExplorer = useOpenFolderInExplorer();
	const unshareFolder = useUnshareFolder();

	const isPaused = folder.paused;
	const isSyncing = status?.state === 'syncing';
	const needsSync = (status?.needFiles || 0) > 0;

	// Get list of shared devices (excluding local device)
	const sharedDevices = (folder.devices || [])
		.filter((fd) => fd.deviceID !== localDeviceId)
		.map((fd) => {
			const device = devices.find((d) => d.deviceID === fd.deviceID);
			return {
				deviceID: fd.deviceID,
				name: device?.name || fd.deviceID.slice(0, 8) + '...',
			};
		});

	const handleUnshare = async (deviceId: string, deviceName: string) => {
		if (
			confirm(
				`Stop sharing "${
					folder.label || folder.id
				}" with "${deviceName}"?`
			)
		) {
			try {
				await unshareFolder.mutateAsync({
					folderId: folder.id,
					deviceId,
				});
				toast.success(`Stopped sharing with ${deviceName}`);
			} catch {
				toast.error('Failed to unshare folder');
			}
		}
	};

	const getStatusBadge = () => {
		if (isPaused) return <Badge variant='secondary'>Paused</Badge>;
		if (isSyncing) return <Badge variant='warning'>Syncing</Badge>;
		if (needsSync) return <Badge variant='warning'>Needs Sync</Badge>;
		return <Badge variant='success'>Up to Date</Badge>;
	};

	const handleTogglePause = () => {
		if (isPaused) {
			resumeFolder.mutate(folder.id);
		} else {
			pauseFolder.mutate(folder.id);
		}
	};

	const handleRescan = () => {
		rescanFolder.mutate(folder.id);
	};

	const handleRemove = async () => {
		if (
			confirm(
				`Remove folder "${
					folder.label || folder.id
				}"? This will not delete the files on disk.`
			)
		) {
			try {
				await removeFolder.mutateAsync(folder.id);
				toast.success('Folder removed');
			} catch {
				toast.error('Failed to remove folder');
			}
		}
	};

	const handleOpenInExplorer = async () => {
		if (folder.path) {
			try {
				await openInExplorer.mutateAsync(folder.path);
				toast.success('Opened in file explorer');
			} catch {
				toast.error('Failed to open folder');
			}
		}
	};

	return (
		<Card
			className={cn(
				'border-slate-800 bg-slate-900/50 backdrop-blur-md transition-all',
				isPaused && 'opacity-60'
			)}
		>
			<CardHeader className='pb-3'>
				<div className='flex items-start justify-between'>
					<div className='flex items-center gap-3'>
						<div className='flex h-10 w-10 items-center justify-center rounded-lg bg-indigo-500/20'>
							<Folder className='h-5 w-5 text-indigo-400' />
						</div>
						<div>
							<CardTitle className='text-lg text-white'>
								{folder.label || folder.id}
							</CardTitle>
							<CardDescription className='font-mono text-xs text-slate-500'>
								{folder.path}
							</CardDescription>
						</div>
					</div>
					{getStatusBadge()}
				</div>
			</CardHeader>
			<CardContent>
				{isLoading ? (
					<div className='space-y-2'>
						<Skeleton className='h-4 w-full' />
						<Skeleton className='h-4 w-3/4' />
					</div>
				) : (
					<>
						<div className='mb-4 grid grid-cols-2 gap-4 text-sm'>
							<div>
								<p className='text-slate-400'>Local Files</p>
								<p className='font-medium text-white'>
									{status?.localFiles?.toLocaleString() || 0}
								</p>
							</div>
							<div>
								<p className='text-slate-400'>Local Size</p>
								<p className='font-medium text-white'>
									{formatBytes(status?.localBytes || 0)}
								</p>
							</div>
							<div>
								<p className='text-slate-400'>Global Files</p>
								<p className='font-medium text-white'>
									{status?.globalFiles?.toLocaleString() || 0}
								</p>
							</div>
							<div>
								<p className='text-slate-400'>Need Sync</p>
								<p className='font-medium text-white'>
									{status?.needFiles?.toLocaleString() || 0}{' '}
									files
								</p>
							</div>
						</div>

						{/* Shared Devices */}
						{sharedDevices.length > 0 && (
							<div className='mb-4'>
								<div className='flex items-center gap-2 mb-2 text-sm text-slate-400'>
									<Users className='h-4 w-4' />
									<span>Shared with</span>
								</div>
								<div className='flex flex-wrap gap-1.5'>
									{sharedDevices.map((device) => (
										<Badge
											key={device.deviceID}
											variant='secondary'
											className='group/badge flex items-center gap-1 pr-1 hover:bg-slate-600'
										>
											<span className='max-w-[100px] truncate'>
												{device.name}
											</span>
											<button
												onClick={() =>
													handleUnshare(
														device.deviceID,
														device.name
													)
												}
												disabled={
													unshareFolder.isPending
												}
												className='ml-0.5 opacity-0 group-hover/badge:opacity-100 transition-opacity rounded-full p-0.5 hover:bg-red-500/20 hover:text-red-400'
												title='Stop sharing'
											>
												<X className='h-3 w-3' />
											</button>
										</Badge>
									))}
								</div>
							</div>
						)}

						{/* Primary Actions */}
						<div className='flex gap-2 mb-2'>
							<Button
								variant='outline'
								size='sm'
								onClick={handleTogglePause}
								disabled={
									pauseFolder.isPending ||
									resumeFolder.isPending
								}
								className='flex-1'
							>
								{isPaused ? (
									<>
										<Play className='mr-1 h-4 w-4' /> Resume
									</>
								) : (
									<>
										<Pause className='mr-1 h-4 w-4' /> Pause
									</>
								)}
							</Button>
							<Button
								variant='outline'
								size='sm'
								onClick={() => onShare(folder.id, folder.label)}
								className='text-indigo-400 hover:bg-indigo-500/10 hover:text-indigo-300'
								title='Share folder'
							>
								<Share2 className='h-4 w-4' />
							</Button>
							<Button
								variant='outline'
								size='sm'
								onClick={handleRescan}
								disabled={rescanFolder.isPending || isPaused}
								title='Rescan'
							>
								<RefreshCw
									className={cn(
										'h-4 w-4',
										rescanFolder.isPending && 'animate-spin'
									)}
								/>
							</Button>
						</div>

						{/* Secondary Actions */}
						<div className='flex gap-2'>
							<Button
								variant='outline'
								size='sm'
								onClick={handleOpenInExplorer}
								disabled={
									openInExplorer.isPending || !folder.path
								}
								className='flex-1 text-slate-400 hover:text-slate-200'
								title='Open in file explorer'
							>
								<ExternalLink className='mr-1 h-4 w-4' />
								Open
							</Button>
							<Button
								variant='outline'
								size='sm'
								onClick={() =>
									folder.path &&
									onBrowse(
										folder.id,
										folder.path,
										folder.label
									)
								}
								disabled={!folder.path}
								title='Browse files'
							>
								<FolderOpen className='h-4 w-4' />
							</Button>
							<Button
								variant='outline'
								size='sm'
								onClick={() =>
									folder.path &&
									onConflicts(
										folder.id,
										folder.path,
										folder.label
									)
								}
								disabled={!folder.path}
								title='Resolve conflicts'
								className='text-amber-400 hover:bg-amber-500/10 hover:text-amber-300'
							>
								<AlertTriangle className='h-4 w-4' />
							</Button>
							<Button
								variant='outline'
								size='sm'
								onClick={() =>
									onIgnorePatterns(folder.id, folder.label)
								}
								title='Ignore patterns'
							>
								<FileX className='h-4 w-4' />
							</Button>
							<Button
								variant='outline'
								size='sm'
								onClick={handleRemove}
								disabled={removeFolder.isPending}
								className='text-red-400 hover:bg-red-500/10 hover:text-red-300'
								title='Remove folder'
							>
								<Trash2 className='h-4 w-4' />
							</Button>
						</div>
					</>
				)}
			</CardContent>
		</Card>
	);
}

export function FolderList() {
	const [addDialogOpen, setAddDialogOpen] = useState(false);
	const [shareData, setShareData] = useState<{
		id: string;
		label?: string;
	} | null>(null);
	const [ignoreData, setIgnoreData] = useState<{
		id: string;
		label?: string;
	} | null>(null);
	const [browseData, setBrowseData] = useState<{
		id: string;
		path: string;
		label?: string;
	} | null>(null);
	const [conflictData, setConflictData] = useState<{
		id: string;
		path: string;
		label?: string;
	} | null>(null);
	const { data: config, isLoading, isError } = useConfig();
	const { data: systemStatus } = useSystemStatus();

	const localDeviceId = systemStatus?.myID;

	if (isLoading) {
		return (
			<div className='grid gap-4 md:grid-cols-2 lg:grid-cols-3'>
				{[1, 2, 3].map((i) => (
					<Card key={i} className='border-slate-800 bg-slate-900/50'>
						<CardHeader>
							<Skeleton className='h-6 w-32' />
							<Skeleton className='h-4 w-48' />
						</CardHeader>
						<CardContent>
							<div className='space-y-2'>
								<Skeleton className='h-4 w-full' />
								<Skeleton className='h-4 w-3/4' />
							</div>
						</CardContent>
					</Card>
				))}
			</div>
		);
	}

	if (isError || !config?.folders?.length) {
		return (
			<>
				<Card className='border-slate-800 bg-slate-900/50 backdrop-blur-md'>
					<CardContent className='flex flex-col items-center justify-center py-12'>
						<Folder className='mb-4 h-12 w-12 text-slate-600' />
						<p className='text-lg font-medium text-slate-300'>
							No folders configured
						</p>
						<p className='mb-4 text-sm text-slate-500'>
							Add folders to start syncing
						</p>
						<Button
							onClick={() => setAddDialogOpen(true)}
							className='bg-indigo-600 hover:bg-indigo-700'
						>
							<Plus className='mr-2 h-4 w-4' />
							Add Folder
						</Button>
					</CardContent>
				</Card>
				<AddFolderDialog
					open={addDialogOpen}
					onOpenChange={setAddDialogOpen}
				/>
			</>
		);
	}

	return (
		<>
			<div className='grid gap-4 md:grid-cols-2 lg:grid-cols-3'>
				{config.folders.map((folder) => (
					<FolderCard
						key={folder.id}
						folder={folder}
						devices={config.devices || []}
						localDeviceId={localDeviceId}
						onShare={(id, label) => setShareData({ id, label })}
						onIgnorePatterns={(id, label) =>
							setIgnoreData({ id, label })
						}
						onBrowse={(id, path, label) =>
							setBrowseData({ id, path, label })
						}
						onConflicts={(id, path, label) =>
							setConflictData({ id, path, label })
						}
					/>
				))}
				{/* Add Folder Card */}
				<Card
					className='flex cursor-pointer items-center justify-center border-2 border-dashed border-slate-700 bg-slate-900/30 transition-colors hover:border-indigo-500/50 hover:bg-slate-800/50'
					onClick={() => setAddDialogOpen(true)}
				>
					<CardContent className='flex flex-col items-center justify-center py-12'>
						<div className='flex h-12 w-12 items-center justify-center rounded-full bg-indigo-500/20'>
							<Plus className='h-6 w-6 text-indigo-400' />
						</div>
						<p className='mt-3 text-sm font-medium text-slate-300'>
							Add Folder
						</p>
					</CardContent>
				</Card>
			</div>
			<AddFolderDialog
				open={addDialogOpen}
				onOpenChange={setAddDialogOpen}
			/>
			<ShareFolderDialog
				open={!!shareData}
				onOpenChange={(open) => !open && setShareData(null)}
				folderId={shareData?.id || ''}
				folderLabel={shareData?.label}
			/>
			<IgnorePatternsDialog
				open={!!ignoreData}
				onOpenChange={(open) => !open && setIgnoreData(null)}
				folderId={ignoreData?.id || ''}
				folderLabel={ignoreData?.label}
			/>
			<FileBrowser
				open={!!browseData}
				onOpenChange={(open) => !open && setBrowseData(null)}
				folderId={browseData?.id || ''}
				folderPath={browseData?.path || ''}
				folderLabel={browseData?.label}
			/>
			<ConflictResolver
				open={!!conflictData}
				onOpenChange={(open) => !open && setConflictData(null)}
				folderId={conflictData?.id || ''}
				folderPath={conflictData?.path || ''}
				folderLabel={conflictData?.label}
			/>
		</>
	);
}
</file>

<file path="src/components/header.tsx">
'use client';

import { useAppStore } from '@/store';
import { useSystemStatus } from '@/hooks/useSyncthing';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { AISearchBar } from '@/components/ai-search-bar';
import { RefreshCw, Wifi, WifiOff } from 'lucide-react';

export function Header() {
	const { activeTab, setActiveTab } = useAppStore();
	const { data: status, isError, refetch, isRefetching } = useSystemStatus();

	const isOnline = !isError && status?.myID;

	const titles: Record<string, string> = {
		dashboard: 'Dashboard',
		folders: 'Folders',
		devices: 'Devices',
		settings: 'Settings',
	};

	const handleSearchResultSelect = (path: string) => {
		// Navigate to folders tab and potentially open file browser
		setActiveTab('folders');
		// TODO: Open file browser at the selected path
		console.log('Selected file:', path);
	};

	return (
		<header className='flex h-16 items-center justify-between border-b border-slate-800 bg-slate-950/50 px-6 backdrop-blur-xl'>
			<div className='flex items-center gap-4'>
				<h1 className='text-xl font-semibold text-white'>
					{titles[activeTab] || 'Dashboard'}
				</h1>
			</div>

			{/* AI Search Bar */}
			<div className='flex-1 max-w-md mx-4'>
				<AISearchBar
					onResultSelect={handleSearchResultSelect}
					className='w-full'
				/>
			</div>

			<div className='flex items-center gap-3'>
				{/* Connection Status */}
				<div className='flex items-center gap-2'>
					{isOnline ? (
						<Wifi className='h-4 w-4 text-emerald-400' />
					) : (
						<WifiOff className='h-4 w-4 text-red-400' />
					)}
					<Badge variant={isOnline ? 'success' : 'destructive'}>
						{isOnline ? 'Connected' : 'Offline'}
					</Badge>
				</div>

				{/* Refresh Button */}
				<Button
					variant='ghost'
					size='icon'
					onClick={() => refetch()}
					disabled={isRefetching}
					className='h-8 w-8 text-slate-400 hover:text-white'
					title='Refresh status'
				>
					<RefreshCw
						className={`h-4 w-4 ${
							isRefetching ? 'animate-spin' : ''
						}`}
					/>
				</Button>
			</div>
		</header>
	);
}
</file>

<file path="src/components/ignore-patterns-dialog.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useFolderIgnores, useSetFolderIgnores } from '@/hooks/useSyncthing';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
	FileX,
	X,
	Save,
	RefreshCw,
	Plus,
	Trash2,
	HelpCircle,
	FileText,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { toast } from 'sonner';

interface IgnorePatternsDialogProps {
	open: boolean;
	onOpenChange: (open: boolean) => void;
	folderId: string;
	folderLabel?: string;
}

const commonPatterns = [
	{ pattern: '.DS_Store', description: 'macOS folder metadata' },
	{ pattern: 'Thumbs.db', description: 'Windows thumbnail cache' },
	{ pattern: 'desktop.ini', description: 'Windows folder settings' },
	{ pattern: 'node_modules', description: 'Node.js dependencies' },
	{ pattern: '.git', description: 'Git repository folder' },
	{ pattern: '*.tmp', description: 'Temporary files' },
	{ pattern: '*.log', description: 'Log files' },
	{ pattern: '.env*', description: 'Environment files' },
	{ pattern: '__pycache__', description: 'Python bytecode cache' },
	{ pattern: '*.pyc', description: 'Python compiled files' },
	{ pattern: 'target/', description: 'Rust/Java build output' },
	{ pattern: 'dist/', description: 'Build distribution folder' },
	{ pattern: 'build/', description: 'Build output folder' },
	{ pattern: '.next/', description: 'Next.js build folder' },
	{ pattern: '*.bak', description: 'Backup files' },
	{ pattern: '~*', description: 'Temporary editor files' },
	{ pattern: '#*#', description: 'Emacs auto-save files' },
	{ pattern: '.*.swp', description: 'Vim swap files' },
];

export function IgnorePatternsDialog({
	open,
	onOpenChange,
	folderId,
	folderLabel,
}: IgnorePatternsDialogProps) {
	const [patterns, setPatterns] = useState<string[]>([]);
	const [newPattern, setNewPattern] = useState('');
	const [showHelp, setShowHelp] = useState(false);
	const [hasChanges, setHasChanges] = useState(false);

	const { data: ignoreData, isLoading, refetch } = useFolderIgnores(folderId);
	const setIgnoresMutation = useSetFolderIgnores();

	// Initialize patterns from server data
	useEffect(() => {
		if (ignoreData?.ignore) {
			setPatterns(
				ignoreData.ignore.filter((p: string) => p.trim() !== '')
			);
			setHasChanges(false);
		}
	}, [ignoreData]);

	if (!open) return null;

	const handleAddPattern = () => {
		const trimmed = newPattern.trim();
		if (!trimmed) return;
		if (patterns.includes(trimmed)) {
			toast.error('Pattern already exists');
			return;
		}
		setPatterns([...patterns, trimmed]);
		setNewPattern('');
		setHasChanges(true);
	};

	const handleRemovePattern = (index: number) => {
		setPatterns(patterns.filter((_, i) => i !== index));
		setHasChanges(true);
	};

	const handleAddCommonPattern = (pattern: string) => {
		if (patterns.includes(pattern)) {
			toast.info('Pattern already added');
			return;
		}
		setPatterns([...patterns, pattern]);
		setHasChanges(true);
	};

	const handleSave = async () => {
		try {
			await setIgnoresMutation.mutateAsync({
				folderId,
				ignorePatterns: patterns,
			});
			toast.success('Ignore patterns saved');
			setHasChanges(false);
		} catch (error) {
			toast.error('Failed to save ignore patterns');
		}
	};

	const handleReset = () => {
		if (ignoreData?.ignore) {
			setPatterns(
				ignoreData.ignore.filter((p: string) => p.trim() !== '')
			);
			setHasChanges(false);
		}
	};

	return (
		<div className='fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm'>
			<Card className='w-full max-w-2xl max-h-[85vh] flex flex-col bg-background/95 backdrop-blur-md border-border/50'>
				<CardHeader className='flex flex-row items-center justify-between space-y-0 pb-4 border-b border-border/50'>
					<CardTitle className='text-xl font-semibold flex items-center gap-2'>
						<FileX className='h-5 w-5 text-muted-foreground' />
						Ignore Patterns
						{folderLabel && (
							<span className='text-sm font-normal text-muted-foreground'>
								 {folderLabel}
							</span>
						)}
					</CardTitle>
					<div className='flex items-center gap-2'>
						<Button
							variant='ghost'
							size='icon'
							onClick={() => setShowHelp(!showHelp)}
							title='Help'
						>
							<HelpCircle
								className={cn(
									'h-4 w-4',
									showHelp && 'text-primary'
								)}
							/>
						</Button>
						<Button
							variant='ghost'
							size='icon'
							onClick={() => refetch()}
							disabled={isLoading}
						>
							<RefreshCw
								className={cn(
									'h-4 w-4',
									isLoading && 'animate-spin'
								)}
							/>
						</Button>
						<Button
							variant='ghost'
							size='icon'
							onClick={() => onOpenChange(false)}
						>
							<X className='h-4 w-4' />
						</Button>
					</div>
				</CardHeader>

				{showHelp && (
					<div className='p-4 bg-muted/30 border-b border-border/50 text-sm'>
						<h4 className='font-medium mb-2'>Pattern Syntax</h4>
						<ul className='space-y-1 text-muted-foreground text-xs'>
							<li>
								{' '}
								<code className='bg-muted px-1 rounded'>*</code>{' '}
								 matches any characters except path separator
							</li>
							<li>
								{' '}
								<code className='bg-muted px-1 rounded'>
									**
								</code>{' '}
								 matches any characters including path
								separator
							</li>
							<li>
								{' '}
								<code className='bg-muted px-1 rounded'>?</code>{' '}
								 matches a single character
							</li>
							<li>
								{' '}
								<code className='bg-muted px-1 rounded'>
									[abc]
								</code>{' '}
								 matches any character in the brackets
							</li>
							<li>
								{' '}
								<code className='bg-muted px-1 rounded'>!</code>{' '}
								prefix  negates the pattern (include instead of
								ignore)
							</li>
							<li>
								{' '}
								<code className='bg-muted px-1 rounded'>/</code>{' '}
								prefix  anchors to folder root
							</li>
							<li>
								{' '}
								<code className='bg-muted px-1 rounded'>
									//
								</code>{' '}
								prefix  comment line
							</li>
						</ul>
					</div>
				)}

				<CardContent className='flex-1 overflow-hidden p-4 space-y-4'>
					{/* Add new pattern */}
					<div className='flex gap-2'>
						<input
							type='text'
							value={newPattern}
							onChange={(e) => setNewPattern(e.target.value)}
							onKeyDown={(e) =>
								e.key === 'Enter' && handleAddPattern()
							}
							placeholder='Enter pattern (e.g., *.log or node_modules)'
							className='flex-1 h-9 px-3 rounded-md border border-border/50 bg-background/50 text-sm placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-primary/50'
						/>
						<Button
							onClick={handleAddPattern}
							disabled={!newPattern.trim()}
							size='sm'
						>
							<Plus className='h-4 w-4 mr-1' />
							Add
						</Button>
					</div>

					{/* Current patterns */}
					<div className='space-y-2'>
						<h4 className='text-sm font-medium text-muted-foreground'>
							Current Patterns ({patterns.length})
						</h4>
						<div className='max-h-[200px] overflow-y-auto space-y-1 border border-border/30 rounded-md p-2 bg-muted/20'>
							{isLoading ? (
								<div className='flex items-center justify-center py-4'>
									<RefreshCw className='h-5 w-5 animate-spin text-muted-foreground' />
								</div>
							) : patterns.length === 0 ? (
								<div className='flex flex-col items-center py-4 text-muted-foreground text-sm'>
									<FileText className='h-6 w-6 mb-1' />
									<span>No ignore patterns defined</span>
								</div>
							) : (
								patterns.map((pattern, index) => (
									<div
										key={index}
										className='flex items-center justify-between px-2 py-1 rounded hover:bg-muted/50 group'
									>
										<code className='text-sm font-mono'>
											{pattern}
										</code>
										<Button
											variant='ghost'
											size='icon'
											className='h-6 w-6 opacity-0 group-hover:opacity-100 transition-opacity'
											onClick={() =>
												handleRemovePattern(index)
											}
										>
											<Trash2 className='h-3 w-3 text-destructive' />
										</Button>
									</div>
								))
							)}
						</div>
					</div>

					{/* Common patterns */}
					<div className='space-y-2'>
						<h4 className='text-sm font-medium text-muted-foreground'>
							Quick Add Common Patterns
						</h4>
						<div className='flex flex-wrap gap-1 max-h-[120px] overflow-y-auto'>
							{commonPatterns.map(({ pattern, description }) => (
								<button
									key={pattern}
									onClick={() =>
										handleAddCommonPattern(pattern)
									}
									className={cn(
										'px-2 py-1 text-xs rounded border border-border/50 bg-background/50',
										'hover:bg-primary/10 hover:border-primary/50 transition-colors',
										patterns.includes(pattern) &&
											'opacity-50 cursor-not-allowed'
									)}
									disabled={patterns.includes(pattern)}
									title={description}
								>
									{pattern}
								</button>
							))}
						</div>
					</div>
				</CardContent>

				<div className='p-4 border-t border-border/50 flex items-center justify-between'>
					<div className='text-xs text-muted-foreground'>
						{hasChanges && (
							<span className='text-yellow-500'>
								 Unsaved changes
							</span>
						)}
					</div>
					<div className='flex gap-2'>
						<Button
							variant='outline'
							onClick={handleReset}
							disabled={!hasChanges}
						>
							Reset
						</Button>
						<Button
							onClick={handleSave}
							disabled={
								!hasChanges || setIgnoresMutation.isPending
							}
						>
							{setIgnoresMutation.isPending ? (
								<RefreshCw className='h-4 w-4 mr-2 animate-spin' />
							) : (
								<Save className='h-4 w-4 mr-2' />
							)}
							Save Patterns
						</Button>
					</div>
				</div>
			</Card>
		</div>
	);
}
</file>

<file path="src/components/log-viewer.tsx">
'use client';

import { useState, useEffect, useRef } from 'react';
import { useSystemLogs } from '@/hooks/useSyncthing';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
	RefreshCw,
	X,
	AlertCircle,
	AlertTriangle,
	Info,
	Bug,
	ChevronDown,
	Download,
	Trash2,
} from 'lucide-react';
import { cn } from '@/lib/utils';

interface LogViewerProps {
	open: boolean;
	onOpenChange: (open: boolean) => void;
}

interface LogEntry {
	when?: string;
	level?: string;
	message?: string;
}

type LogLevel = 'all' | 'error' | 'warning' | 'info' | 'debug';

const levelConfig: Record<
	string,
	{ icon: typeof Info; color: string; bg: string }
> = {
	error: { icon: AlertCircle, color: 'text-red-500', bg: 'bg-red-500/10' },
	warning: {
		icon: AlertTriangle,
		color: 'text-yellow-500',
		bg: 'bg-yellow-500/10',
	},
	info: { icon: Info, color: 'text-blue-500', bg: 'bg-blue-500/10' },
	debug: { icon: Bug, color: 'text-gray-500', bg: 'bg-gray-500/10' },
	verbose: { icon: Bug, color: 'text-gray-400', bg: 'bg-gray-400/10' },
};

export function LogViewer({ open, onOpenChange }: LogViewerProps) {
	const [filter, setFilter] = useState<LogLevel>('all');
	const [autoScroll, setAutoScroll] = useState(true);
	const logContainerRef = useRef<HTMLDivElement>(null);

	const { data: logs, isLoading, refetch, isRefetching } = useSystemLogs();

	// Auto-scroll to bottom when new logs arrive
	useEffect(() => {
		if (autoScroll && logContainerRef.current) {
			logContainerRef.current.scrollTop =
				logContainerRef.current.scrollHeight;
		}
	}, [logs, autoScroll]);

	if (!open) return null;

	const logEntries = (logs as LogEntry[] | undefined) || [];
	const filteredLogs = logEntries.filter((log: LogEntry) => {
		if (filter === 'all') return true;
		const level = log.level?.toLowerCase() || 'info';
		return level === filter;
	});

	const getLogLevel = (log: { level?: string; message?: string }): string => {
		if (log.level) return log.level.toLowerCase();
		// Try to infer from message
		const msg = log.message?.toLowerCase() || '';
		if (msg.includes('error') || msg.includes('failed')) return 'error';
		if (msg.includes('warning') || msg.includes('warn')) return 'warning';
		return 'info';
	};

	const handleExport = () => {
		if (!logEntries.length) return;
		const content = logEntries
			.map(
				(log: LogEntry) =>
					`[${log.when || ''}] [${log.level || 'INFO'}] ${
						log.message || ''
					}`
			)
			.join('\n');

		const blob = new Blob([content], { type: 'text/plain' });
		const url = URL.createObjectURL(blob);
		const a = document.createElement('a');
		a.href = url;
		a.download = `syncthing-logs-${
			new Date().toISOString().split('T')[0]
		}.txt`;
		document.body.appendChild(a);
		a.click();
		document.body.removeChild(a);
		URL.revokeObjectURL(url);
	};

	return (
		<div className='fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm'>
			<Card className='w-full max-w-4xl max-h-[80vh] flex flex-col bg-background/95 backdrop-blur-md border-border/50'>
				<CardHeader className='flex flex-row items-center justify-between space-y-0 pb-4 border-b border-border/50'>
					<CardTitle className='text-xl font-semibold flex items-center gap-2'>
						<Bug className='h-5 w-5 text-muted-foreground' />
						System Logs
					</CardTitle>
					<div className='flex items-center gap-2'>
						<Button
							variant='ghost'
							size='icon'
							onClick={handleExport}
							disabled={!logEntries.length}
							title='Export logs'
						>
							<Download className='h-4 w-4' />
						</Button>
						<Button
							variant='ghost'
							size='icon'
							onClick={() => refetch()}
							disabled={isRefetching}
						>
							<RefreshCw
								className={cn(
									'h-4 w-4',
									isRefetching && 'animate-spin'
								)}
							/>
						</Button>
						<Button
							variant='ghost'
							size='icon'
							onClick={() => onOpenChange(false)}
						>
							<X className='h-4 w-4' />
						</Button>
					</div>
				</CardHeader>

				<div className='p-4 border-b border-border/50 flex items-center gap-4 flex-wrap'>
					{/* Level Filter */}
					<div className='flex items-center gap-2'>
						<span className='text-sm text-muted-foreground'>
							Level:
						</span>
						<div className='flex gap-1'>
							{(
								[
									'all',
									'error',
									'warning',
									'info',
									'debug',
								] as LogLevel[]
							).map((level) => (
								<Button
									key={level}
									variant={
										filter === level ? 'default' : 'ghost'
									}
									size='sm'
									onClick={() => setFilter(level)}
									className={cn(
										'text-xs capitalize',
										filter === level &&
											'bg-primary text-primary-foreground'
									)}
								>
									{level}
								</Button>
							))}
						</div>
					</div>

					{/* Auto-scroll toggle */}
					<div className='flex items-center gap-2 ml-auto'>
						<label className='flex items-center gap-2 cursor-pointer'>
							<input
								type='checkbox'
								checked={autoScroll}
								onChange={(e) =>
									setAutoScroll(e.target.checked)
								}
								className='rounded border-border'
							/>
							<span className='text-sm text-muted-foreground'>
								Auto-scroll
							</span>
						</label>
					</div>
				</div>

				<CardContent className='flex-1 overflow-hidden p-0'>
					<div
						ref={logContainerRef}
						className='h-[400px] overflow-y-auto font-mono text-xs'
					>
						{isLoading ? (
							<div className='flex items-center justify-center h-full'>
								<RefreshCw className='h-6 w-6 animate-spin text-muted-foreground' />
							</div>
						) : filteredLogs.length === 0 ? (
							<div className='flex flex-col items-center justify-center h-full text-muted-foreground'>
								<Info className='h-8 w-8 mb-2' />
								<p>No logs to display</p>
								<p className='text-xs'>
									Logs will appear here when Syncthing
									generates them
								</p>
							</div>
						) : (
							<div className='divide-y divide-border/30'>
								{filteredLogs.map((log, index) => {
									const level = getLogLevel(log);
									const config =
										levelConfig[level] || levelConfig.info;
									const Icon = config.icon;

									return (
										<div
											key={index}
											className={cn(
												'flex items-start gap-2 p-2 hover:bg-muted/30 transition-colors',
												config.bg
											)}
										>
											<Icon
												className={cn(
													'h-4 w-4 mt-0.5 flex-shrink-0',
													config.color
												)}
											/>
											<div className='flex-1 min-w-0'>
												<div className='flex items-center gap-2 text-[10px] text-muted-foreground mb-0.5'>
													<span>
														{log.when
															? new Date(
																	log.when
															  ).toLocaleTimeString()
															: ''}
													</span>
													<span
														className={cn(
															'uppercase font-medium',
															config.color
														)}
													>
														{level}
													</span>
												</div>
												<p className='text-foreground break-all whitespace-pre-wrap'>
													{log.message}
												</p>
											</div>
										</div>
									);
								})}
							</div>
						)}
					</div>
				</CardContent>

				<div className='p-3 border-t border-border/50 flex items-center justify-between text-xs text-muted-foreground'>
					<span>
						Showing {filteredLogs.length} of {logEntries.length} log
						entries
					</span>
					<Button
						variant='ghost'
						size='sm'
						onClick={() => {
							if (logContainerRef.current) {
								logContainerRef.current.scrollTop =
									logContainerRef.current.scrollHeight;
							}
						}}
					>
						<ChevronDown className='h-3 w-3 mr-1' />
						Jump to bottom
					</Button>
				</div>
			</Card>
		</div>
	);
}
</file>

<file path="src/components/logs-page.tsx">
'use client';

import { useState, useEffect, useRef } from 'react';
import { useSystemLogs, LogEntry } from '@/hooks/useSyncthing';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import {
	RefreshCw,
	AlertCircle,
	AlertTriangle,
	Info,
	Bug,
	Download,
	Trash2,
	ChevronDown,
} from 'lucide-react';
import { cn } from '@/lib/utils';

type LogLevel = 'all' | 'error' | 'warning' | 'info' | 'debug';

const levelConfig: Record<
	string,
	{ icon: typeof Info; color: string; bg: string }
> = {
	error: { icon: AlertCircle, color: 'text-red-500', bg: 'bg-red-500/10' },
	warning: {
		icon: AlertTriangle,
		color: 'text-yellow-500',
		bg: 'bg-yellow-500/10',
	},
	info: { icon: Info, color: 'text-blue-500', bg: 'bg-blue-500/10' },
	debug: { icon: Bug, color: 'text-gray-500', bg: 'bg-gray-500/10' },
	verbose: { icon: Bug, color: 'text-gray-400', bg: 'bg-gray-400/10' },
};

export function LogsPage() {
	const [filter, setFilter] = useState<LogLevel>('all');
	const [autoScroll, setAutoScroll] = useState(true);
	const logContainerRef = useRef<HTMLDivElement>(null);

	const { data: logs, isLoading, refetch, isRefetching } = useSystemLogs();

	// Auto-scroll to bottom when new logs arrive
	useEffect(() => {
		if (autoScroll && logContainerRef.current) {
			logContainerRef.current.scrollTop =
				logContainerRef.current.scrollHeight;
		}
	}, [logs, autoScroll]);

	const logEntries = logs?.messages || [];

	// Convert numeric log level to string
	const getLevelString = (level?: number): string => {
		if (level === undefined) return 'info';
		// Syncthing log levels: 0=debug, 1=verbose, 2=info, 3=warning, 4=error
		switch (level) {
			case 0:
				return 'debug';
			case 1:
				return 'verbose';
			case 2:
				return 'info';
			case 3:
				return 'warning';
			case 4:
				return 'error';
			default:
				return 'info';
		}
	};

	const filteredLogs = logEntries.filter((log) => {
		if (filter === 'all') return true;
		const level = getLevelString(log.level);
		return level === filter;
	});

	const getLogLevel = (log: { level?: number; message?: string }): string => {
		if (log.level !== undefined) return getLevelString(log.level);
		// Try to infer from message
		const msg = log.message?.toLowerCase() || '';
		if (msg.includes('error') || msg.includes('failed')) return 'error';
		if (msg.includes('warning') || msg.includes('warn')) return 'warning';
		return 'info';
	};

	const handleExport = () => {
		if (!logEntries.length) return;
		const content = logEntries
			.map(
				(log) =>
					`[${log.when || ''}] [${getLevelString(
						log.level
					).toUpperCase()}] ${log.message || ''}`
			)
			.join('\n');

		const blob = new Blob([content], { type: 'text/plain' });
		const url = URL.createObjectURL(blob);
		const a = document.createElement('a');
		a.href = url;
		a.download = `syncthing-logs-${
			new Date().toISOString().split('T')[0]
		}.txt`;
		document.body.appendChild(a);
		a.click();
		document.body.removeChild(a);
		URL.revokeObjectURL(url);
	};

	const formatTime = (timestamp?: string) => {
		if (!timestamp) return '';
		try {
			return new Date(timestamp).toLocaleTimeString();
		} catch {
			return timestamp;
		}
	};

	return (
		<div className='space-y-6'>
			<div className='flex items-center justify-between'>
				<h2 className='text-lg font-semibold text-white'>
					System Logs
				</h2>
				<div className='flex items-center gap-2'>
					<Button
						variant='outline'
						size='sm'
						onClick={handleExport}
						disabled={!logEntries.length}
						className='border-slate-700 bg-slate-800/50 hover:bg-slate-700'
					>
						<Download className='mr-2 h-4 w-4' />
						Export
					</Button>
					<Button
						variant='outline'
						size='sm'
						onClick={() => refetch()}
						disabled={isLoading || isRefetching}
						className='border-slate-700 bg-slate-800/50 hover:bg-slate-700'
					>
						<RefreshCw
							className={cn(
								'h-4 w-4',
								(isLoading || isRefetching) && 'animate-spin'
							)}
						/>
					</Button>
				</div>
			</div>

			<Card className='border-slate-800 bg-slate-900/50 backdrop-blur-md'>
				<CardHeader className='border-b border-slate-800 pb-4'>
					<div className='flex items-center justify-between'>
						<CardTitle className='text-base text-white'>
							Log Output
						</CardTitle>
						<div className='flex items-center gap-2'>
							{/* Filter buttons */}
							{(
								[
									'all',
									'error',
									'warning',
									'info',
									'debug',
								] as const
							).map((level) => (
								<Button
									key={level}
									variant={
										filter === level ? 'default' : 'ghost'
									}
									size='sm'
									onClick={() => setFilter(level)}
									className={cn(
										'text-xs capitalize',
										filter === level
											? 'bg-indigo-600 hover:bg-indigo-700'
											: 'text-slate-400 hover:text-white'
									)}
								>
									{level}
								</Button>
							))}
						</div>
					</div>
				</CardHeader>
				<CardContent className='p-0'>
					{isLoading ? (
						<div className='flex items-center justify-center py-12'>
							<RefreshCw className='h-8 w-8 animate-spin text-slate-400' />
						</div>
					) : filteredLogs.length === 0 ? (
						<div className='flex flex-col items-center justify-center py-12 text-center'>
							<Info className='h-8 w-8 text-slate-500' />
							<p className='mt-2 text-sm text-slate-400'>
								No logs to display
							</p>
						</div>
					) : (
						<div
							ref={logContainerRef}
							className='h-[500px] overflow-auto font-mono text-xs'
						>
							{filteredLogs.map((log, index) => {
								const level = getLogLevel(log);
								const config =
									levelConfig[level] || levelConfig.info;
								const Icon = config.icon;

								return (
									<div
										key={index}
										className={cn(
											'flex items-start gap-2 border-b border-slate-800/50 px-4 py-2 hover:bg-slate-800/30',
											config.bg
										)}
									>
										<Icon
											className={cn(
												'mt-0.5 h-3 w-3 shrink-0',
												config.color
											)}
										/>
										<span className='shrink-0 text-slate-500'>
											{formatTime(log.when)}
										</span>
										<span className='flex-1 break-all text-slate-300'>
											{log.message}
										</span>
									</div>
								);
							})}
						</div>
					)}
				</CardContent>
			</Card>

			{/* Auto-scroll toggle */}
			<div className='flex items-center justify-between'>
				<label className='flex items-center gap-2 text-sm text-slate-400'>
					<input
						type='checkbox'
						checked={autoScroll}
						onChange={(e) => setAutoScroll(e.target.checked)}
						className='rounded border-slate-600 bg-slate-800'
					/>
					Auto-scroll to new logs
				</label>
				<p className='text-xs text-slate-500'>
					{filteredLogs.length} log entries
				</p>
			</div>
		</div>
	);
}
</file>

<file path="src/components/main-content.tsx">
'use client';

import { useAppStore } from '@/store';
import { NetworkGraph } from '@/components/network-graph';
import { StatsOverview } from '@/components/stats-overview';
import { FolderList } from '@/components/folder-list';
import { DeviceList } from '@/components/device-list';
import { SettingsPage } from '@/components/settings-page';
import { LogsPage } from '@/components/logs-page';
import { MotionPage, MotionList, MotionItem } from '@/components/ui/motion';
import { AnimatePresence } from 'framer-motion';

function DashboardView() {
	return (
		<MotionPage className='space-y-8'>
			{/* Network Visualization */}
			<MotionList>
				<MotionItem>
					<section>
						<h2 className='mb-4 text-lg font-semibold text-white'>
							Network Topology
						</h2>
						<NetworkGraph />
					</section>
				</MotionItem>

				{/* Stats Overview */}
				<MotionItem>
					<section className='mt-8'>
						<h2 className='mb-4 text-lg font-semibold text-white'>
							Overview
						</h2>
						<StatsOverview />
					</section>
				</MotionItem>

				{/* Quick Folders Preview */}
				<MotionItem>
					<section className='mt-8'>
						<h2 className='mb-4 text-lg font-semibold text-white'>
							Recent Folders
						</h2>
						<FolderList />
					</section>
				</MotionItem>
			</MotionList>
		</MotionPage>
	);
}

function FoldersView() {
	return (
		<MotionPage className='space-y-6'>
			<div className='flex items-center justify-between'>
				<h2 className='text-lg font-semibold text-white'>
					All Folders
				</h2>
			</div>
			<FolderList />
		</MotionPage>
	);
}

function DevicesView() {
	return (
		<MotionPage className='space-y-6'>
			<div className='flex items-center justify-between'>
				<h2 className='text-lg font-semibold text-white'>
					All Devices
				</h2>
			</div>
			<DeviceList />
		</MotionPage>
	);
}

function LogsView() {
	return (
		<MotionPage>
			<LogsPage />
		</MotionPage>
	);
}

function SettingsView() {
	return (
		<MotionPage>
			<SettingsPage />
		</MotionPage>
	);
}

export function MainContent() {
	const { activeTab } = useAppStore();

	const renderContent = () => {
		switch (activeTab) {
			case 'dashboard':
				return <DashboardView />;
			case 'folders':
				return <FoldersView />;
			case 'devices':
				return <DevicesView />;
			case 'logs':
				return <LogsView />;
			case 'settings':
				return <SettingsView />;
			default:
				return <DashboardView />;
		}
	};

	return (
		<main className='flex-1 overflow-auto p-6'>
			<AnimatePresence mode='wait'>
				<div key={activeTab}>{renderContent()}</div>
			</AnimatePresence>
		</main>
	);
}
</file>

<file path="src/components/network-graph.tsx">
'use client';

import { useConnections, useConfig } from '@/hooks/useSyncthing';
import { Skeleton } from '@/components/ui/skeleton';
import { useMemo } from 'react';

interface DeviceNode {
	id: string;
	name: string;
	connected: boolean;
	x: number;
	y: number;
}

export function NetworkGraph() {
	const { data: connections, isLoading: connectionsLoading } =
		useConnections();
	const { data: config, isLoading: configLoading } = useConfig();

	const { nodes, lines, myDeviceId } = useMemo(() => {
		if (!connections || !config) {
			return { nodes: [], lines: [], myDeviceId: null };
		}

		const deviceNodes: DeviceNode[] = [];
		const conns = connections.connections || {};
		const devices = config.devices || [];

		// Find my device ID from connections response
		const myId = (connections as { myID?: string }).myID || null;

		// Center position
		const centerX = 150;
		const centerY = 120;
		const radius = 80;

		// Add my device at center
		if (myId) {
			const myDevice = devices.find(
				(d: { deviceID: string }) => d.deviceID === myId
			);
			deviceNodes.push({
				id: myId,
				name: myDevice?.name || 'This Device',
				connected: true,
				x: centerX,
				y: centerY,
			});
		}

		// Add other devices in a circle around center
		const otherDevices = devices.filter(
			(d: { deviceID: string }) => d.deviceID !== myId
		);
		const angleStep = (2 * Math.PI) / Math.max(otherDevices.length, 1);

		otherDevices.forEach(
			(device: { deviceID: string; name?: string }, index: number) => {
				const angle = index * angleStep - Math.PI / 2; // Start from top
				const connectionInfo = conns[device.deviceID] as
					| { connected?: boolean }
					| undefined;

				deviceNodes.push({
					id: device.deviceID,
					name: device.name || device.deviceID.slice(0, 8),
					connected: connectionInfo?.connected ?? false,
					x: centerX + Math.cos(angle) * radius,
					y: centerY + Math.sin(angle) * radius,
				});
			}
		);

		// Build connection lines from center to connected devices
		const connectionLines: Array<{
			x1: number;
			y1: number;
			x2: number;
			y2: number;
		}> = [];
		const centerNode = deviceNodes.find((n) => n.id === myId);

		if (centerNode) {
			deviceNodes
				.filter((n) => n.id !== myId && n.connected)
				.forEach((node) => {
					connectionLines.push({
						x1: centerNode.x,
						y1: centerNode.y,
						x2: node.x,
						y2: node.y,
					});
				});
		}

		return { nodes: deviceNodes, lines: connectionLines, myDeviceId: myId };
	}, [connections, config]);

	if (connectionsLoading || configLoading) {
		return <Skeleton className='h-64 w-full rounded-xl bg-slate-800/50' />;
	}

	if (nodes.length === 0) {
		return (
			<div className='flex h-64 w-full items-center justify-center rounded-xl bg-slate-900/50 backdrop-blur-md'>
				<p className='text-sm text-slate-400'>
					No devices connected. Start Syncthing to see your network.
				</p>
			</div>
		);
	}

	return (
		<div className='h-64 w-full overflow-hidden rounded-xl bg-slate-900/50 backdrop-blur-md'>
			<svg viewBox='0 0 300 240' className='h-full w-full'>
				{/* Connection lines */}
				{lines.map((line, i) => (
					<line
						key={i}
						x1={line.x1}
						y1={line.y1}
						x2={line.x2}
						y2={line.y2}
						stroke='#6366f1'
						strokeWidth='2'
						strokeOpacity='0.5'
						strokeDasharray='4 2'
					>
						<animate
							attributeName='stroke-dashoffset'
							from='0'
							to='12'
							dur='1s'
							repeatCount='indefinite'
						/>
					</line>
				))}

				{/* Device nodes */}
				{nodes.map((node) => {
					const isMe = node.id === myDeviceId;
					const nodeRadius = isMe ? 24 : 18;
					const color = isMe
						? '#6366f1'
						: node.connected
						? '#10b981'
						: '#6b7280';

					return (
						<g key={node.id}>
							{/* Glow effect */}
							<circle
								cx={node.x}
								cy={node.y}
								r={nodeRadius + 4}
								fill={color}
								opacity={node.connected || isMe ? 0.3 : 0.1}
							>
								{(node.connected || isMe) && (
									<animate
										attributeName='opacity'
										values='0.3;0.5;0.3'
										dur='2s'
										repeatCount='indefinite'
									/>
								)}
							</circle>

							{/* Main circle */}
							<circle
								cx={node.x}
								cy={node.y}
								r={nodeRadius}
								fill={color}
								stroke={
									isMe
										? '#818cf8'
										: node.connected
										? '#34d399'
										: '#9ca3af'
								}
								strokeWidth='2'
							/>

							{/* Icon */}
							<text
								x={node.x}
								y={node.y}
								textAnchor='middle'
								dominantBaseline='central'
								fontSize={isMe ? '14' : '12'}
							>
								{isMe ? '' : node.connected ? '' : ''}
							</text>

							{/* Label */}
							<text
								x={node.x}
								y={node.y + nodeRadius + 14}
								textAnchor='middle'
								fill='white'
								fontSize='10'
								fontWeight='500'
								className='select-none'
							>
								{node.name.length > 12
									? node.name.slice(0, 12) + ''
									: node.name}
							</text>
						</g>
					);
				})}
			</svg>
		</div>
	);
}
</file>

<file path="src/components/providers.tsx">
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactNode, useState } from 'react';
import { Toaster } from 'sonner';
import { SyncthingManager } from './syncthing-manager';

export function Providers({ children }: { children: ReactNode }) {
	const [queryClient] = useState(
		() =>
			new QueryClient({
				defaultOptions: {
					queries: {
						staleTime: 1000,
						refetchOnWindowFocus: false,
						retry: 3,
						retryDelay: (attemptIndex) =>
							Math.min(1000 * 2 ** attemptIndex, 30000),
					},
				},
			})
	);

	return (
		<QueryClientProvider client={queryClient}>
			<SyncthingManager>{children}</SyncthingManager>
			<Toaster
				position='bottom-right'
				theme='dark'
				richColors
				closeButton
			/>
		</QueryClientProvider>
	);
}
</file>

<file path="src/components/settings-page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useAppStore } from '@/store';
import {
	useSyncthingInstallation,
	useDeviceId,
	useRestartSyncthing,
	useConfig,
	useUpdateOptions,
} from '@/hooks/useSyncthing';
import type { Options } from '@/hooks/useSyncthing';
import {
	Card,
	CardContent,
	CardHeader,
	CardTitle,
	CardDescription,
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Skeleton } from '@/components/ui/skeleton';
import {
	Sun,
	Moon,
	Monitor,
	Copy,
	Check,
	Info,
	Palette,
	Server,
	Bell,
	RefreshCw,
	Bug,
	RotateCw,
	Brain,
	Globe,
	Save,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { toast } from 'sonner';
import { LogViewer } from '@/components/log-viewer';
import { FileIndexer } from '@/components/file-indexer';

interface SettingCardProps {
	title: string;
	description: string;
	icon: React.ComponentType<{ className?: string }>;
	children: React.ReactNode;
}

function SettingCard({
	title,
	description,
	icon: Icon,
	children,
}: SettingCardProps) {
	return (
		<Card className='border-slate-800 bg-slate-900/50 backdrop-blur-md'>
			<CardHeader className='pb-3'>
				<div className='flex items-start gap-3'>
					<div className='flex h-10 w-10 items-center justify-center rounded-lg bg-indigo-500/20'>
						<Icon className='h-5 w-5 text-indigo-400' />
					</div>
					<div>
						<CardTitle className='text-lg text-white'>
							{title}
						</CardTitle>
						<CardDescription className='text-slate-400'>
							{description}
						</CardDescription>
					</div>
				</div>
			</CardHeader>
			<CardContent>{children}</CardContent>
		</Card>
	);
}

function ThemeSelector() {
	const { theme, setTheme } = useAppStore();

	const themes = [
		{ value: 'light', label: 'Light', icon: Sun },
		{ value: 'dark', label: 'Dark', icon: Moon },
		{ value: 'system', label: 'System', icon: Monitor },
	] as const;

	return (
		<div className='flex gap-2'>
			{themes.map(({ value, label, icon: Icon }) => (
				<Button
					key={value}
					variant={theme === value ? 'default' : 'outline'}
					size='sm'
					onClick={() => setTheme(value)}
					className={cn(
						'flex-1 gap-2',
						theme === value
							? 'bg-indigo-600 hover:bg-indigo-700'
							: 'border-slate-700 bg-slate-800/50 text-slate-300 hover:bg-slate-700'
					)}
				>
					<Icon className='h-4 w-4' />
					{label}
				</Button>
			))}
		</div>
	);
}

function DeviceIdDisplay() {
	const { data: deviceId, isLoading, isError } = useDeviceId();
	const [copied, setCopied] = useState(false);

	const handleCopy = async () => {
		if (deviceId) {
			await navigator.clipboard.writeText(deviceId);
			setCopied(true);
			toast.success('Device ID copied to clipboard');
			setTimeout(() => setCopied(false), 2000);
		}
	};

	if (isLoading) {
		return <Skeleton className='h-10 w-full' />;
	}

	if (isError || !deviceId) {
		return (
			<div className='rounded-lg border border-red-500/30 bg-red-500/10 p-3 text-sm text-red-400'>
				Unable to fetch device ID. Make sure Syncthing is running.
			</div>
		);
	}

	return (
		<div className='flex items-center gap-2'>
			<code className='flex-1 truncate rounded-lg bg-slate-800 px-3 py-2 font-mono text-sm text-slate-300'>
				{deviceId}
			</code>
			<Button
				variant='outline'
				size='sm'
				onClick={handleCopy}
				className='shrink-0 border-slate-700 bg-slate-800/50 hover:bg-slate-700'
			>
				{copied ? (
					<Check className='h-4 w-4 text-emerald-400' />
				) : (
					<Copy className='h-4 w-4' />
				)}
			</Button>
		</div>
	);
}

function SyncthingInfo() {
	const { data: installation, isLoading } = useSyncthingInstallation();

	if (isLoading) {
		return (
			<div className='space-y-2'>
				<Skeleton className='h-5 w-48' />
				<Skeleton className='h-5 w-64' />
			</div>
		);
	}

	if (!installation?.installed) {
		return (
			<div className='rounded-lg border border-red-500/30 bg-red-500/10 p-3'>
				<p className='text-sm font-medium text-red-400'>
					Syncthing not installed
				</p>
				<p className='mt-1 text-xs text-red-400/70'>
					Install with: sudo apt install syncthing
				</p>
			</div>
		);
	}

	return (
		<div className='space-y-3'>
			<div className='flex items-center justify-between'>
				<span className='text-sm text-slate-400'>Status</span>
				<Badge variant='success'>Installed</Badge>
			</div>
			{installation.version && (
				<div className='flex items-center justify-between'>
					<span className='text-sm text-slate-400'>Version</span>
					<span className='font-mono text-sm text-white'>
						{installation.version.split(' ')[1] ||
							installation.version}
					</span>
				</div>
			)}
			{installation.path && (
				<div className='flex items-center justify-between'>
					<span className='text-sm text-slate-400'>Path</span>
					<code className='rounded bg-slate-800 px-2 py-0.5 font-mono text-xs text-slate-300'>
						{installation.path}
					</code>
				</div>
			)}
		</div>
	);
}

function PollingSettings() {
	const { pollingInterval, setPollingInterval } = useAppStore();

	const intervals = [
		{ value: 2000, label: '2 seconds' },
		{ value: 5000, label: '5 seconds' },
		{ value: 10000, label: '10 seconds' },
		{ value: 30000, label: '30 seconds' },
	];

	return (
		<div className='space-y-3'>
			<label className='text-sm text-slate-400'>
				Status polling interval
			</label>
			<div className='flex flex-wrap gap-2'>
				{intervals.map(({ value, label }) => (
					<Button
						key={value}
						variant={
							pollingInterval === value ? 'default' : 'outline'
						}
						size='sm'
						onClick={() => {
							setPollingInterval(value);
							toast.success(`Polling interval set to ${label}`);
						}}
						className={cn(
							pollingInterval === value
								? 'bg-indigo-600 hover:bg-indigo-700'
								: 'border-slate-700 bg-slate-800/50 text-slate-300 hover:bg-slate-700'
						)}
					>
						{label}
					</Button>
				))}
			</div>
			<p className='text-xs text-slate-500'>
				How often to refresh connection and folder status
			</p>
		</div>
	);
}

function NotificationSettings() {
	const { nativeNotificationsEnabled, setNativeNotificationsEnabled } =
		useAppStore();

	return (
		<div className='space-y-3'>
			<div className='flex items-center justify-between'>
				<div>
					<p className='text-sm text-white'>Native Notifications</p>
					<p className='text-xs text-slate-500'>
						Show OS notifications for sync events
					</p>
				</div>
				<Button
					variant={nativeNotificationsEnabled ? 'default' : 'outline'}
					size='sm'
					onClick={() => {
						setNativeNotificationsEnabled(
							!nativeNotificationsEnabled
						);
						toast.success(
							nativeNotificationsEnabled
								? 'Native notifications disabled'
								: 'Native notifications enabled'
						);
					}}
					className={cn(
						nativeNotificationsEnabled
							? 'bg-emerald-600 hover:bg-emerald-700'
							: 'border-slate-700 bg-slate-800/50 text-slate-300 hover:bg-slate-700'
					)}
				>
					{nativeNotificationsEnabled ? 'Enabled' : 'Disabled'}
				</Button>
			</div>
			<p className='text-xs text-slate-500'>
				Receive desktop notifications when devices connect/disconnect,
				folders sync, or errors occur. In-app toasts are always shown.
			</p>
		</div>
	);
}

function AISettings() {
	const { aiEnabled, setAiEnabled } = useAppStore();

	return (
		<div className='space-y-4'>
			<div className='flex items-center justify-between'>
				<div>
					<p className='text-sm text-white'>Enable AI Search</p>
					<p className='text-xs text-slate-500'>
						Semantic file search using local AI model
					</p>
				</div>
				<Button
					variant={aiEnabled ? 'default' : 'outline'}
					size='sm'
					onClick={() => {
						setAiEnabled(!aiEnabled);
						toast.success(
							aiEnabled
								? 'AI search disabled'
								: 'AI search enabled - model will load on next use'
						);
					}}
					className={cn(
						aiEnabled
							? 'bg-emerald-600 hover:bg-emerald-700'
							: 'border-slate-700 bg-slate-800/50 text-slate-300 hover:bg-slate-700'
					)}
				>
					{aiEnabled ? 'Enabled' : 'Disabled'}
				</Button>
			</div>
			<p className='text-xs text-slate-500'>
				AI search uses a local embedding model (all-MiniLM-L6-v2) to
				enable semantic file search. The model runs entirely on your
				device. Disabling saves memory and CPU resources.
			</p>
			{aiEnabled && (
				<div className='pt-2 border-t border-slate-800'>
					<FileIndexer />
				</div>
			)}
		</div>
	);
}

function NetworkSettings() {
	const { data: config, isLoading } = useConfig();
	const updateOptions = useUpdateOptions();

	const [localOptions, setLocalOptions] = useState<Partial<Options>>({});
	const [hasChanges, setHasChanges] = useState(false);

	// Initialize local state from config
	useEffect(() => {
		if (config?.options) {
			setLocalOptions({
				globalAnnounceEnabled: config.options.globalAnnounceEnabled,
				localAnnounceEnabled: config.options.localAnnounceEnabled,
				relaysEnabled: config.options.relaysEnabled,
				maxSendKbps: config.options.maxSendKbps,
				maxRecvKbps: config.options.maxRecvKbps,
				listenAddresses: config.options.listenAddresses,
			});
			setHasChanges(false);
		}
	}, [config?.options]);

	const updateField = <K extends keyof Options>(
		key: K,
		value: Options[K]
	) => {
		setLocalOptions((prev) => ({ ...prev, [key]: value }));
		setHasChanges(true);
	};

	const handleSave = async () => {
		try {
			await updateOptions.mutateAsync(localOptions);
			toast.success('Network settings saved');
			setHasChanges(false);
		} catch (error) {
			toast.error('Failed to save network settings');
		}
	};

	if (isLoading) {
		return (
			<div className='space-y-3'>
				<Skeleton className='h-8 w-full' />
				<Skeleton className='h-8 w-full' />
				<Skeleton className='h-8 w-full' />
			</div>
		);
	}

	return (
		<div className='space-y-4'>
			{/* Discovery Toggles */}
			<div className='flex items-center justify-between'>
				<div>
					<p className='text-sm text-white'>Global Discovery</p>
					<p className='text-xs text-slate-500'>
						Find devices over the internet
					</p>
				</div>
				<Button
					variant={
						localOptions.globalAnnounceEnabled
							? 'default'
							: 'outline'
					}
					size='sm'
					onClick={() =>
						updateField(
							'globalAnnounceEnabled',
							!localOptions.globalAnnounceEnabled
						)
					}
					className={cn(
						localOptions.globalAnnounceEnabled
							? 'bg-emerald-600 hover:bg-emerald-700'
							: 'border-slate-700 bg-slate-800/50 text-slate-300 hover:bg-slate-700'
					)}
				>
					{localOptions.globalAnnounceEnabled ? 'On' : 'Off'}
				</Button>
			</div>

			<div className='flex items-center justify-between'>
				<div>
					<p className='text-sm text-white'>Local Discovery</p>
					<p className='text-xs text-slate-500'>
						Find devices on local network
					</p>
				</div>
				<Button
					variant={
						localOptions.localAnnounceEnabled
							? 'default'
							: 'outline'
					}
					size='sm'
					onClick={() =>
						updateField(
							'localAnnounceEnabled',
							!localOptions.localAnnounceEnabled
						)
					}
					className={cn(
						localOptions.localAnnounceEnabled
							? 'bg-emerald-600 hover:bg-emerald-700'
							: 'border-slate-700 bg-slate-800/50 text-slate-300 hover:bg-slate-700'
					)}
				>
					{localOptions.localAnnounceEnabled ? 'On' : 'Off'}
				</Button>
			</div>

			<div className='flex items-center justify-between'>
				<div>
					<p className='text-sm text-white'>Relaying</p>
					<p className='text-xs text-slate-500'>
						Use relays when direct connection fails
					</p>
				</div>
				<Button
					variant={localOptions.relaysEnabled ? 'default' : 'outline'}
					size='sm'
					onClick={() =>
						updateField(
							'relaysEnabled',
							!localOptions.relaysEnabled
						)
					}
					className={cn(
						localOptions.relaysEnabled
							? 'bg-emerald-600 hover:bg-emerald-700'
							: 'border-slate-700 bg-slate-800/50 text-slate-300 hover:bg-slate-700'
					)}
				>
					{localOptions.relaysEnabled ? 'On' : 'Off'}
				</Button>
			</div>

			{/* Bandwidth Limits */}
			<div className='pt-2 border-t border-slate-800'>
				<p className='text-sm text-white mb-2'>Bandwidth Limits</p>
				<div className='grid grid-cols-2 gap-3'>
					<div>
						<label className='text-xs text-slate-500'>
							Upload (KB/s)
						</label>
						<input
							type='number'
							value={localOptions.maxSendKbps ?? 0}
							onChange={(e) =>
								updateField(
									'maxSendKbps',
									parseInt(e.target.value) || 0
								)
							}
							className='w-full mt-1 rounded-lg bg-slate-800 px-3 py-2 text-sm text-white border border-slate-700 focus:border-indigo-500 focus:outline-none'
							placeholder='0 = unlimited'
							min={0}
						/>
					</div>
					<div>
						<label className='text-xs text-slate-500'>
							Download (KB/s)
						</label>
						<input
							type='number'
							value={localOptions.maxRecvKbps ?? 0}
							onChange={(e) =>
								updateField(
									'maxRecvKbps',
									parseInt(e.target.value) || 0
								)
							}
							className='w-full mt-1 rounded-lg bg-slate-800 px-3 py-2 text-sm text-white border border-slate-700 focus:border-indigo-500 focus:outline-none'
							placeholder='0 = unlimited'
							min={0}
						/>
					</div>
				</div>
				<p className='text-xs text-slate-500 mt-1'>
					0 = unlimited bandwidth
				</p>
			</div>

			{/* Listen Addresses */}
			<div className='pt-2 border-t border-slate-800'>
				<label className='text-sm text-white'>Listen Addresses</label>
				<input
					type='text'
					value={localOptions.listenAddresses?.join(', ') ?? ''}
					onChange={(e) => {
						const addresses = e.target.value
							.split(',')
							.map((s) => s.trim())
							.filter(Boolean);
						updateField(
							'listenAddresses',
							addresses.length > 0 ? addresses : ['default']
						);
					}}
					className='w-full mt-1 rounded-lg bg-slate-800 px-3 py-2 text-sm text-white border border-slate-700 focus:border-indigo-500 focus:outline-none'
					placeholder='default, tcp://0.0.0.0:22000'
				/>
				<p className='text-xs text-slate-500 mt-1'>
					Comma-separated list of listen addresses
				</p>
			</div>

			{/* Save Button */}
			{hasChanges && (
				<Button
					variant='default'
					size='sm'
					onClick={handleSave}
					disabled={updateOptions.isPending}
					className='w-full bg-indigo-600 hover:bg-indigo-700'
				>
					{updateOptions.isPending ? (
						<>
							<RefreshCw className='mr-2 h-4 w-4 animate-spin' />
							Saving...
						</>
					) : (
						<>
							<Save className='mr-2 h-4 w-4' />
							Save Changes
						</>
					)}
				</Button>
			)}
		</div>
	);
}

export function SettingsPage() {
	const [logViewerOpen, setLogViewerOpen] = useState(false);
	const restartSyncthing = useRestartSyncthing();

	const handleRestart = async () => {
		try {
			await restartSyncthing.mutateAsync();
			toast.success('Syncthing is restarting...');
		} catch (error) {
			toast.error('Failed to restart Syncthing');
		}
	};

	return (
		<div className='space-y-6'>
			<div className='flex items-center justify-between'>
				<h2 className='text-lg font-semibold text-white'>Settings</h2>
			</div>

			<div className='grid gap-6 md:grid-cols-2'>
				{/* Appearance */}
				<SettingCard
					title='Appearance'
					description='Customize the look and feel'
					icon={Palette}
				>
					<ThemeSelector />
				</SettingCard>

				{/* Syncthing Info */}
				<SettingCard
					title='Syncthing'
					description='Backend service information'
					icon={Server}
				>
					<SyncthingInfo />
				</SettingCard>

				{/* Device ID */}
				<SettingCard
					title='Device ID'
					description='Share this ID to connect with other devices'
					icon={Info}
				>
					<DeviceIdDisplay />
				</SettingCard>

				{/* Polling Settings */}
				<SettingCard
					title='Refresh Rate'
					description='Configure data polling frequency'
					icon={RefreshCw}
				>
					<PollingSettings />
				</SettingCard>

				{/* Notification Settings */}
				<SettingCard
					title='Notifications'
					description='Configure how you receive alerts'
					icon={Bell}
				>
					<NotificationSettings />
				</SettingCard>

				{/* AI File Index */}
				<SettingCard
					title='AI Search'
					description='Semantic file search powered by AI'
					icon={Brain}
				>
					<AISettings />
				</SettingCard>

				{/* Network Settings */}
				<SettingCard
					title='Network'
					description='Discovery, relays, and bandwidth limits'
					icon={Globe}
				>
					<NetworkSettings />
				</SettingCard>

				{/* System Logs */}
				<SettingCard
					title='System Logs'
					description='View Syncthing logs for debugging'
					icon={Bug}
				>
					<div className='space-y-3'>
						<p className='text-sm text-slate-400'>
							View real-time logs from Syncthing for
							troubleshooting connection issues and errors.
						</p>
						<Button
							variant='outline'
							size='sm'
							onClick={() => setLogViewerOpen(true)}
							className='w-full border-slate-700 bg-slate-800/50 hover:bg-slate-700'
						>
							<Bug className='mr-2 h-4 w-4' />
							Open Log Viewer
						</Button>
					</div>
				</SettingCard>

				{/* System Actions */}
				<SettingCard
					title='System Actions'
					description='Control Syncthing service'
					icon={RotateCw}
				>
					<div className='space-y-3'>
						<p className='text-sm text-slate-400'>
							Restart Syncthing to apply configuration changes
							that require a restart.
						</p>
						<Button
							variant='outline'
							size='sm'
							onClick={handleRestart}
							disabled={restartSyncthing.isPending}
							className='w-full border-orange-500/30 bg-orange-500/10 text-orange-400 hover:bg-orange-500/20'
						>
							{restartSyncthing.isPending ? (
								<>
									<RefreshCw className='mr-2 h-4 w-4 animate-spin' />
									Restarting...
								</>
							) : (
								<>
									<RotateCw className='mr-2 h-4 w-4' />
									Restart Syncthing
								</>
							)}
						</Button>
					</div>
				</SettingCard>
			</div>

			{/* About Section */}
			<Card className='border-slate-800 bg-slate-900/50 backdrop-blur-md'>
				<CardHeader>
					<CardTitle className='text-white'>About Eigen</CardTitle>
				</CardHeader>
				<CardContent>
					<div className='flex items-center justify-between'>
						<div>
							<p className='text-slate-300'>
								A modern Syncthing manager built with Tauri
							</p>
							<p className='mt-1 text-sm text-slate-500'>
								Version 0.1.0  Built with Next.js + Rust
							</p>
						</div>
						<Button
							variant='outline'
							size='sm'
							className='border-slate-700 bg-slate-800/50 hover:bg-slate-700'
							onClick={() =>
								window.open(
									'https://github.com/syncthing/syncthing',
									'_blank'
								)
							}
						>
							Syncthing Docs
						</Button>
					</div>
				</CardContent>
			</Card>

			{/* Log Viewer Modal */}
			<LogViewer open={logViewerOpen} onOpenChange={setLogViewerOpen} />
		</div>
	);
}
</file>

<file path="src/components/share-folder-dialog.tsx">
'use client';

import { useState } from 'react';
import { useConfig, useShareFolder } from '@/hooks/useSyncthing';
import { Button } from '@/components/ui/button';
import {
	Card,
	CardContent,
	CardHeader,
	CardTitle,
	CardDescription,
} from '@/components/ui/card';
import { X, Laptop, Check } from 'lucide-react';
import { toast } from 'sonner';
import { cn } from '@/lib/utils';

interface ShareFolderDialogProps {
	open: boolean;
	onOpenChange: (open: boolean) => void;
	folderId: string;
	folderLabel?: string;
}

export function ShareFolderDialog({
	open,
	onOpenChange,
	folderId,
	folderLabel,
}: ShareFolderDialogProps) {
	const [selectedDevice, setSelectedDevice] = useState<string | null>(null);
	const { data: config } = useConfig();
	const shareFolder = useShareFolder();

	const handleShare = async () => {
		if (!selectedDevice) return;

		try {
			await shareFolder.mutateAsync({
				folderId,
				deviceId: selectedDevice,
			});
			toast.success(`Folder shared with device`);
			onOpenChange(false);
			setSelectedDevice(null);
		} catch (error) {
			console.error('Share folder error:', error);
			toast.error(
				`Failed to share folder: ${
					error instanceof Error ? error.message : String(error)
				}`
			);
		}
	};

	if (!open) return null;

	// Filter out devices that already have this folder
	const availableDevices = config?.devices?.filter((device) => {
		// Find the current folder config
		const currentFolder = config.folders?.find((f) => f.id === folderId);
		// Check if this device is already in the folder's device list
		// Note: The backend returns 'devices' as an array of objects with 'deviceID'
		const isAlreadyShared = (currentFolder as any)?.devices?.some(
			(d: any) => d.deviceID === device.deviceID
		);
		return !isAlreadyShared;
	});

	return (
		<div className='fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm'>
			<Card className='w-full max-w-md border-slate-700 bg-slate-900 shadow-2xl'>
				<CardHeader className='relative'>
					<Button
						variant='ghost'
						size='icon'
						onClick={() => onOpenChange(false)}
						className='absolute right-4 top-4 text-slate-400 hover:text-white'
					>
						<X className='h-4 w-4' />
					</Button>
					<CardTitle className='text-xl text-white'>
						Share Folder
					</CardTitle>
					<CardDescription className='text-slate-400'>
						Select a device to sync "{folderLabel || folderId}"
						with.
					</CardDescription>
				</CardHeader>
				<CardContent className='space-y-4'>
					<div className='space-y-2'>
						{availableDevices?.length === 0 ? (
							<div className='py-8 text-center text-slate-500'>
								No new devices available to share with.
							</div>
						) : (
							availableDevices?.map((device) => (
								<div
									key={device.deviceID}
									onClick={() =>
										setSelectedDevice(device.deviceID)
									}
									className={cn(
										'flex cursor-pointer items-center justify-between rounded-lg border p-3 transition-all',
										selectedDevice === device.deviceID
											? 'border-indigo-500 bg-indigo-500/10'
											: 'border-slate-700 bg-slate-800 hover:border-slate-600'
									)}
								>
									<div className='flex items-center gap-3'>
										<div className='flex h-8 w-8 items-center justify-center rounded bg-slate-700'>
											<Laptop className='h-4 w-4 text-slate-300' />
										</div>
										<div className='flex flex-col'>
											<span className='text-sm font-medium text-white'>
												{device.name ||
													'Unnamed Device'}
											</span>
											<span className='font-mono text-[10px] text-slate-500'>
												{device.deviceID.slice(0, 12)}
												...
											</span>
										</div>
									</div>
									{selectedDevice === device.deviceID && (
										<Check className='h-4 w-4 text-indigo-400' />
									)}
								</div>
							))
						)}
					</div>

					<div className='flex justify-end gap-3 pt-2'>
						<Button
							variant='outline'
							onClick={() => onOpenChange(false)}
							className='border-slate-700 bg-transparent hover:bg-slate-800'
						>
							Cancel
						</Button>
						<Button
							onClick={handleShare}
							disabled={!selectedDevice || shareFolder.isPending}
							className='bg-indigo-600 hover:bg-indigo-700'
						>
							{shareFolder.isPending ? 'Sharing...' : 'Share'}
						</Button>
					</div>
				</CardContent>
			</Card>
		</div>
	);
}
</file>

<file path="src/components/sidebar.tsx">
'use client';

import { useEffect } from 'react';
import { useAppStore } from '@/store';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import {
	LayoutDashboard,
	Folder,
	Laptop,
	Settings,
	ChevronLeft,
	ChevronRight,
	Zap,
	ScrollText,
} from 'lucide-react';

const navItems = [
	{ id: 'dashboard' as const, label: 'Dashboard', icon: LayoutDashboard },
	{ id: 'folders' as const, label: 'Folders', icon: Folder },
	{ id: 'devices' as const, label: 'Devices', icon: Laptop },
	{ id: 'logs' as const, label: 'Logs', icon: ScrollText },
	{ id: 'settings' as const, label: 'Settings', icon: Settings },
];

export function Sidebar() {
	const { sidebarOpen, toggleSidebar, activeTab, setActiveTab } =
		useAppStore();

	// Listen for navigation events from toast notifications
	useEffect(() => {
		const handleNavigate = (event: CustomEvent<string>) => {
			const tab = event.detail as typeof activeTab;
			if (
				[
					'dashboard',
					'folders',
					'devices',
					'settings',
					'logs',
				].includes(tab)
			) {
				setActiveTab(tab);
			}
		};

		window.addEventListener(
			'navigate-to-tab',
			handleNavigate as EventListener
		);
		return () => {
			window.removeEventListener(
				'navigate-to-tab',
				handleNavigate as EventListener
			);
		};
	}, [setActiveTab]);

	return (
		<aside
			className={cn(
				'flex h-full flex-col border-r border-slate-800 bg-slate-950/50 backdrop-blur-xl transition-all duration-300',
				sidebarOpen ? 'w-64' : 'w-16'
			)}
		>
			{/* Logo */}
			<div className='flex h-16 items-center gap-3 border-b border-slate-800 px-4'>
				<div className='flex h-8 w-8 items-center justify-center rounded-lg bg-gradient-to-br from-indigo-500 to-purple-600'>
					<Zap className='h-4 w-4 text-white' />
				</div>
				{sidebarOpen && (
					<span className='text-lg font-bold text-white'>Eigen</span>
				)}
			</div>

			{/* Navigation */}
			<nav className='flex-1 space-y-1 p-3'>
				{navItems.map((item) => (
					<Button
						key={item.id}
						variant='ghost'
						className={cn(
							'w-full justify-start gap-3 text-slate-400 hover:bg-slate-800/50 hover:text-white',
							activeTab === item.id &&
								'bg-slate-800/50 text-white',
							!sidebarOpen && 'justify-center px-2'
						)}
						onClick={() => setActiveTab(item.id)}
					>
						<item.icon className='h-5 w-5 shrink-0' />
						{sidebarOpen && <span>{item.label}</span>}
					</Button>
				))}
			</nav>

			{/* Toggle Button */}
			<div className='border-t border-slate-800 p-3'>
				<Button
					variant='ghost'
					size='sm'
					className='w-full justify-center text-slate-400 hover:bg-slate-800/50 hover:text-white'
					onClick={toggleSidebar}
				>
					{sidebarOpen ? (
						<ChevronLeft className='h-4 w-4' />
					) : (
						<ChevronRight className='h-4 w-4' />
					)}
				</Button>
			</div>
		</aside>
	);
}
</file>

<file path="src/components/stats-overview.tsx">
'use client';

import { useSystemStatus, useConnections } from '@/hooks/useSyncthing';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Skeleton } from '@/components/ui/skeleton';
import { formatUptime, formatBytes } from '@/lib/utils';
import { motion } from 'framer-motion';
import {
	Activity,
	HardDrive,
	Network,
	Clock,
	ArrowDownToLine,
	ArrowUpFromLine,
} from 'lucide-react';

const cardVariants = {
	hidden: { opacity: 0, y: 20, scale: 0.95 },
	visible: (i: number) => ({
		opacity: 1,
		y: 0,
		scale: 1,
		transition: {
			delay: i * 0.1,
			type: 'spring' as const,
			stiffness: 300,
			damping: 25,
		},
	}),
};

function StatCard({
	title,
	value,
	icon: Icon,
	isLoading,
	badge,
	index = 0,
}: {
	title: string;
	value: string;
	icon: React.ComponentType<{ className?: string }>;
	isLoading: boolean;
	badge?: { label: string; variant: 'success' | 'warning' | 'destructive' };
	index?: number;
}) {
	return (
		<motion.div
			variants={cardVariants}
			initial='hidden'
			animate='visible'
			custom={index}
			whileHover={{
				y: -4,
				transition: { type: 'spring', stiffness: 400, damping: 25 },
			}}
		>
			<Card className='border-slate-800 bg-slate-900/50 backdrop-blur-md'>
				<CardHeader className='flex flex-row items-center justify-between space-y-0 pb-2'>
					<CardTitle className='text-sm font-medium text-slate-300'>
						{title}
					</CardTitle>
					<Icon className='h-4 w-4 text-slate-400' />
				</CardHeader>
				<CardContent>
					{isLoading ? (
						<Skeleton className='h-8 w-24' />
					) : (
						<div className='flex items-center gap-2'>
							<motion.div
								className='text-2xl font-bold text-white'
								key={value}
								initial={{ opacity: 0, scale: 0.8 }}
								animate={{ opacity: 1, scale: 1 }}
								transition={{
									type: 'spring',
									stiffness: 500,
									damping: 30,
								}}
							>
								{value}
							</motion.div>
							{badge && (
								<Badge
									variant={badge.variant}
									className='text-xs'
								>
									{badge.label}
								</Badge>
							)}
						</div>
					)}
				</CardContent>
			</Card>
		</motion.div>
	);
}

export function StatsOverview() {
	const {
		data: status,
		isLoading: statusLoading,
		isError: statusError,
	} = useSystemStatus();
	const { data: connections, isLoading: connectionsLoading } =
		useConnections();

	const isLoading = statusLoading || connectionsLoading;

	// Calculate connected devices
	const connectedDevices = Object.values(
		connections?.connections || {}
	).filter((c) => c?.connected).length;
	const totalDevices = Object.keys(connections?.connections || {}).length;

	// Calculate transfer stats
	const inBytes = connections?.total?.inBytesTotal || 0;
	const outBytes = connections?.total?.outBytesTotal || 0;

	return (
		<div className='grid gap-4 md:grid-cols-2 lg:grid-cols-4'>
			<StatCard
				title='Status'
				value={statusError ? 'Offline' : 'Online'}
				icon={Activity}
				isLoading={isLoading}
				index={0}
				badge={
					statusError
						? { label: 'Disconnected', variant: 'destructive' }
						: { label: 'Connected', variant: 'success' }
				}
			/>
			<StatCard
				title='Uptime'
				value={status?.uptime ? formatUptime(status.uptime) : ''}
				icon={Clock}
				isLoading={isLoading}
				index={1}
			/>
			<StatCard
				title='Devices'
				value={`${connectedDevices}/${totalDevices}`}
				icon={Network}
				isLoading={isLoading}
				index={2}
				badge={
					connectedDevices === totalDevices && totalDevices > 0
						? { label: 'All Connected', variant: 'success' }
						: undefined
				}
			/>
			<StatCard
				title='Goroutines'
				value={status?.goroutines?.toString() || ''}
				icon={HardDrive}
				isLoading={isLoading}
				index={3}
			/>
			<StatCard
				title='Downloaded'
				value={formatBytes(inBytes)}
				icon={ArrowDownToLine}
				isLoading={isLoading}
				index={4}
			/>
			<StatCard
				title='Uploaded'
				value={formatBytes(outBytes)}
				icon={ArrowUpFromLine}
				isLoading={isLoading}
				index={5}
			/>
		</div>
	);
}
</file>

<file path="src/components/syncthing-manager.tsx">
'use client';

import { useEffect, useRef, useCallback } from 'react';
import { invoke } from '@tauri-apps/api/core';
import {
	useStartSyncthing,
	useSystemStatus,
	useSyncthingInstallation,
	useSyncthingEvents,
	SyncthingEvent,
} from '@/hooks/useSyncthing';
import { useNativeNotifications } from '@/hooks/useNotifications';
import { toast } from 'sonner';

/**
 * Updates the system tray tooltip with current sync status
 */
async function updateTrayStatus(status: string, details: string) {
	try {
		const tooltip = `Eigen - ${status}\n${details}`;
		await invoke('update_tray_status', {
			status,
			tooltip,
		});
	} catch (error) {
		// Silently fail - tray might not be available
		console.debug('Could not update tray status:', error);
	}
}

/**
 * Component that manages Syncthing lifecycle.
 * Checks installation and auto-starts Syncthing when the app loads.
 * Also handles device discovery notifications via the Event API.
 */
// Cooldown period for device notifications (in milliseconds)
const DEVICE_NOTIFICATION_COOLDOWN = 60000; // 1 minute

export function SyncthingManager({ children }: { children: React.ReactNode }) {
	const { data: installation, isLoading: checkingInstallation } =
		useSyncthingInstallation();
	const startSyncthing = useStartSyncthing();
	const { data: status, isError } = useSystemStatus();
	const hasAttemptedStart = useRef(false);
	const installationToastShown = useRef(false);
	const connectedToastShown = useRef(false);

	// Track last notification time per device to prevent spam
	const deviceNotificationTimestamps = useRef<Map<string, number>>(new Map());

	// Native notifications hook
	const { notifyDeviceEvent, notifyFolderEvent } = useNativeNotifications();

	/**
	 * Check if we should show a notification for a device event
	 * Returns true if cooldown has passed, false if we should skip
	 */
	const shouldNotifyDevice = useCallback(
		(deviceId: string, eventType: string): boolean => {
			const key = `${deviceId}-${eventType}`;
			const now = Date.now();
			const lastNotified = deviceNotificationTimestamps.current.get(key);

			if (
				lastNotified &&
				now - lastNotified < DEVICE_NOTIFICATION_COOLDOWN
			) {
				return false;
			}

			deviceNotificationTimestamps.current.set(key, now);
			return true;
		},
		[]
	);

	// Handle incoming Syncthing events
	const handleEvent = useCallback(
		(event: SyncthingEvent) => {
			switch (event.type) {
				case 'DeviceRejected': {
					// A device tried to connect but isn't in our config
					const deviceName =
						event.data?.name ||
						event.data?.device?.slice(0, 7) ||
						'Unknown';
					toast.warning('New Device Wants to Connect', {
						description: `Device ${deviceName} is trying to connect.`,
						duration: 15000,
						action: {
							label: 'View Devices',
							onClick: () => {
								// Navigate to devices tab
								window.dispatchEvent(
									new CustomEvent('navigate-to-tab', {
										detail: 'devices',
									})
								);
							},
						},
					});
					// Also send native notification (shown when window is hidden)
					notifyDeviceEvent('rejected', deviceName);
					break;
				}

				case 'FolderRejected': {
					// A folder was shared to us but isn't in our config
					const folderName =
						event.data?.folderLabel ||
						event.data?.folder ||
						'Unknown';
					const fromDevice =
						event.data?.device?.slice(0, 7) || 'A device';
					toast.info('Folder Shared With You', {
						description: `Device ${fromDevice} wants to share folder "${folderName}".`,
						duration: 15000,
						action: {
							label: 'View Folders',
							onClick: () => {
								window.dispatchEvent(
									new CustomEvent('navigate-to-tab', {
										detail: 'folders',
									})
								);
							},
						},
					});
					// Native notification
					notifyFolderEvent('shared', folderName, fromDevice);
					break;
				}

				case 'DeviceConnected': {
					const deviceId = event.data?.id || 'unknown';
					const deviceName =
						event.data?.deviceName ||
						event.data?.id?.slice(0, 7) ||
						'Device';

					// Rate limit notifications per device
					if (!shouldNotifyDevice(deviceId, 'connected')) {
						break;
					}

					toast.success('Device Connected', {
						description: `${deviceName} is now online.`,
						duration: 5000,
					});
					// Native notification
					notifyDeviceEvent('connected', deviceName);
					break;
				}

				case 'DeviceDisconnected': {
					const deviceId = event.data?.id || 'unknown';
					const deviceName =
						event.data?.deviceName ||
						event.data?.id?.slice(0, 7) ||
						'Device';

					// Rate limit notifications per device to prevent spam
					if (!shouldNotifyDevice(deviceId, 'disconnected')) {
						break;
					}

					toast.info('Device Disconnected', {
						description: `${deviceName} went offline.`,
						duration: 5000,
					});
					// Native notification
					notifyDeviceEvent('disconnected', deviceName);
					break;
				}

				case 'FolderCompletion':
					// Only show when folder reaches 100%
					if (event.data?.completion === 100) {
						const folderName = event.data?.folder || 'Folder';
						toast.success('Sync Complete', {
							description: `Folder "${folderName}" is now in sync.`,
							duration: 3000,
						});
						// Native notification for sync complete
						notifyFolderEvent('synced', folderName);
					}
					break;

				case 'FolderErrors':
					if (event.data?.errors?.length > 0) {
						const folderName = event.data?.folder || 'Folder';
						const errorCount = event.data.errors.length;
						toast.error('Sync Errors', {
							description: `Folder "${folderName}" has ${errorCount} error(s).`,
							duration: 10000,
						});
						// Native notification for errors
						notifyFolderEvent(
							'error',
							folderName,
							`${errorCount} error(s)`
						);
					}
					break;
			}
		},
		[notifyDeviceEvent, notifyFolderEvent, shouldNotifyDevice]
	);

	// Subscribe to Syncthing events when connected
	const { isPolling } = useSyncthingEvents({
		onEvent: handleEvent,
		enabled: !!status?.myID,
	});

	// Check installation status
	useEffect(() => {
		if (checkingInstallation || installationToastShown.current) return;

		if (installation && !installation.installed) {
			installationToastShown.current = true;
			toast.error('Syncthing not installed', {
				description:
					'Please install Syncthing to use this app. Run: sudo apt install syncthing',
				duration: 15000,
				action: {
					label: 'Learn More',
					onClick: () =>
						window.open(
							'https://syncthing.net/downloads/',
							'_blank'
						),
				},
			});
		} else if (installation?.installed && installation.version) {
			console.log(
				'Syncthing found:',
				installation.version,
				'at',
				installation.path
			);
		}
	}, [installation, checkingInstallation]);

	// Auto-start Syncthing if installed but not responding
	useEffect(() => {
		if (hasAttemptedStart.current) return;
		if (!installation?.installed) return;

		// If we get an error (Syncthing not responding), try to start it
		if (isError && !startSyncthing.isPending) {
			hasAttemptedStart.current = true;

			console.log('Syncthing not responding, attempting to start...');

			startSyncthing.mutate(undefined, {
				onSuccess: (message) => {
					console.log('Syncthing start result:', message);
					toast.success('Starting Syncthing...', {
						description: 'Please wait while Syncthing initializes.',
					});
				},
				onError: (err) => {
					console.error('Failed to start Syncthing:', err);
					toast.error('Failed to start Syncthing', {
						description:
							err instanceof Error
								? err.message
								: 'Unknown error',
						duration: 10000,
					});
				},
			});
		}
	}, [isError, startSyncthing, installation?.installed]);

	// Show success toast when Syncthing connects
	useEffect(() => {
		if (status?.myID && !connectedToastShown.current) {
			connectedToastShown.current = true;
			toast.success('Connected to Syncthing', {
				description: `Device ID: ${status.myID.slice(0, 7)}...`,
			});
		}
	}, [status?.myID]);

	// Update tray status based on connection and sync state
	useEffect(() => {
		if (!status?.myID) {
			updateTrayStatus('Disconnected', 'Syncthing is not running');
			return;
		}

		// Connected to Syncthing
		const uptime = status.uptime ? Math.floor(status.uptime / 60) : 0;
		const uptimeStr =
			uptime > 60
				? `${Math.floor(uptime / 60)}h ${uptime % 60}m`
				: `${uptime}m`;

		if (isPolling) {
			updateTrayStatus(
				'Connected',
				`Uptime: ${uptimeStr}  Listening for events`
			);
		} else {
			updateTrayStatus('Connected', `Uptime: ${uptimeStr}`);
		}
	}, [status?.myID, status?.uptime, isPolling]);

	return <>{children}</>;
}
</file>

<file path="src/hooks/useAISearch.ts">
/**
 * useAISearch - Hook for semantic file search using AI embeddings
 * 
 * Manages a Web Worker running transformers.js for:
 * - Generating file path embeddings
 * - Semantic similarity search
 */

import { useCallback, useEffect, useRef, useState } from 'react';
import { storeEmbedding, getAllEmbeddings, type FileEmbedding } from '@/lib/db';

export type AIStatus = 'idle' | 'loading' | 'ready' | 'error' | 'disabled';

interface AIWorkerMessage {
    id?: string;
    type: string;
    payload?: unknown;
}

interface SearchResult {
    path: string;
    score: number;
}

interface UseAISearchOptions {
    enabled?: boolean;
}

interface UseAISearchReturn {
    status: AIStatus;
    statusMessage: string;
    isReady: boolean;
    initialize: () => Promise<void>;
    generateEmbeddings: (texts: string[]) => Promise<number[][]>;
    indexFiles: (files: { path: string; name: string }[]) => Promise<void>;
    search: (query: string, folderId?: string) => Promise<SearchResult[]>;
    progress: { current: number; total: number } | null;
}

export function useAISearch(options: UseAISearchOptions = {}): UseAISearchReturn {
    const { enabled = true } = options;

    const workerRef = useRef<Worker | null>(null);
    const pendingCallsRef = useRef<Map<string, { resolve: (value: unknown) => void; reject: (error: Error) => void }>>(new Map());
    const callIdRef = useRef(0);

    const [status, setStatus] = useState<AIStatus>(enabled ? 'idle' : 'disabled');
    const [statusMessage, setStatusMessage] = useState(enabled ? '' : 'AI features are disabled');
    const [progress, setProgress] = useState<{ current: number; total: number } | null>(null);

    // Initialize worker only when enabled
    useEffect(() => {
        if (!enabled) {
            // Clean up existing worker if disabled
            if (workerRef.current) {
                workerRef.current.terminate();
                workerRef.current = null;
            }
            setStatus('disabled');
            setStatusMessage('AI features are disabled');
            return;
        }

        // Create worker - using the bundled worker file
        const worker = new Worker(new URL('../workers/ai.worker.ts', import.meta.url), {
            type: 'module',
        });

        worker.onmessage = (event: MessageEvent<AIWorkerMessage>) => {
            const { id, type, payload } = event.data;

            // Handle status updates
            if (type === 'status' && payload && typeof payload === 'object') {
                const statusPayload = payload as { status?: string; message?: string };
                if (statusPayload.status === 'loading') {
                    setStatus('loading');
                    setStatusMessage(statusPayload.message || 'Loading model...');
                } else if (statusPayload.status === 'ready') {
                    setStatus('ready');
                    setStatusMessage(statusPayload.message || 'Ready');
                } else if (statusPayload.status === 'error') {
                    setStatus('error');
                    setStatusMessage(statusPayload.message || 'Error');
                }
            }

            // Handle responses to calls
            if (id) {
                const pending = pendingCallsRef.current.get(id);
                if (pending) {
                    if (type === 'error') {
                        const errorPayload = payload as { message?: string };
                        pending.reject(new Error(errorPayload?.message || 'Worker error'));
                    } else {
                        pending.resolve(payload);
                    }
                    pendingCallsRef.current.delete(id);
                }
            }
        };

        worker.onerror = (error) => {
            console.error('AI Worker error:', error);
            setStatus('error');
            setStatusMessage('Worker error');
        };

        workerRef.current = worker;

        return () => {
            worker.terminate();
            workerRef.current = null;
        };
    }, [enabled]);

    // Send message to worker and wait for response
    const sendMessage = useCallback(
        <T>(type: string, payload?: unknown, timeoutMs = 120000): Promise<T> => {
            return new Promise((resolve, reject) => {
                if (!workerRef.current) {
                    reject(new Error('Worker not initialized'));
                    return;
                }

                const id = `call-${++callIdRef.current}`;

                const timeoutId = setTimeout(() => {
                    if (pendingCallsRef.current.has(id)) {
                        pendingCallsRef.current.delete(id);
                        reject(new Error(`Worker call timed out after ${timeoutMs / 1000}s for operation: ${type}`));
                    }
                }, timeoutMs);

                pendingCallsRef.current.set(id, {
                    resolve: (value: unknown) => {
                        clearTimeout(timeoutId);
                        resolve(value as T);
                    },
                    reject: (error: Error) => {
                        clearTimeout(timeoutId);
                        reject(error);
                    },
                });

                workerRef.current.postMessage({ id, type, payload });
            });
        },
        []
    );

    // Initialize the model
    const initialize = useCallback(async () => {
        if (!enabled) return;
        if (status === 'ready' || status === 'loading') return;
        setStatus('loading');
        try {
            // Model loading/downloading can take 5+ minutes on slow connections
            await sendMessage('init', undefined, 300000);
        } catch (error) {
            console.error('Failed to initialize AI model:', error);
            setStatus('error');
            setStatusMessage(error instanceof Error ? error.message : 'Failed to initialize');
        }
    }, [enabled, status, sendMessage]);

    // Generate embeddings for texts
    const generateEmbeddings = useCallback(
        async (texts: string[]): Promise<number[][]> => {
            if (!enabled) return [];
            // Embedding generation: 60 seconds should be enough for a batch
            const result = await sendMessage<{ embeddings: number[][] }>('embed', { texts }, 60000);
            return result.embeddings;
        },
        [enabled, sendMessage]
    );

    // Index files - generate and store embeddings
    const indexFiles = useCallback(
        async (files: { path: string; name: string }[]) => {
            if (!enabled) return;
            if (files.length === 0) return;

            setProgress({ current: 0, total: files.length });

            const batchSize = 10;

            for (let i = 0; i < files.length; i += batchSize) {
                const batch = files.slice(i, i + batchSize);
                const texts = batch.map((f) => `${f.name} ${f.path}`);

                try {
                    const embeddings = await generateEmbeddings(texts);

                    // Save to IndexedDB
                    for (let j = 0; j < batch.length; j++) {
                        await storeEmbedding({
                            path: batch[j].path,
                            embedding: embeddings[j],
                            model: 'all-MiniLM-L6-v2',
                            createdAt: Date.now(),
                        });
                    }
                } catch (error) {
                    console.error('Error indexing batch:', error);
                }

                setProgress({ current: Math.min(i + batchSize, files.length), total: files.length });
            }

            setProgress(null);
        },
        [enabled, generateEmbeddings]
    );

    // Semantic search
    const search = useCallback(
        async (query: string, folderId?: string): Promise<SearchResult[]> => {
            if (!enabled) return [];
            if (!query.trim()) return [];

            // Get stored embeddings
            const storedEmbeddings = await getAllEmbeddings();

            // TODO: Filter by folderId if provided (need to join with files table)
            const embeddings = storedEmbeddings.map((e: FileEmbedding) => ({
                path: e.path,
                embedding: e.embedding,
            }));

            if (embeddings.length === 0) {
                return [];
            }

            // Search should be fast, 30 seconds is plenty
            const result = await sendMessage<{ results: SearchResult[] }>('search', {
                query,
                embeddings,
                topK: 20,
            }, 30000);

            return result.results;
        },
        [enabled, sendMessage]
    );

    return {
        status,
        statusMessage,
        isReady: status === 'ready',
        initialize,
        generateEmbeddings,
        indexFiles,
        search,
        progress,
    };
}
</file>

<file path="src/hooks/useNotifications.ts">
'use client';

import { useEffect, useState, useCallback } from 'react';
import {
    isPermissionGranted,
    requestPermission,
    sendNotification,
} from '@tauri-apps/plugin-notification';
import { useAppStore } from '@/store';

export type NotificationPriority = 'low' | 'normal' | 'high';

export interface NotificationOptions {
    title: string;
    body: string;
    priority?: NotificationPriority;
}

/**
 * Hook for sending native OS notifications
 */
export function useNativeNotifications() {
    const [permissionGranted, setPermissionGranted] = useState(false);
    const [initialized, setInitialized] = useState(false);
    const nativeNotificationsEnabled = useAppStore((s) => s.nativeNotificationsEnabled);

    // Check and request permission on mount
    useEffect(() => {
        async function checkPermission() {
            try {
                let granted = await isPermissionGranted();

                if (!granted) {
                    const permission = await requestPermission();
                    granted = permission === 'granted';
                }

                setPermissionGranted(granted);
            } catch (error) {
                console.debug('Notification permission check failed:', error);
                setPermissionGranted(false);
            } finally {
                setInitialized(true);
            }
        }

        checkPermission();
    }, []);

    /**
     * Send a native notification
     */
    const notify = useCallback(
        async ({ title, body }: NotificationOptions) => {
            // Check if notifications are enabled in settings
            if (!nativeNotificationsEnabled) {
                return false;
            }

            if (!permissionGranted) {
                console.debug('Notifications not permitted');
                return false;
            }

            try {
                await sendNotification({
                    title,
                    body,
                });
                return true;
            } catch (error) {
                console.error('Failed to send notification:', error);
                return false;
            }
        },
        [permissionGranted, nativeNotificationsEnabled]
    );

    /**
     * Quick notification for device events
     */
    const notifyDeviceEvent = useCallback(
        (type: 'connected' | 'disconnected' | 'rejected', deviceName: string) => {
            const messages = {
                connected: {
                    title: 'Device Connected',
                    body: `${deviceName} is now online`,
                },
                disconnected: {
                    title: 'Device Disconnected',
                    body: `${deviceName} went offline`,
                },
                rejected: {
                    title: 'New Device Request',
                    body: `${deviceName} wants to connect`,
                },
            };

            return notify(messages[type]);
        },
        [notify]
    );

    /**
     * Quick notification for folder events
     */
    const notifyFolderEvent = useCallback(
        (
            type: 'synced' | 'error' | 'shared',
            folderName: string,
            extra?: string
        ) => {
            const messages = {
                synced: {
                    title: 'Sync Complete',
                    body: `${folderName} is now up to date`,
                },
                error: {
                    title: 'Sync Error',
                    body: `${folderName}: ${extra || 'An error occurred'}`,
                },
                shared: {
                    title: 'Folder Shared',
                    body: `${extra || 'A device'} shared ${folderName} with you`,
                },
            };

            return notify(messages[type]);
        },
        [notify]
    );

    return {
        initialized,
        permissionGranted,
        notify,
        notifyDeviceEvent,
        notifyFolderEvent,
    };
}
</file>

<file path="src/hooks/useSyncthing.ts">
"use client";

import { invoke } from "@tauri-apps/api/core";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { z } from "zod";
import { useEffect, useRef, useCallback, useState } from "react";
import { useAppStore } from "@/store";

// ============================================================================
// Zod Schemas for Type Safety
// ============================================================================

export const SyncthingInfoSchema = z.object({
    installed: z.boolean(),
    version: z.string().nullable().optional(),
    path: z.string().nullable().optional(),
});

export type SyncthingInfo = z.infer<typeof SyncthingInfoSchema>;

export const SystemStatusSchema = z.object({
    myID: z.string().optional(),
    uptime: z.number().optional(),
    allPeersConnected: z.boolean().optional(),
    goroutines: z.number().optional(),
    sys: z.number().optional(),
    startTime: z.string().optional(),
}).passthrough();

export const ConnectionInfoSchema = z.object({
    connected: z.boolean().optional(),
    paused: z.boolean().optional(),
    address: z.string().optional(),
    type: z.string().optional(),
    clientVersion: z.string().optional(),
    crypto: z.string().optional(),
}).passthrough();

export const ConnectionsSchema = z.object({
    total: z.object({
        at: z.string().optional(),
        inBytesTotal: z.number().optional(),
        outBytesTotal: z.number().optional(),
    }).optional(),
    connections: z.record(z.string(), ConnectionInfoSchema).optional(),
}).passthrough();

// Versioning schema
export const VersioningConfigSchema = z.object({
    type: z.string().optional(),
    params: z.record(z.string(), z.string()).optional(),
    cleanupIntervalS: z.number().optional(),
    fsPath: z.string().optional(),
    fsType: z.string().optional(),
}).passthrough();

// Folder device reference schema
export const FolderDeviceSchema = z.object({
    deviceID: z.string(),
    introducedBy: z.string().optional(),
    encryptionPassword: z.string().optional(),
}).passthrough();

export const FolderConfigSchema = z.object({
    id: z.string(),
    label: z.string().optional(),
    path: z.string().optional(),
    paused: z.boolean().optional(),
    type: z.string().optional(),
    rescanIntervalS: z.number().optional(),
    fsWatcherEnabled: z.boolean().optional(),
    fsWatcherDelayS: z.number().optional(),
    ignorePerms: z.boolean().optional(),
    versioning: VersioningConfigSchema.optional(),
    devices: z.array(FolderDeviceSchema).optional(),
}).passthrough();

export const DeviceConfigSchema = z.object({
    deviceID: z.string(),
    name: z.string().optional(),
    paused: z.boolean().optional(),
    addresses: z.array(z.string()).optional(),
    compression: z.string().optional(),
    introducer: z.boolean().optional(),
    autoAcceptFolders: z.boolean().optional(),
    maxSendKbps: z.number().optional(),
    maxRecvKbps: z.number().optional(),
}).passthrough();

// Global options schema
export const OptionsSchema = z.object({
    listenAddresses: z.array(z.string()).optional(),
    globalAnnounceServers: z.array(z.string()).optional(),
    globalAnnounceEnabled: z.boolean().optional(),
    localAnnounceEnabled: z.boolean().optional(),
    localAnnouncePort: z.number().optional(),
    localAnnounceMCAddr: z.string().optional(),
    maxSendKbps: z.number().optional(),
    maxRecvKbps: z.number().optional(),
    reconnectionIntervalS: z.number().optional(),
    relaysEnabled: z.boolean().optional(),
    relayReconnectIntervalM: z.number().optional(),
    startBrowser: z.boolean().optional(),
    natEnabled: z.boolean().optional(),
    natLeaseMinutes: z.number().optional(),
    natRenewalMinutes: z.number().optional(),
    natTimeoutSeconds: z.number().optional(),
    urAccepted: z.number().optional(),
    urSeen: z.number().optional(),
    urUniqueId: z.string().optional(),
    urURL: z.string().optional(),
    urPostInsecurely: z.boolean().optional(),
    urInitialDelayS: z.number().optional(),
    autoUpgradeIntervalH: z.number().optional(),
    upgradeToPreReleases: z.boolean().optional(),
    keepTemporariesH: z.number().optional(),
    cacheIgnoredFiles: z.boolean().optional(),
    progressUpdateIntervalS: z.number().optional(),
    limitBandwidthInLan: z.boolean().optional(),
    minHomeDiskFree: z.object({
        value: z.number(),
        unit: z.string(),
    }).optional(),
    releasesURL: z.string().optional(),
    alwaysLocalNets: z.array(z.string()).optional(),
    overwriteRemoteDeviceNamesOnConnect: z.boolean().optional(),
    tempIndexMinBlocks: z.number().optional(),
    unackedNotificationIDs: z.array(z.string()).optional(),
    trafficClass: z.number().optional(),
    setLowPriority: z.boolean().optional(),
    maxFolderConcurrency: z.number().optional(),
    crashReportingURL: z.string().optional(),
    crashReportingEnabled: z.boolean().optional(),
    stunKeepaliveStartS: z.number().optional(),
    stunKeepaliveMinS: z.number().optional(),
    stunServers: z.array(z.string()).optional(),
    databaseTuning: z.string().optional(),
    maxConcurrentIncomingRequestKiB: z.number().optional(),
    announceLANAddresses: z.boolean().optional(),
    sendFullIndexOnUpgrade: z.boolean().optional(),
    featureFlags: z.array(z.string()).optional(),
    connectionLimitEnough: z.number().optional(),
    connectionLimitMax: z.number().optional(),
    insecureAllowOldTLSVersions: z.boolean().optional(),
}).passthrough();

export const ConfigSchema = z.object({
    folders: z.array(FolderConfigSchema).optional(),
    devices: z.array(DeviceConfigSchema).optional(),
    options: OptionsSchema.optional(),
}).passthrough();

export const FolderStatusSchema = z.object({
    globalFiles: z.number().optional(),
    globalBytes: z.number().optional(),
    localFiles: z.number().optional(),
    localBytes: z.number().optional(),
    needFiles: z.number().optional(),
    needBytes: z.number().optional(),
    state: z.string().optional(),
    stateChanged: z.string().optional(),
}).passthrough();

// Ignore patterns schema
export const IgnorePatternsSchema = z.object({
    ignore: z.array(z.string()).optional(),
    expanded: z.array(z.string()).optional(),
}).passthrough();

// Log entry schema
export const LogEntrySchema = z.object({
    when: z.string(),
    message: z.string(),
    level: z.number().optional(),
}).passthrough();

export const SystemLogsSchema = z.object({
    messages: z.array(LogEntrySchema).optional(),
}).passthrough();

// Event schema
export const SyncthingEventSchema = z.object({
    id: z.number(),
    globalID: z.number().optional(),
    time: z.string(),
    type: z.string(),
    data: z.any(),
}).passthrough();

// ============================================================================
// Types
// ============================================================================

export type SystemStatus = z.infer<typeof SystemStatusSchema>;
export type Connections = z.infer<typeof ConnectionsSchema>;
export type ConnectionInfo = z.infer<typeof ConnectionInfoSchema>;
export type Config = z.infer<typeof ConfigSchema>;
export type Options = z.infer<typeof OptionsSchema>;
export type FolderConfig = z.infer<typeof FolderConfigSchema>;
export type DeviceConfig = z.infer<typeof DeviceConfigSchema>;
export type FolderStatus = z.infer<typeof FolderStatusSchema>;
export type VersioningConfig = z.infer<typeof VersioningConfigSchema>;
export type IgnorePatterns = z.infer<typeof IgnorePatternsSchema>;
export type SystemLogs = z.infer<typeof SystemLogsSchema>;
export type LogEntry = z.infer<typeof LogEntrySchema>;
export type SyncthingEvent = z.infer<typeof SyncthingEventSchema>;

// Advanced folder options
export interface AdvancedFolderOptions {
    folderId: string;
    folderLabel: string;
    folderPath: string;
    versioningType?: "simple" | "staggered" | "trashcan" | "external" | "";
    versioningParams?: Record<string, string>;
    rescanIntervalS?: number;
    fsWatcherEnabled?: boolean;
    fsWatcherDelayS?: number;
    ignorePerms?: boolean;
}

// Advanced device options
export interface AdvancedDeviceOptions {
    deviceId: string;
    name: string;
    addresses?: string[];
    compression?: "metadata" | "always" | "never";
    introducer?: boolean;
    autoAcceptFolders?: boolean;
    maxSendKbps?: number;
    maxRecvKbps?: number;
}

// ============================================================================
// Query Hooks
// ============================================================================

/**
 * Check if Syncthing is installed on the system
 */
export function useSyncthingInstallation() {
    return useQuery({
        queryKey: ["syncthingInstallation"],
        queryFn: async () => {
            const data = await invoke("check_syncthing_installation");
            return SyncthingInfoSchema.parse(data);
        },
        staleTime: Infinity, // Installation status doesn't change often
        retry: 1,
    });
}

/**
 * Get Syncthing system status with polling
 */
export function useSystemStatus() {
    const pollingInterval = useAppStore((state) => state.pollingInterval);

    return useQuery({
        queryKey: ["systemStatus"],
        queryFn: async () => {
            const data = await invoke("get_system_status");
            return SystemStatusSchema.parse(data);
        },
        refetchInterval: pollingInterval,
        retry: 3,
        retryDelay: 1000,
        refetchOnWindowFocus: false,
        staleTime: pollingInterval - 1000,
    });
}

/**
 * Get Syncthing connections info with polling
 */
export function useConnections() {
    const pollingInterval = useAppStore((state) => state.pollingInterval);

    return useQuery({
        queryKey: ["connections"],
        queryFn: async () => {
            const data = await invoke("get_connections");
            return ConnectionsSchema.parse(data);
        },
        refetchInterval: pollingInterval,
        retry: 3,
        retryDelay: 1000,
        refetchOnWindowFocus: false,
        staleTime: pollingInterval - 1000,
    });
}

/**
 * Get Syncthing configuration
 */
export function useConfig() {
    return useQuery({
        queryKey: ["config"],
        queryFn: async () => {
            const data = await invoke("get_config");
            return ConfigSchema.parse(data);
        },
        refetchInterval: 30000, // Less frequent refresh for config
        refetchOnWindowFocus: false,
        staleTime: 25000,
        retry: 3,
        retryDelay: 1000,
    });
}

/**
 * Get folder status
 */
export function useFolderStatus(folderId: string) {
    const pollingInterval = useAppStore((state) => state.pollingInterval);
    // Folder status polls faster (2x the rate)
    const folderPollingInterval = Math.max(pollingInterval / 2, 1000);

    return useQuery({
        queryKey: ["folderStatus", folderId],
        queryFn: async () => {
            const data = await invoke("get_folder_status", { folderId });
            return FolderStatusSchema.parse(data);
        },
        refetchInterval: folderPollingInterval,
        enabled: !!folderId,
        retry: 3,
        retryDelay: 1000,
    });
}

// ============================================================================
// Mutation Hooks
// ============================================================================

/**
 * Start Syncthing sidecar
 */
export function useStartSyncthing() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async () => {
            return await invoke<string>("start_syncthing_sidecar");
        },
        onSuccess: () => {
            // Wait a bit for syncthing to start, then refetch
            setTimeout(() => {
                queryClient.invalidateQueries({ queryKey: ["systemStatus"] });
                queryClient.invalidateQueries({ queryKey: ["connections"] });
                queryClient.invalidateQueries({ queryKey: ["config"] });
            }, 2000);
        },
    });
}

/**
 * Stop Syncthing sidecar
 */
export function useStopSyncthing() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async () => {
            return await invoke<string>("stop_syncthing_sidecar");
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ["systemStatus"] });
            queryClient.invalidateQueries({ queryKey: ["connections"] });
        },
    });
}

/**
 * Pause a folder with optimistic updates
 */
export function usePauseFolder() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (folderId: string) => {
            await invoke("pause_folder", { folderId });
        },
        onMutate: async (folderId) => {
            // Cancel outgoing refetches
            await queryClient.cancelQueries({ queryKey: ["config"] });

            // Snapshot previous value
            const previousConfig = queryClient.getQueryData<Config>(["config"]);

            // Optimistically update
            queryClient.setQueryData<Config>(["config"], (old) => {
                if (!old?.folders) return old;
                return {
                    ...old,
                    folders: old.folders.map((folder) =>
                        folder.id === folderId ? { ...folder, paused: true } : folder
                    ),
                };
            });

            return { previousConfig };
        },
        onError: (_err, _folderId, context) => {
            // Rollback on error
            if (context?.previousConfig) {
                queryClient.setQueryData(["config"], context.previousConfig);
            }
        },
        onSettled: () => {
            queryClient.invalidateQueries({ queryKey: ["config"] });
        },
    });
}

/**
 * Resume a folder with optimistic updates
 */
export function useResumeFolder() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (folderId: string) => {
            await invoke("resume_folder", { folderId });
        },
        onMutate: async (folderId) => {
            await queryClient.cancelQueries({ queryKey: ["config"] });

            const previousConfig = queryClient.getQueryData<Config>(["config"]);

            queryClient.setQueryData<Config>(["config"], (old) => {
                if (!old?.folders) return old;
                return {
                    ...old,
                    folders: old.folders.map((folder) =>
                        folder.id === folderId ? { ...folder, paused: false } : folder
                    ),
                };
            });

            return { previousConfig };
        },
        onError: (_err, _folderId, context) => {
            if (context?.previousConfig) {
                queryClient.setQueryData(["config"], context.previousConfig);
            }
        },
        onSettled: () => {
            queryClient.invalidateQueries({ queryKey: ["config"] });
        },
    });
}

/**
 * Rescan a folder
 */
export function useRescanFolder() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (folderId: string) => {
            await invoke("rescan_folder", { folderId });
        },
        onSettled: () => {
            queryClient.invalidateQueries({ queryKey: ["folderStatus"] });
        },
    });
}

// ============================================================================
// Device Management
// ============================================================================

/**
 * Get this device's ID
 */
export function useDeviceId() {
    return useQuery({
        queryKey: ["deviceId"],
        queryFn: async () => {
            return await invoke<string>("get_device_id");
        },
        staleTime: Infinity,
        retry: 3,
    });
}

/**
 * Add a new device
 */
export function useAddDevice() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({ deviceId, name }: { deviceId: string; name?: string }) => {
            await invoke("add_device", { deviceId, name: name || deviceId.slice(0, 7) });
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ["config"] });
            queryClient.invalidateQueries({ queryKey: ["connections"] });
        },
    });
}

/**
 * Remove a device
 */
export function useRemoveDevice() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (deviceId: string) => {
            await invoke("remove_device", { deviceId });
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ["config"] });
            queryClient.invalidateQueries({ queryKey: ["connections"] });
        },
    });
}

/**
 * Pause a device with optimistic updates
 */
export function usePauseDevice() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (deviceId: string) => {
            await invoke("pause_device", { deviceId });
        },
        onMutate: async (deviceId) => {
            await queryClient.cancelQueries({ queryKey: ["config"] });

            const previousConfig = queryClient.getQueryData<Config>(["config"]);

            queryClient.setQueryData<Config>(["config"], (old) => {
                if (!old?.devices) return old;
                return {
                    ...old,
                    devices: old.devices.map((device) =>
                        device.deviceID === deviceId ? { ...device, paused: true } : device
                    ),
                };
            });

            return { previousConfig };
        },
        onError: (_err, _deviceId, context) => {
            if (context?.previousConfig) {
                queryClient.setQueryData(["config"], context.previousConfig);
            }
        },
        onSettled: () => {
            queryClient.invalidateQueries({ queryKey: ["config"] });
            queryClient.invalidateQueries({ queryKey: ["connections"] });
        },
    });
}

/**
 * Resume a device with optimistic updates
 */
export function useResumeDevice() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (deviceId: string) => {
            await invoke("resume_device", { deviceId });
        },
        onMutate: async (deviceId) => {
            await queryClient.cancelQueries({ queryKey: ["config"] });

            const previousConfig = queryClient.getQueryData<Config>(["config"]);

            queryClient.setQueryData<Config>(["config"], (old) => {
                if (!old?.devices) return old;
                return {
                    ...old,
                    devices: old.devices.map((device) =>
                        device.deviceID === deviceId ? { ...device, paused: false } : device
                    ),
                };
            });

            return { previousConfig };
        },
        onError: (_err, _deviceId, context) => {
            if (context?.previousConfig) {
                queryClient.setQueryData(["config"], context.previousConfig);
            }
        },
        onSettled: () => {
            queryClient.invalidateQueries({ queryKey: ["config"] });
            queryClient.invalidateQueries({ queryKey: ["connections"] });
        },
    });
}

// ============================================================================
// Folder Management
// ============================================================================

/**
 * Add a new folder
 */
export function useAddFolder() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({
            folderId,
            folderLabel,
            folderPath,
        }: {
            folderId: string;
            folderLabel: string;
            folderPath: string;
        }) => {
            await invoke("add_folder", { folderId, folderLabel, folderPath });
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ["config"] });
        },
    });
}

/**
 * Remove a folder
 */
export function useRemoveFolder() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (folderId: string) => {
            await invoke("remove_folder", { folderId });
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ["config"] });
            queryClient.invalidateQueries({ queryKey: ["folderStatus"] });
        },
    });
}

/**
 * Share a folder with a device
 */
export function useShareFolder() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({ folderId, deviceId }: { folderId: string; deviceId: string }) => {
            await invoke("share_folder", { folderId, deviceId });
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ["config"] });
            // Also invalidate folder status as it might change from "Up to Date" to "Syncing"
            queryClient.invalidateQueries({ queryKey: ["folderStatus"] });
        },
    });
}

/**
 * Unshare a folder from a device with optimistic updates
 */
export function useUnshareFolder() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({ folderId, deviceId }: { folderId: string; deviceId: string }) => {
            await invoke("unshare_folder", { folderId, deviceId });
        },
        onMutate: async ({ folderId, deviceId }) => {
            await queryClient.cancelQueries({ queryKey: ["config"] });

            const previousConfig = queryClient.getQueryData<Config>(["config"]);

            queryClient.setQueryData<Config>(["config"], (old) => {
                if (!old?.folders) return old;
                return {
                    ...old,
                    folders: old.folders.map((folder) => {
                        if (folder.id !== folderId) return folder;
                        return {
                            ...folder,
                            devices: folder.devices?.filter((d) => d.deviceID !== deviceId) || [],
                        };
                    }),
                };
            });

            return { previousConfig };
        },
        onError: (_err, _variables, context) => {
            if (context?.previousConfig) {
                queryClient.setQueryData(["config"], context.previousConfig);
            }
        },
        onSettled: () => {
            queryClient.invalidateQueries({ queryKey: ["config"] });
            queryClient.invalidateQueries({ queryKey: ["folderStatus"] });
        },
    });
}

// ============================================================================
// Advanced Folder Management
// ============================================================================

/**
 * Add a folder with advanced options
 */
export function useAddFolderAdvanced() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (options: AdvancedFolderOptions) => {
            await invoke("add_folder_advanced", {
                folderId: options.folderId,
                folderLabel: options.folderLabel,
                folderPath: options.folderPath,
                versioningType: options.versioningType || null,
                versioningParams: options.versioningParams || null,
                rescanIntervalS: options.rescanIntervalS || null,
                fsWatcherEnabled: options.fsWatcherEnabled ?? null,
                fsWatcherDelayS: options.fsWatcherDelayS || null,
                ignorePerms: options.ignorePerms ?? null,
            });
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ["config"] });
        },
    });
}

/**
 * Get detailed folder configuration
 */
export function useFolderConfig(folderId: string) {
    return useQuery({
        queryKey: ["folderConfig", folderId],
        queryFn: async () => {
            const data = await invoke("get_folder_config", { folderId });
            return FolderConfigSchema.parse(data);
        },
        enabled: !!folderId,
        staleTime: 30000,
    });
}

/**
 * Update folder configuration
 */
export function useUpdateFolderConfig() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({ folderId, updates }: { folderId: string; updates: Partial<FolderConfig> }) => {
            await invoke("update_folder_config", { folderId, updates });
        },
        onSuccess: (_data, { folderId }) => {
            queryClient.invalidateQueries({ queryKey: ["config"] });
            queryClient.invalidateQueries({ queryKey: ["folderConfig", folderId] });
        },
    });
}

// ============================================================================
// Ignore Patterns (.stignore)
// ============================================================================

/**
 * Get ignore patterns for a folder
 */
export function useFolderIgnores(folderId: string) {
    return useQuery({
        queryKey: ["folderIgnores", folderId],
        queryFn: async () => {
            const data = await invoke("get_folder_ignores", { folderId });
            return IgnorePatternsSchema.parse(data);
        },
        enabled: !!folderId,
        staleTime: 30000,
    });
}

/**
 * Set ignore patterns for a folder
 */
export function useSetFolderIgnores() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({ folderId, ignorePatterns }: { folderId: string; ignorePatterns: string[] }) => {
            await invoke("set_folder_ignores", { folderId, ignorePatterns });
        },
        onSuccess: (_data, { folderId }) => {
            queryClient.invalidateQueries({ queryKey: ["folderIgnores", folderId] });
        },
    });
}

// ============================================================================
// System Logs
// ============================================================================

/**
 * Get system logs
 */
export function useSystemLogs(since?: string) {
    return useQuery({
        queryKey: ["systemLogs", since],
        queryFn: async () => {
            const data = await invoke("get_system_logs", { since: since || null });
            return SystemLogsSchema.parse(data);
        },
        refetchInterval: 10000, // Refresh every 10 seconds
        staleTime: 5000,
    });
}

// ============================================================================
// Event API for Real-Time Updates
// ============================================================================

/**
 * Hook for real-time Syncthing events using long-polling
 */
export function useSyncthingEvents(options?: {
    onEvent?: (event: SyncthingEvent) => void;
    enabled?: boolean;
}) {
    const queryClient = useQueryClient();
    const lastEventIdRef = useRef<number>(0);
    const [events, setEvents] = useState<SyncthingEvent[]>([]);
    const [isPolling, setIsPolling] = useState(false);
    const abortControllerRef = useRef<AbortController | null>(null);
    const enabled = options?.enabled ?? true;

    const pollEvents = useCallback(async () => {
        if (!enabled) return;

        setIsPolling(true);

        try {
            const data = await invoke<SyncthingEvent[]>("get_events", {
                since: lastEventIdRef.current,
                limit: 100,
                timeout: 30,
            });

            if (Array.isArray(data) && data.length > 0) {
                const parsedEvents = data.map(e => SyncthingEventSchema.parse(e));

                // Update last event ID
                const maxId = Math.max(...parsedEvents.map(e => e.id));
                if (maxId > lastEventIdRef.current) {
                    lastEventIdRef.current = maxId;
                }

                setEvents(prev => [...prev.slice(-100), ...parsedEvents]);

                // Call event handler for each event
                parsedEvents.forEach(event => {
                    options?.onEvent?.(event);

                    // Invalidate queries based on event type
                    switch (event.type) {
                        case "StateChanged":
                        case "FolderCompletion":
                        case "FolderSummary":
                            queryClient.invalidateQueries({ queryKey: ["folderStatus"] });
                            break;
                        case "DeviceConnected":
                        case "DeviceDisconnected":
                        case "DevicePaused":
                        case "DeviceResumed":
                            queryClient.invalidateQueries({ queryKey: ["connections"] });
                            break;
                        case "ConfigSaved":
                            queryClient.invalidateQueries({ queryKey: ["config"] });
                            break;
                        case "ItemStarted":
                        case "ItemFinished":
                            queryClient.invalidateQueries({ queryKey: ["folderStatus"] });
                            break;
                    }
                });
            }
        } catch (error) {
            // Only log actual errors, not aborts or empty responses
            if (error && typeof error === 'object' && Object.keys(error).length > 0) {
                console.error("Event polling error:", error);
            }
        } finally {
            setIsPolling(false);
        }
    }, [enabled, queryClient, options]);

    useEffect(() => {
        if (!enabled) return;

        let timeoutId: ReturnType<typeof setTimeout>;

        const poll = async () => {
            await pollEvents();
            // Schedule next poll
            timeoutId = setTimeout(poll, 1000);
        };

        poll();

        return () => {
            clearTimeout(timeoutId);
            abortControllerRef.current?.abort();
        };
    }, [enabled, pollEvents]);

    return {
        events,
        isPolling,
        clearEvents: () => setEvents([]),
    };
}

// ============================================================================
// Advanced Device Management
// ============================================================================

/**
 * Add device with advanced options
 */
export function useAddDeviceAdvanced() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (options: AdvancedDeviceOptions) => {
            await invoke("add_device_advanced", {
                deviceId: options.deviceId,
                name: options.name,
                addresses: options.addresses || null,
                compression: options.compression || null,
                introducer: options.introducer ?? null,
                autoAcceptFolders: options.autoAcceptFolders ?? null,
                maxSendKbps: options.maxSendKbps || null,
                maxRecvKbps: options.maxRecvKbps || null,
            });
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ["config"] });
            queryClient.invalidateQueries({ queryKey: ["connections"] });
        },
    });
}

/**
 * Get detailed device configuration
 */
export function useDeviceConfig(deviceId: string) {
    return useQuery({
        queryKey: ["deviceConfig", deviceId],
        queryFn: async () => {
            const data = await invoke("get_device_config", { deviceId });
            return DeviceConfigSchema.parse(data);
        },
        enabled: !!deviceId,
        staleTime: 30000,
    });
}

/**
 * Update device configuration
 */
export function useUpdateDeviceConfig() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({ deviceId, updates }: { deviceId: string; updates: Partial<DeviceConfig> }) => {
            await invoke("update_device_config", { deviceId, updates });
        },
        onSuccess: (_data, { deviceId }) => {
            queryClient.invalidateQueries({ queryKey: ["config"] });
            queryClient.invalidateQueries({ queryKey: ["deviceConfig", deviceId] });
            queryClient.invalidateQueries({ queryKey: ["connections"] });
        },
    });
}

// ============================================================================
// System Management
// ============================================================================

/**
 * Restart Syncthing
 */
export function useRestartSyncthing() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async () => {
            await invoke("restart_syncthing");
        },
        onSuccess: () => {
            // Wait for restart and then refetch everything
            setTimeout(() => {
                queryClient.invalidateQueries({ queryKey: ["systemStatus"] });
                queryClient.invalidateQueries({ queryKey: ["config"] });
                queryClient.invalidateQueries({ queryKey: ["connections"] });
            }, 3000);
        },
    });
}

// ============================================================================
// File Browser Integration
// ============================================================================

/**
 * Open folder in system file explorer
 */
export function useOpenFolderInExplorer() {
    return useMutation({
        mutationFn: async (folderPath: string) => {
            await invoke("open_folder_in_explorer", { folderPath });
        },
    });
}

/**
 * Browse folder contents
 */
export function useBrowseFolder(folderId: string, prefix?: string) {
    return useQuery({
        queryKey: ["browseFolder", folderId, prefix],
        queryFn: async () => {
            const data = await invoke("browse_folder", {
                folderId,
                prefix: prefix || null
            });
            return data as Record<string, unknown>[];
        },
        enabled: !!folderId,
        staleTime: 10000,
    });
}

// ============================================================================
// Conflict Resolution
// ============================================================================

export interface ConflictFile {
    name: string;
    original: string;
    size: number;
    modTime?: number;
}

/**
 * Scan folder for conflict files
 */
export function useScanConflicts(folderPath: string) {
    return useQuery({
        queryKey: ["conflicts", folderPath],
        queryFn: async () => {
            const data = await invoke<ConflictFile[]>("scan_for_conflicts", { folderPath });
            return data;
        },
        enabled: !!folderPath,
        staleTime: 30000,
    });
}

/**
 * Delete a conflict file (keep original)
 */
export function useDeleteConflict() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({ folderPath, conflictFile }: { folderPath: string; conflictFile: string }) => {
            await invoke("delete_conflict_file", { folderPath, conflictFile });
        },
        onSuccess: (_data, { folderPath }) => {
            queryClient.invalidateQueries({ queryKey: ["conflicts", folderPath] });
        },
    });
}

/**
 * Resolve conflict by keeping the conflict version
 */
export function useResolveConflictKeepConflict() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({
            folderPath,
            originalFile,
            conflictFile,
        }: {
            folderPath: string;
            originalFile: string;
            conflictFile: string;
        }) => {
            await invoke("resolve_conflict_keep_conflict", { folderPath, originalFile, conflictFile });
        },
        onSuccess: (_data, { folderPath }) => {
            queryClient.invalidateQueries({ queryKey: ["conflicts", folderPath] });
        },
    });
}

// ============================================================================
// File Versioning
// ============================================================================

export interface VersionEntry {
    name: string;
    originalName: string;
    type: 'file' | 'directory';
    size?: number;
    modTime?: number;
    versionTime?: string;
}

/**
 * Browse .stversions folder for old file versions
 */
export function useBrowseVersions(folderPath: string, prefix?: string) {
    return useQuery({
        queryKey: ["versions", folderPath, prefix],
        queryFn: async () => {
            const data = await invoke<VersionEntry[]>("browse_versions", {
                folderPath,
                prefix: prefix || null
            });
            return data;
        },
        enabled: !!folderPath,
        staleTime: 10000,
    });
}

/**
 * Restore a versioned file to its original location
 */
export function useRestoreVersion() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async ({
            folderPath,
            versionPath,
            originalName,
            overwrite = false,
        }: {
            folderPath: string;
            versionPath: string;
            originalName: string;
            overwrite?: boolean;
        }) => {
            await invoke("restore_version", {
                folderPath,
                versionPath,
                originalName,
                overwrite
            });
        },
        onSuccess: (_data, { folderPath }) => {
            queryClient.invalidateQueries({ queryKey: ["versions", folderPath] });
            queryClient.invalidateQueries({ queryKey: ["browseFolder"] });
        },
    });
}

// ============================================================================
// Global Options
// ============================================================================

/**
 * Update global Syncthing options (network settings, discovery, etc.)
 */
export function useUpdateOptions() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (options: Partial<Options>) => {
            await invoke("update_options", { options });
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ["config"] });
        },
    });
}

// ============================================================================
// Syncthing Lifecycle
// ============================================================================

/**
 * Hook to manage Syncthing lifecycle - auto-starts on mount
 */
export function useSyncthingLifecycle() {
    const startMutation = useStartSyncthing();
    const { data: status, isError, error } = useSystemStatus();

    return {
        start: startMutation.mutate,
        isStarting: startMutation.isPending,
        startError: startMutation.error,
        isRunning: !!status?.myID,
        isConnecting: !status?.myID && !isError,
        connectionError: isError ? error : null,
    };
}
</file>

<file path="src/lib/db.ts">
/**
 * IndexedDB schema and utilities for file metadata and embeddings
 */
import { openDB, DBSchema, IDBPDatabase } from 'idb';

// Database schema
interface EigenDB extends DBSchema {
    files: {
        key: string; // Full path
        value: FileMetadata;
        indexes: {
            'by-folder': string;
            'by-name': string;
            'by-modified': number;
        };
    };
    embeddings: {
        key: string; // Full path
        value: FileEmbedding;
    };
    searchHistory: {
        key: number; // Auto-increment
        value: SearchHistoryEntry;
        indexes: {
            'by-query': string;
            'by-date': number;
        };
    };
    activityLog: {
        key: number;
        value: ActivityLogEntry;
        indexes: {
            'by-path': string;
            'by-date': number;
            'by-action': string;
        };
    };
}

export interface FileMetadata {
    path: string;
    name: string;
    folderId: string;
    folderPath: string;
    size: number;
    modified: number;
    isDirectory: boolean;
    extension?: string;
    indexed: number; // When it was indexed
}

export interface FileEmbedding {
    path: string;
    embedding: number[]; // Vector embedding
    model: string;
    createdAt: number;
}

export interface SearchHistoryEntry {
    query: string;
    resultCount: number;
    selectedPath?: string;
    timestamp: number;
}

export interface ActivityLogEntry {
    path: string;
    action: 'open' | 'sync' | 'modify' | 'search';
    timestamp: number;
    details?: string;
}

const DB_NAME = 'eigen-ai';
const DB_VERSION = 1;

let dbInstance: IDBPDatabase<EigenDB> | null = null;

/**
 * Get or create the database instance
 */
export async function getDB(): Promise<IDBPDatabase<EigenDB>> {
    if (dbInstance) return dbInstance;

    dbInstance = await openDB<EigenDB>(DB_NAME, DB_VERSION, {
        upgrade(db) {
            // Files store
            if (!db.objectStoreNames.contains('files')) {
                const fileStore = db.createObjectStore('files', { keyPath: 'path' });
                fileStore.createIndex('by-folder', 'folderId');
                fileStore.createIndex('by-name', 'name');
                fileStore.createIndex('by-modified', 'modified');
            }

            // Embeddings store
            if (!db.objectStoreNames.contains('embeddings')) {
                db.createObjectStore('embeddings', { keyPath: 'path' });
            }

            // Search history store
            if (!db.objectStoreNames.contains('searchHistory')) {
                const historyStore = db.createObjectStore('searchHistory', {
                    keyPath: 'id',
                    autoIncrement: true,
                });
                historyStore.createIndex('by-query', 'query');
                historyStore.createIndex('by-date', 'timestamp');
            }

            // Activity log store
            if (!db.objectStoreNames.contains('activityLog')) {
                const activityStore = db.createObjectStore('activityLog', {
                    keyPath: 'id',
                    autoIncrement: true,
                });
                activityStore.createIndex('by-path', 'path');
                activityStore.createIndex('by-date', 'timestamp');
                activityStore.createIndex('by-action', 'action');
            }
        },
    });

    return dbInstance;
}

// ============================================================================
// File Operations
// ============================================================================

/**
 * Add or update file metadata
 */
export async function upsertFile(file: FileMetadata): Promise<void> {
    const db = await getDB();
    await db.put('files', file);
}

/**
 * Bulk add files (for initial indexing)
 */
export async function bulkUpsertFiles(files: FileMetadata[]): Promise<void> {
    const db = await getDB();
    const tx = db.transaction('files', 'readwrite');
    await Promise.all([
        ...files.map((file) => tx.store.put(file)),
        tx.done,
    ]);
}

/**
 * Get all files for a folder
 */
export async function getFilesByFolder(folderId: string): Promise<FileMetadata[]> {
    const db = await getDB();
    return db.getAllFromIndex('files', 'by-folder', folderId);
}

/**
 * Search files by name (simple substring match)
 */
export async function searchFilesByName(query: string): Promise<FileMetadata[]> {
    const db = await getDB();
    const allFiles = await db.getAll('files');
    const lowerQuery = query.toLowerCase();
    return allFiles.filter(
        (file) =>
            file.name.toLowerCase().includes(lowerQuery) ||
            file.path.toLowerCase().includes(lowerQuery)
    );
}

/**
 * Get file count
 */
export async function getFileCount(): Promise<number> {
    const db = await getDB();
    return db.count('files');
}

/**
 * Clear all files for a folder (for re-indexing)
 */
export async function clearFilesForFolder(folderId: string): Promise<void> {
    const db = await getDB();
    const files = await db.getAllFromIndex('files', 'by-folder', folderId);
    const tx = db.transaction('files', 'readwrite');
    await Promise.all([
        ...files.map((file) => tx.store.delete(file.path)),
        tx.done,
    ]);
}

// ============================================================================
// Embedding Operations
// ============================================================================

/**
 * Store embedding for a file
 */
export async function storeEmbedding(embedding: FileEmbedding): Promise<void> {
    const db = await getDB();
    await db.put('embeddings', embedding);
}

/**
 * Bulk store embeddings
 */
export async function bulkStoreEmbeddings(embeddings: FileEmbedding[]): Promise<void> {
    const db = await getDB();
    const tx = db.transaction('embeddings', 'readwrite');
    await Promise.all([
        ...embeddings.map((emb) => tx.store.put(emb)),
        tx.done,
    ]);
}

/**
 * Get embedding for a file
 */
export async function getEmbedding(path: string): Promise<FileEmbedding | undefined> {
    const db = await getDB();
    return db.get('embeddings', path);
}

/**
 * Get all embeddings (for semantic search)
 */
export async function getAllEmbeddings(): Promise<FileEmbedding[]> {
    const db = await getDB();
    return db.getAll('embeddings');
}

/**
 * Get files without embeddings
 */
export async function getFilesWithoutEmbeddings(): Promise<FileMetadata[]> {
    const db = await getDB();
    const files = await db.getAll('files');
    const embeddingPaths = new Set((await db.getAllKeys('embeddings')));
    return files.filter((file) => !embeddingPaths.has(file.path));
}

// ============================================================================
// Activity Logging
// ============================================================================

/**
 * Log an activity
 */
export async function logActivity(entry: Omit<ActivityLogEntry, 'timestamp'>): Promise<void> {
    const db = await getDB();
    await db.add('activityLog', {
        ...entry,
        timestamp: Date.now(),
    });
}

/**
 * Get recent activity for a path (for predictive sync)
 */
export async function getActivityForPath(path: string, limit = 100): Promise<ActivityLogEntry[]> {
    const db = await getDB();
    const entries = await db.getAllFromIndex('activityLog', 'by-path', path);
    return entries.slice(-limit);
}

/**
 * Get most accessed files (for predictive sync)
 */
export async function getMostAccessedFiles(limit = 50): Promise<{ path: string; count: number }[]> {
    const db = await getDB();
    const entries = await db.getAll('activityLog');

    // Count accesses per path
    const counts = new Map<string, number>();
    for (const entry of entries) {
        counts.set(entry.path, (counts.get(entry.path) || 0) + 1);
    }

    // Sort by count and return top N
    return Array.from(counts.entries())
        .map(([path, count]) => ({ path, count }))
        .sort((a, b) => b.count - a.count)
        .slice(0, limit);
}

// ============================================================================
// Search History
// ============================================================================

/**
 * Log a search query
 */
export async function logSearch(query: string, resultCount: number, selectedPath?: string): Promise<void> {
    const db = await getDB();
    await db.add('searchHistory', {
        query,
        resultCount,
        selectedPath,
        timestamp: Date.now(),
    });
}

/**
 * Get recent searches
 */
export async function getRecentSearches(limit = 10): Promise<SearchHistoryEntry[]> {
    const db = await getDB();
    const entries = await db.getAllFromIndex('searchHistory', 'by-date');
    return entries.slice(-limit).reverse();
}

// ============================================================================
// Database Management
// ============================================================================

/**
 * Clear all data
 */
export async function clearAllData(): Promise<void> {
    const db = await getDB();
    await Promise.all([
        db.clear('files'),
        db.clear('embeddings'),
        db.clear('searchHistory'),
        db.clear('activityLog'),
    ]);
}

/**
 * Get database stats
 */
export async function getDBStats(): Promise<{
    fileCount: number;
    embeddingCount: number;
    activityCount: number;
    searchCount: number;
}> {
    const db = await getDB();
    return {
        fileCount: await db.count('files'),
        embeddingCount: await db.count('embeddings'),
        activityCount: await db.count('activityLog'),
        searchCount: await db.count('searchHistory'),
    };
}
</file>

<file path="src/lib/utils.ts">
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs));
}

export function formatBytes(bytes: number, decimals = 2): string {
    if (bytes === 0) return "0 Bytes";

    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB"];

    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + " " + sizes[i];
}

export function formatUptime(seconds: number): string {
    const days = Math.floor(seconds / 86400);
    const hours = Math.floor((seconds % 86400) / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);

    if (days > 0) {
        return `${days}d ${hours}h`;
    }
    if (hours > 0) {
        return `${hours}h ${minutes}m`;
    }
    return `${minutes}m`;
}
</file>

<file path="src/store/index.ts">
"use client";

import { create } from "zustand";
import { persist } from "zustand/middleware";

interface AppState {
    // UI State
    sidebarOpen: boolean;
    activeTab: "dashboard" | "folders" | "devices" | "settings" | "logs";
    theme: "light" | "dark" | "system";

    // Settings
    pollingInterval: number; // in milliseconds
    nativeNotificationsEnabled: boolean;
    aiEnabled: boolean; // Enable AI-powered semantic search

    // Actions
    setSidebarOpen: (open: boolean) => void;
    toggleSidebar: () => void;
    setActiveTab: (tab: AppState["activeTab"]) => void;
    setTheme: (theme: AppState["theme"]) => void;
    setPollingInterval: (interval: number) => void;
    setNativeNotificationsEnabled: (enabled: boolean) => void;
    setAiEnabled: (enabled: boolean) => void;
}

export const useAppStore = create<AppState>()(
    persist(
        (set) => ({
            // Initial State
            sidebarOpen: true,
            activeTab: "dashboard",
            theme: "dark",
            pollingInterval: 5000,
            nativeNotificationsEnabled: true,
            aiEnabled: false, // AI disabled by default

            // Actions
            setSidebarOpen: (open) => set({ sidebarOpen: open }),
            toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
            setActiveTab: (tab) => set({ activeTab: tab }),
            setTheme: (theme) => set({ theme }),
            setPollingInterval: (interval) => set({ pollingInterval: interval }),
            setNativeNotificationsEnabled: (enabled) => set({ nativeNotificationsEnabled: enabled }),
            setAiEnabled: (enabled) => set({ aiEnabled: enabled }),
        }),
        {
            name: "eigen-app-store",
        }
    )
);

interface SyncState {
    // Syncthing state
    isConnected: boolean;
    isSyncthingRunning: boolean;
    lastError: string | null;

    // Actions
    setConnected: (connected: boolean) => void;
    setSyncthingRunning: (running: boolean) => void;
    setLastError: (error: string | null) => void;
}

export const useSyncStore = create<SyncState>()((set) => ({
    // Initial State
    isConnected: false,
    isSyncthingRunning: false,
    lastError: null,

    // Actions
    setConnected: (connected) => set({ isConnected: connected }),
    setSyncthingRunning: (running) => set({ isSyncthingRunning: running }),
    setLastError: (error) => set({ lastError: error }),
}));
</file>

<file path="src/workers/ai.worker.ts">
/**
 * AI Worker - Runs transformers.js in a Web Worker to avoid blocking the UI
 * 
 * This worker handles:
 * - Loading the embedding model
 * - Generating embeddings for file names/paths
 * - Computing similarity scores for semantic search
 */

import { pipeline, env, type FeatureExtractionPipeline } from '@xenova/transformers';

// Configure transformers.js for browser
env.allowLocalModels = false;
env.useBrowserCache = true;

// Message types
interface WorkerMessage {
    id: string;
    type: 'init' | 'embed' | 'search' | 'status';
    payload?: unknown;
}

interface InitPayload {
    modelName?: string;
}

interface EmbedPayload {
    texts: string[];
}

interface SearchPayload {
    query: string;
    embeddings: { path: string; embedding: number[] }[];
    topK?: number;
}

// Worker state
let embedder: FeatureExtractionPipeline | null = null;
let isLoading = false;
let modelName = 'Xenova/all-MiniLM-L6-v2'; // Small, fast model

/**
 * Initialize the embedding pipeline
 */
async function initModel(name?: string): Promise<void> {
    if (isLoading) return;
    if (embedder) return;

    isLoading = true;
    modelName = name || modelName;

    try {
        postMessage({
            type: 'status',
            payload: { status: 'loading', message: `Loading model: ${modelName}` },
        });

        embedder = await pipeline('feature-extraction', modelName, {
            quantized: true, // Use quantized model for smaller size
        }) as FeatureExtractionPipeline;

        postMessage({
            type: 'status',
            payload: { status: 'ready', message: 'Model loaded successfully' },
        });
    } catch (error) {
        postMessage({
            type: 'status',
            payload: {
                status: 'error',
                message: `Failed to load model: ${error instanceof Error ? error.message : 'Unknown error'}`,
            },
        });
    } finally {
        isLoading = false;
    }
}

/**
 * Generate embeddings for texts
 */
async function generateEmbeddings(texts: string[]): Promise<number[][]> {
    if (!embedder) {
        throw new Error('Model not initialized');
    }

    const results: number[][] = [];

    for (const text of texts) {
        const output = await embedder(text, {
            pooling: 'mean',
            normalize: true,
        });
        // Convert tensor to array
        results.push(Array.from(output.data as Float32Array));
    }

    return results;
}

/**
 * Compute cosine similarity between two vectors
 */
function cosineSimilarity(a: number[], b: number[]): number {
    if (a.length !== b.length) return 0;

    let dotProduct = 0;
    let normA = 0;
    let normB = 0;

    for (let i = 0; i < a.length; i++) {
        dotProduct += a[i] * b[i];
        normA += a[i] * a[i];
        normB += b[i] * b[i];
    }

    normA = Math.sqrt(normA);
    normB = Math.sqrt(normB);

    if (normA === 0 || normB === 0) return 0;

    return dotProduct / (normA * normB);
}

/**
 * Semantic search - find most similar files to query
 */
async function semanticSearch(
    query: string,
    embeddings: { path: string; embedding: number[] }[],
    topK = 10
): Promise<{ path: string; score: number }[]> {
    if (!embedder) {
        throw new Error('Model not initialized');
    }

    // Generate query embedding
    const queryEmbedding = (await generateEmbeddings([query]))[0];

    // Compute similarities
    const results = embeddings.map((item) => ({
        path: item.path,
        score: cosineSimilarity(queryEmbedding, item.embedding),
    }));

    // Sort by similarity and return top K
    return results
        .sort((a, b) => b.score - a.score)
        .slice(0, topK);
}

// Handle messages from main thread
self.onmessage = async (event: MessageEvent<WorkerMessage>) => {
    const { id, type, payload } = event.data;

    try {
        switch (type) {
            case 'init': {
                const initPayload = payload as InitPayload | undefined;
                await initModel(initPayload?.modelName);
                postMessage({ id, type: 'init', payload: { success: true } });
                break;
            }

            case 'embed': {
                const embedPayload = payload as EmbedPayload;
                const embeddings = await generateEmbeddings(embedPayload.texts);
                postMessage({ id, type: 'embed', payload: { embeddings } });
                break;
            }

            case 'search': {
                const searchPayload = payload as SearchPayload;
                const results = await semanticSearch(
                    searchPayload.query,
                    searchPayload.embeddings,
                    searchPayload.topK
                );
                postMessage({ id, type: 'search', payload: { results } });
                break;
            }

            case 'status': {
                postMessage({
                    id,
                    type: 'status',
                    payload: {
                        initialized: !!embedder,
                        loading: isLoading,
                        model: modelName,
                    },
                });
                break;
            }

            default:
                postMessage({
                    id,
                    type: 'error',
                    payload: { message: `Unknown message type: ${type}` },
                });
        }
    } catch (error) {
        postMessage({
            id,
            type: 'error',
            payload: {
                message: error instanceof Error ? error.message : 'Unknown error',
            },
        });
    }
};

// Signal that worker is ready
postMessage({ type: 'status', payload: { status: 'initialized' } });
</file>

<file path="src-tauri/capabilities/default.json">
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "Capability for the main window",
  "windows": ["main"],
  "permissions": [
    "core:default",
    "opener:default",
    "notification:default",
    "dialog:allow-open",
    {
      "identifier": "shell:allow-spawn",
      "allow": [
        {
          "name": "binaries/syncthing",
          "sidecar": true,
          "args": [
            "-no-browser",
            "-no-restart",
            {
              "validator": "\\S+"
            }
          ]
        }
      ]
    },
    "shell:allow-kill"
  ]
}
</file>

<file path="src-tauri/src/commands.rs">
use crate::{SyncthingError, SyncthingState};
use tauri::State;
use tauri::AppHandle;
use tauri_plugin_shell::ShellExt;
use serde::Serialize;

/// Information about Syncthing installation
#[derive(Debug, Serialize)]
pub struct SyncthingInfo {
    pub installed: bool,
    pub version: Option<String>,
    pub path: Option<String>,
    pub bundled: bool,
}

/// Check if Syncthing is installed and get version info
#[tauri::command]
pub fn check_syncthing_installation() -> SyncthingInfo {
    // Check for system-installed syncthing
    use std::process::Command;
    match Command::new("syncthing").arg("--version").output() {
        Ok(output) => {
            let version_str = String::from_utf8_lossy(&output.stdout);
            let version = version_str
                .lines()
                .next()
                .map(|s| s.to_string());
            
            // Try to get the path
            let path = Command::new("which")
                .arg("syncthing")
                .output()
                .ok()
                .and_then(|o| {
                    let p = String::from_utf8_lossy(&o.stdout).trim().to_string();
                    if p.is_empty() { None } else { Some(p) }
                });
            
            SyncthingInfo {
                installed: true,
                version,
                path,
                bundled: false,
            }
        }
        Err(_) => SyncthingInfo {
            installed: true, // Bundled sidecar is always available
            version: Some("bundled".to_string()),
            path: Some("bundled sidecar".to_string()),
            bundled: true,
        },
    }
}

/// Start the Syncthing sidecar process
#[tauri::command]
pub async fn start_syncthing_sidecar(
    app: AppHandle,
    state: State<'_, SyncthingState>,
) -> Result<String, SyncthingError> {
    let mut child_guard = state.sidecar_child.lock().map_err(|e| {
        SyncthingError::ProcessError(format!("Failed to acquire lock: {}", e))
    })?;

    if child_guard.is_some() {
        return Ok("Syncthing already running".into());
    }

    // Use the bundled sidecar
    let sidecar_command = app.shell()
        .sidecar("syncthing")
        .map_err(|e| SyncthingError::ProcessError(format!("Failed to create sidecar command: {}", e)))?
        .args([
            "-no-browser",
            "-no-restart",
            &format!("-gui-apikey={}", state.config.api_key),
            &format!("-gui-address={}:{}", state.config.host, state.config.port),
        ]);

    let (_rx, child) = sidecar_command
        .spawn()
        .map_err(|e| SyncthingError::ProcessError(format!("Failed to spawn syncthing sidecar: {}", e)))?;

    *child_guard = Some(child);
    Ok("Syncthing sidecar started successfully".into())
}

/// Stop the Syncthing sidecar process
#[tauri::command]
pub async fn stop_syncthing_sidecar(
    state: State<'_, SyncthingState>,
) -> Result<String, SyncthingError> {
    let mut child_guard = state.sidecar_child.lock().map_err(|e| {
        SyncthingError::ProcessError(format!("Failed to acquire lock: {}", e))
    })?;

    if let Some(child) = child_guard.take() {
        child.kill().map_err(|e| {
            SyncthingError::ProcessError(format!("Failed to kill sidecar process: {}", e))
        })?;
        Ok("Syncthing sidecar stopped".into())
    } else {
        Ok("Syncthing sidecar was not running".into())
    }
}

/// Get Syncthing system status
#[tauri::command]
pub async fn get_system_status(
    state: State<'_, SyncthingState>,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/system/status",
        state.config.host, state.config.port
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

/// Get Syncthing connections info
#[tauri::command]
pub async fn get_connections(
    state: State<'_, SyncthingState>,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/system/connections",
        state.config.host, state.config.port
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

/// Get Syncthing configuration
#[tauri::command]
pub async fn get_config(
    state: State<'_, SyncthingState>,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config",
        state.config.host, state.config.port
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

/// Update global Syncthing options
#[tauri::command]
pub async fn update_options(
    state: State<'_, SyncthingState>,
    options: serde_json::Value,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    
    // First get the current config
    let get_url = format!(
        "http://{}:{}/rest/config",
        state.config.host, state.config.port
    );

    let current_config: serde_json::Value = client
        .get(&get_url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Merge options into current config
    let mut updated_config = current_config.clone();
    if let (Some(config_obj), Some(current_options)) = (
        updated_config.as_object_mut(),
        current_config.get("options"),
    ) {
        let mut new_options = current_options.clone();
        if let (Some(opts_obj), Some(updates_obj)) = (
            new_options.as_object_mut(),
            options.as_object(),
        ) {
            for (key, value) in updates_obj {
                opts_obj.insert(key.clone(), value.clone());
            }
        }
        config_obj.insert("options".to_string(), new_options);
    }

    // Save the updated config
    let put_url = format!(
        "http://{}:{}/rest/config",
        state.config.host, state.config.port
    );

    let res = client
        .put(&put_url)
        .header("X-API-Key", &state.config.api_key)
        .json(&updated_config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    if !res.status().is_success() {
        return Err(SyncthingError::HttpError(format!(
            "Failed to update options: {}",
            res.status()
        )));
    }

    Ok(())
}

/// Get folder status
#[tauri::command]
pub async fn get_folder_status(
    state: State<'_, SyncthingState>,
    folder_id: String,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/db/status?folder={}",
        state.config.host, state.config.port, folder_id
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

/// Pause a folder
#[tauri::command]
pub async fn pause_folder(
    state: State<'_, SyncthingState>,
    folder_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/folders/{}",
        state.config.host, state.config.port, folder_id
    );

    // Get current config
    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Update paused status
    config["paused"] = serde_json::Value::Bool(true);

    // Put updated config
    client
        .put(&url)
        .header("X-API-Key", &state.config.api_key)
        .json(&config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Resume a folder
#[tauri::command]
pub async fn resume_folder(
    state: State<'_, SyncthingState>,
    folder_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/folders/{}",
        state.config.host, state.config.port, folder_id
    );

    // Get current config
    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Update paused status
    config["paused"] = serde_json::Value::Bool(false);

    // Put updated config
    client
        .put(&url)
        .header("X-API-Key", &state.config.api_key)
        .json(&config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Force rescan of a folder
#[tauri::command]
pub async fn rescan_folder(
    state: State<'_, SyncthingState>,
    folder_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/db/scan?folder={}",
        state.config.host, state.config.port, folder_id
    );

    client
        .post(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Get the current API configuration (for debugging)
#[tauri::command]
pub fn get_api_config(state: State<'_, SyncthingState>) -> (String, u16) {
    (state.config.host.clone(), state.config.port)
}

/// Get this device's ID
#[tauri::command]
pub async fn get_device_id(
    state: State<'_, SyncthingState>,
) -> Result<String, SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/system/status",
        state.config.host, state.config.port
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    json["myID"]
        .as_str()
        .map(|s| s.to_string())
        .ok_or_else(|| SyncthingError::ParseError("No device ID found".into()))
}

/// Add a new device to Syncthing
#[tauri::command]
pub async fn add_device(
    state: State<'_, SyncthingState>,
    device_id: String,
    name: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    
    // First, get current config
    let config_url = format!(
        "http://{}:{}/rest/config",
        state.config.host, state.config.port
    );
    
    let res = client
        .get(&config_url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Check if device already exists
    if let Some(devices) = config["devices"].as_array() {
        for device in devices {
            if device["deviceID"].as_str() == Some(&device_id) {
                return Err(SyncthingError::ProcessError("Device already exists".into()));
            }
        }
    }

    // Create new device config
    let new_device = serde_json::json!({
        "deviceID": device_id,
        "name": name,
        "addresses": ["dynamic"],
        "compression": "metadata",
        "introducer": false,
        "paused": false,
        "autoAcceptFolders": false,
    });

    // Add to devices array
    if let Some(devices) = config["devices"].as_array_mut() {
        devices.push(new_device);
    }

    // Save updated config
    client
        .put(&config_url)
        .header("X-API-Key", &state.config.api_key)
        .json(&config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Remove a device from Syncthing
#[tauri::command]
pub async fn remove_device(
    state: State<'_, SyncthingState>,
    device_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/devices/{}",
        state.config.host, state.config.port, device_id
    );

    client
        .delete(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Add a new folder to Syncthing
#[tauri::command]
pub async fn add_folder(
    state: State<'_, SyncthingState>,
    folder_id: String,
    folder_label: String,
    folder_path: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    
    // First, get current config
    let config_url = format!(
        "http://{}:{}/rest/config",
        state.config.host, state.config.port
    );
    
    let res = client
        .get(&config_url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Check if folder already exists
    if let Some(folders) = config["folders"].as_array() {
        for folder in folders {
            if folder["id"].as_str() == Some(&folder_id) {
                return Err(SyncthingError::ProcessError("Folder already exists".into()));
            }
        }
    }

    // Create new folder config
    let new_folder = serde_json::json!({
        "id": folder_id,
        "label": folder_label,
        "path": folder_path,
        "type": "sendreceive",
        "rescanIntervalS": 3600,
        "fsWatcherEnabled": true,
        "fsWatcherDelayS": 10,
        "ignorePerms": false,
        "autoNormalize": true,
        "paused": false,
        "devices": [],
        "minDiskFree": {
            "value": 1,
            "unit": "%"
        },
        "versioning": {
            "type": "",
            "params": {},
            "cleanupIntervalS": 3600,
            "fsPath": "",
            "fsType": "basic"
        },
        "copiers": 0,
        "pullerMaxPendingKiB": 0,
        "hashers": 0,
        "order": "random",
        "ignoreDelete": false,
        "scanProgressIntervalS": 0,
        "pullerPauseS": 0,
        "maxConflicts": 10,
        "disableSparseFiles": false,
        "disableTempIndexes": false,
        "weakHashThresholdPct": 25,
        "markerName": ".stfolder",
        "copyOwnershipFromParent": false,
        "modTimeWindowS": 0,
        "maxConcurrentWrites": 2,
        "disableFsync": false,
        "blockPullOrder": "standard",
        "copyRangeMethod": "standard",
        "caseSensitiveFS": false,
        "junctionsAsDirs": false,
        "syncOwnership": false,
        "sendOwnership": false,
        "syncXattrs": false,
        "sendXattrs": false,
        "xattrFilter": {
            "entries": [],
            "maxSingleEntrySize": 1024,
            "maxTotalSize": 4096
        }
    });

    // Add to folders array
    if let Some(folders) = config["folders"].as_array_mut() {
        folders.push(new_folder);
    }

    // Save updated config
    client
        .put(&config_url)
        .header("X-API-Key", &state.config.api_key)
        .json(&config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Remove a folder from Syncthing
#[tauri::command]
pub async fn remove_folder(
    state: State<'_, SyncthingState>,
    folder_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/folders/{}",
        state.config.host, state.config.port, folder_id
    );

    client
        .delete(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Share a folder with a specific device
#[tauri::command]
pub async fn share_folder(
    state: State<'_, SyncthingState>,
    folder_id: String,
    device_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/folders/{}",
        state.config.host, state.config.port, folder_id
    );

    // 1. Get current folder config
    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut folder_config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // 2. Check if device is already added
    let mut device_exists = false;
    if let Some(devices) = folder_config["devices"].as_array() {
        for device in devices {
            if device["deviceID"].as_str() == Some(&device_id) {
                device_exists = true;
                break;
            }
        }
    }

    // 3. Add device if not exists
    if !device_exists {
        let new_device_entry = serde_json::json!({
            "deviceID": device_id,
            "introducedBy": ""
        });

        if let Some(devices) = folder_config["devices"].as_array_mut() {
            devices.push(new_device_entry);
        }

        // 4. Update config
        client
            .put(&url)
            .header("X-API-Key", &state.config.api_key)
            .json(&folder_config)
            .send()
            .await
            .map_err(|e| SyncthingError::HttpError(e.to_string()))?;
    }

    Ok(())
}

// ============================================================================
// Advanced Folder Configuration
// ============================================================================

/// Add a folder with advanced configuration options
#[tauri::command]
pub async fn add_folder_advanced(
    state: State<'_, SyncthingState>,
    folder_id: String,
    folder_label: String,
    folder_path: String,
    versioning_type: Option<String>,
    versioning_params: Option<serde_json::Value>,
    rescan_interval_s: Option<u32>,
    fs_watcher_enabled: Option<bool>,
    fs_watcher_delay_s: Option<u32>,
    ignore_perms: Option<bool>,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    
    let config_url = format!(
        "http://{}:{}/rest/config",
        state.config.host, state.config.port
    );
    
    let res = client
        .get(&config_url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Check if folder already exists
    if let Some(folders) = config["folders"].as_array() {
        for folder in folders {
            if folder["id"].as_str() == Some(&folder_id) {
                return Err(SyncthingError::ProcessError("Folder already exists".into()));
            }
        }
    }

    // Build versioning config
    let versioning = match versioning_type.as_deref() {
        Some("simple") => serde_json::json!({
            "type": "simple",
            "params": versioning_params.unwrap_or(serde_json::json!({
                "keep": "5"
            })),
            "cleanupIntervalS": 3600,
            "fsPath": "",
            "fsType": "basic"
        }),
        Some("staggered") => serde_json::json!({
            "type": "staggered",
            "params": versioning_params.unwrap_or(serde_json::json!({
                "cleanInterval": "3600",
                "maxAge": "31536000"
            })),
            "cleanupIntervalS": 3600,
            "fsPath": "",
            "fsType": "basic"
        }),
        Some("trashcan") => serde_json::json!({
            "type": "trashcan",
            "params": versioning_params.unwrap_or(serde_json::json!({
                "cleanoutDays": "0"
            })),
            "cleanupIntervalS": 3600,
            "fsPath": "",
            "fsType": "basic"
        }),
        Some("external") => serde_json::json!({
            "type": "external",
            "params": versioning_params.unwrap_or(serde_json::json!({
                "command": ""
            })),
            "cleanupIntervalS": 3600,
            "fsPath": "",
            "fsType": "basic"
        }),
        _ => serde_json::json!({
            "type": "",
            "params": {},
            "cleanupIntervalS": 3600,
            "fsPath": "",
            "fsType": "basic"
        }),
    };

    let new_folder = serde_json::json!({
        "id": folder_id,
        "label": folder_label,
        "path": folder_path,
        "type": "sendreceive",
        "rescanIntervalS": rescan_interval_s.unwrap_or(3600),
        "fsWatcherEnabled": fs_watcher_enabled.unwrap_or(true),
        "fsWatcherDelayS": fs_watcher_delay_s.unwrap_or(10),
        "ignorePerms": ignore_perms.unwrap_or(false),
        "autoNormalize": true,
        "paused": false,
        "devices": [],
        "minDiskFree": { "value": 1, "unit": "%" },
        "versioning": versioning,
        "copiers": 0,
        "pullerMaxPendingKiB": 0,
        "hashers": 0,
        "order": "random",
        "ignoreDelete": false,
        "scanProgressIntervalS": 0,
        "pullerPauseS": 0,
        "maxConflicts": 10,
        "disableSparseFiles": false,
        "disableTempIndexes": false,
        "weakHashThresholdPct": 25,
        "markerName": ".stfolder",
        "copyOwnershipFromParent": false,
        "modTimeWindowS": 0,
        "maxConcurrentWrites": 2,
        "disableFsync": false,
        "blockPullOrder": "standard",
        "copyRangeMethod": "standard",
        "caseSensitiveFS": false,
        "junctionsAsDirs": false,
        "syncOwnership": false,
        "sendOwnership": false,
        "syncXattrs": false,
        "sendXattrs": false,
        "xattrFilter": {
            "entries": [],
            "maxSingleEntrySize": 1024,
            "maxTotalSize": 4096
        }
    });

    if let Some(folders) = config["folders"].as_array_mut() {
        folders.push(new_folder);
    }

    client
        .put(&config_url)
        .header("X-API-Key", &state.config.api_key)
        .json(&config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Update folder configuration
#[tauri::command]
pub async fn update_folder_config(
    state: State<'_, SyncthingState>,
    folder_id: String,
    updates: serde_json::Value,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/folders/{}",
        state.config.host, state.config.port, folder_id
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut folder_config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Merge updates into folder config
    if let (Some(config_obj), Some(updates_obj)) = (folder_config.as_object_mut(), updates.as_object()) {
        for (key, value) in updates_obj {
            config_obj.insert(key.clone(), value.clone());
        }
    }

    client
        .put(&url)
        .header("X-API-Key", &state.config.api_key)
        .json(&folder_config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

// ============================================================================
// Ignore Patterns (.stignore)
// ============================================================================

/// Get ignore patterns for a folder
#[tauri::command]
pub async fn get_folder_ignores(
    state: State<'_, SyncthingState>,
    folder_id: String,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/db/ignores?folder={}",
        state.config.host, state.config.port, folder_id
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

/// Set ignore patterns for a folder
#[tauri::command]
pub async fn set_folder_ignores(
    state: State<'_, SyncthingState>,
    folder_id: String,
    ignore_patterns: Vec<String>,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/db/ignores?folder={}",
        state.config.host, state.config.port, folder_id
    );

    let body = serde_json::json!({
        "ignore": ignore_patterns
    });

    client
        .post(&url)
        .header("X-API-Key", &state.config.api_key)
        .json(&body)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

// ============================================================================
// System Logs
// ============================================================================

/// Get Syncthing logs
#[tauri::command]
pub async fn get_system_logs(
    state: State<'_, SyncthingState>,
    since: Option<String>,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let mut url = format!(
        "http://{}:{}/rest/system/log",
        state.config.host, state.config.port
    );

    if let Some(since_time) = since {
        url = format!("{}?since={}", url, since_time);
    }

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

// ============================================================================
// Event API
// ============================================================================

/// Get events from Syncthing (for real-time updates)
#[tauri::command]
pub async fn get_events(
    state: State<'_, SyncthingState>,
    since: Option<u64>,
    limit: Option<u32>,
    timeout: Option<u32>,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::builder()
        .timeout(std::time::Duration::from_secs(timeout.unwrap_or(60) as u64 + 5))
        .build()
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut url = format!(
        "http://{}:{}/rest/events",
        state.config.host, state.config.port
    );

    let mut params = Vec::new();
    if let Some(s) = since {
        params.push(format!("since={}", s));
    }
    if let Some(l) = limit {
        params.push(format!("limit={}", l));
    }
    if let Some(t) = timeout {
        params.push(format!("timeout={}", t));
    }

    if !params.is_empty() {
        url = format!("{}?{}", url, params.join("&"));
    }

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

// ============================================================================
// Advanced Device Settings
// ============================================================================

/// Add device with advanced options
#[tauri::command]
pub async fn add_device_advanced(
    state: State<'_, SyncthingState>,
    device_id: String,
    name: String,
    addresses: Option<Vec<String>>,
    compression: Option<String>,
    introducer: Option<bool>,
    auto_accept_folders: Option<bool>,
    max_send_kbps: Option<u32>,
    max_recv_kbps: Option<u32>,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    
    let config_url = format!(
        "http://{}:{}/rest/config",
        state.config.host, state.config.port
    );
    
    let res = client
        .get(&config_url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Check if device already exists
    if let Some(devices) = config["devices"].as_array() {
        for device in devices {
            if device["deviceID"].as_str() == Some(&device_id) {
                return Err(SyncthingError::ProcessError("Device already exists".into()));
            }
        }
    }

    let new_device = serde_json::json!({
        "deviceID": device_id,
        "name": name,
        "addresses": addresses.unwrap_or_else(|| vec!["dynamic".to_string()]),
        "compression": compression.unwrap_or_else(|| "metadata".to_string()),
        "introducer": introducer.unwrap_or(false),
        "paused": false,
        "autoAcceptFolders": auto_accept_folders.unwrap_or(false),
        "maxSendKbps": max_send_kbps.unwrap_or(0),
        "maxRecvKbps": max_recv_kbps.unwrap_or(0),
    });

    if let Some(devices) = config["devices"].as_array_mut() {
        devices.push(new_device);
    }

    client
        .put(&config_url)
        .header("X-API-Key", &state.config.api_key)
        .json(&config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Update device configuration
#[tauri::command]
pub async fn update_device_config(
    state: State<'_, SyncthingState>,
    device_id: String,
    updates: serde_json::Value,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/devices/{}",
        state.config.host, state.config.port, device_id
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut device_config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Merge updates
    if let (Some(config_obj), Some(updates_obj)) = (device_config.as_object_mut(), updates.as_object()) {
        for (key, value) in updates_obj {
            config_obj.insert(key.clone(), value.clone());
        }
    }

    client
        .put(&url)
        .header("X-API-Key", &state.config.api_key)
        .json(&device_config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Pause a device
#[tauri::command]
pub async fn pause_device(
    state: State<'_, SyncthingState>,
    device_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/devices/{}",
        state.config.host, state.config.port, device_id
    );

    // Get current config
    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Update paused status
    config["paused"] = serde_json::Value::Bool(true);

    // Put updated config
    client
        .put(&url)
        .header("X-API-Key", &state.config.api_key)
        .json(&config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Resume a device
#[tauri::command]
pub async fn resume_device(
    state: State<'_, SyncthingState>,
    device_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/devices/{}",
        state.config.host, state.config.port, device_id
    );

    // Get current config
    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Update paused status
    config["paused"] = serde_json::Value::Bool(false);

    // Put updated config
    client
        .put(&url)
        .header("X-API-Key", &state.config.api_key)
        .json(&config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Unshare a folder from a device
#[tauri::command]
pub async fn unshare_folder(
    state: State<'_, SyncthingState>,
    folder_id: String,
    device_id: String,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/folders/{}",
        state.config.host, state.config.port, folder_id
    );

    // Get current folder config
    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let mut folder_config: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    // Remove device from the devices array
    if let Some(devices) = folder_config["devices"].as_array_mut() {
        devices.retain(|d| d["deviceID"].as_str() != Some(&device_id));
    }

    // Update config
    client
        .put(&url)
        .header("X-API-Key", &state.config.api_key)
        .json(&folder_config)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

// ============================================================================
// System Management
// ============================================================================

/// Restart Syncthing
#[tauri::command]
pub async fn restart_syncthing(
    state: State<'_, SyncthingState>,
) -> Result<(), SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/system/restart",
        state.config.host, state.config.port
    );

    client
        .post(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    Ok(())
}

/// Get detailed folder configuration
#[tauri::command]
pub async fn get_folder_config(
    state: State<'_, SyncthingState>,
    folder_id: String,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/folders/{}",
        state.config.host, state.config.port, folder_id
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

/// Get detailed device configuration
#[tauri::command]
pub async fn get_device_config(
    state: State<'_, SyncthingState>,
    device_id: String,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let url = format!(
        "http://{}:{}/rest/config/devices/{}",
        state.config.host, state.config.port, device_id
    );

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

/// Open folder in file explorer
#[tauri::command]
pub async fn open_folder_in_explorer(folder_path: String) -> Result<(), SyncthingError> {
    use std::process::Command;
    
    #[cfg(target_os = "linux")]
    {
        Command::new("xdg-open")
            .arg(&folder_path)
            .spawn()
            .map_err(|e| SyncthingError::ProcessError(format!("Failed to open folder: {}", e)))?;
    }

    #[cfg(target_os = "macos")]
    {
        Command::new("open")
            .arg(&folder_path)
            .spawn()
            .map_err(|e| SyncthingError::ProcessError(format!("Failed to open folder: {}", e)))?;
    }

    #[cfg(target_os = "windows")]
    {
        Command::new("explorer")
            .arg(&folder_path)
            .spawn()
            .map_err(|e| SyncthingError::ProcessError(format!("Failed to open folder: {}", e)))?;
    }

    Ok(())
}

/// Browse files in a folder (list directory contents)
#[tauri::command]
pub async fn browse_folder(
    state: State<'_, SyncthingState>,
    folder_id: String,
    prefix: Option<String>,
) -> Result<serde_json::Value, SyncthingError> {
    let client = reqwest::Client::new();
    let mut url = format!(
        "http://{}:{}/rest/db/browse?folder={}",
        state.config.host, state.config.port, folder_id
    );

    if let Some(p) = prefix {
        url = format!("{}&prefix={}", url, p);
    }

    let res = client
        .get(&url)
        .header("X-API-Key", &state.config.api_key)
        .send()
        .await
        .map_err(|e| SyncthingError::HttpError(e.to_string()))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| SyncthingError::ParseError(e.to_string()))?;

    Ok(json)
}

// ============================================================================
// File Conflict Resolution
// ============================================================================

/// Get list of conflict files for a folder by scanning the filesystem
#[tauri::command]
pub async fn scan_for_conflicts(
    folder_path: String,
) -> Result<Vec<serde_json::Value>, SyncthingError> {
    let mut conflicts = Vec::new();
    
    fn scan_dir(dir: &std::path::Path, conflicts: &mut Vec<serde_json::Value>, base: &std::path::Path) {
        if let Ok(entries) = std::fs::read_dir(dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                if path.is_dir() {
                    // Skip hidden directories and .stversions
                    if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                        if !name.starts_with('.') && name != ".stversions" {
                            scan_dir(&path, conflicts, base);
                        }
                    }
                } else if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                    if name.contains(".sync-conflict-") {
                        let relative_path = path.strip_prefix(base).unwrap_or(&path);
                        if let Ok(metadata) = std::fs::metadata(&path) {
                            // Extract original filename from conflict pattern
                            // Pattern: filename.sync-conflict-YYYYMMDD-HHMMSS-DEVICEID.ext
                            let original = extract_original_filename(name);
                            conflicts.push(serde_json::json!({
                                "name": relative_path.to_string_lossy(),
                                "original": original,
                                "size": metadata.len(),
                                "modTime": metadata.modified().ok().map(|t| {
                                    let duration = t.duration_since(std::time::UNIX_EPOCH).unwrap_or_default();
                                    duration.as_secs()
                                }),
                            }));
                        }
                    }
                }
            }
        }
    }
    
    fn extract_original_filename(conflict_name: &str) -> String {
        // Pattern: file.sync-conflict-20231201-120000-ABCDEFG.txt
        // Should become: file.txt
        if let Some(pos) = conflict_name.find(".sync-conflict-") {
            let before = &conflict_name[..pos];
            // Find the extension after the conflict marker
            let after = &conflict_name[pos..];
            if let Some(ext_pos) = after.rfind('.') {
                let ext = &after[ext_pos..];
                return format!("{}{}", before, ext);
            }
            return before.to_string();
        }
        conflict_name.to_string()
    }

    let base = std::path::Path::new(&folder_path);
    if base.exists() {
        scan_dir(base, &mut conflicts, base);
    }

    Ok(conflicts)
}

/// Delete a conflict file (resolve by keeping the original)
#[tauri::command]
pub async fn delete_conflict_file(
    folder_path: String,
    conflict_file: String,
) -> Result<(), SyncthingError> {
    let full_path = std::path::Path::new(&folder_path).join(&conflict_file);
    
    if full_path.exists() {
        std::fs::remove_file(&full_path)
            .map_err(|e| SyncthingError::ProcessError(format!("Failed to delete conflict file: {}", e)))?;
    }

    Ok(())
}

/// Resolve conflict by replacing original with conflict file
#[tauri::command]
pub async fn resolve_conflict_keep_conflict(
    folder_path: String,
    original_file: String,
    conflict_file: String,
) -> Result<(), SyncthingError> {
    let base_path = std::path::Path::new(&folder_path);
    let original_path = base_path.join(&original_file);
    let conflict_path = base_path.join(&conflict_file);
    
    // Delete original if it exists
    if original_path.exists() {
        std::fs::remove_file(&original_path)
            .map_err(|e| SyncthingError::ProcessError(format!("Failed to delete original: {}", e)))?;
    }

    // Rename conflict to original
    if conflict_path.exists() {
        std::fs::rename(&conflict_path, &original_path)
            .map_err(|e| SyncthingError::ProcessError(format!("Failed to rename conflict file: {}", e)))?;
    }

    Ok(())
}

// ============================================================================
// File Versioning
// ============================================================================

/// Browse the .stversions folder for old file versions
#[tauri::command]
pub async fn browse_versions(
    folder_path: String,
    prefix: Option<String>,
) -> Result<Vec<serde_json::Value>, SyncthingError> {
    use std::path::Path;
    use std::fs;

    let versions_path = Path::new(&folder_path).join(".stversions");
    let browse_path = if let Some(ref p) = prefix {
        versions_path.join(p)
    } else {
        versions_path.clone()
    };

    if !browse_path.exists() {
        return Ok(Vec::new());
    }

    let mut entries = Vec::new();
    
    if let Ok(dir_entries) = fs::read_dir(&browse_path) {
        for entry in dir_entries.flatten() {
            let path = entry.path();
            let name = path.file_name()
                .and_then(|n| n.to_str())
                .unwrap_or("")
                .to_string();

            if let Ok(metadata) = entry.metadata() {
                let is_dir = metadata.is_dir();
                
                // Parse version timestamp from filename if it's a file
                // Pattern: filename~YYYYMMDD-HHMMSS.ext
                let (original_name, version_time) = if !is_dir {
                    parse_version_filename(&name)
                } else {
                    (name.clone(), None)
                };

                entries.push(serde_json::json!({
                    "name": name,
                    "originalName": original_name,
                    "type": if is_dir { "directory" } else { "file" },
                    "size": if is_dir { None::<u64> } else { Some(metadata.len()) },
                    "modTime": metadata.modified().ok().map(|t| {
                        t.duration_since(std::time::UNIX_EPOCH)
                            .map(|d| d.as_secs())
                            .unwrap_or(0)
                    }),
                    "versionTime": version_time,
                }));
            }
        }
    }

    // Sort: directories first, then by modification time (newest first)
    entries.sort_by(|a, b| {
        let a_is_dir = a["type"].as_str() == Some("directory");
        let b_is_dir = b["type"].as_str() == Some("directory");
        
        if a_is_dir != b_is_dir {
            return if a_is_dir { std::cmp::Ordering::Less } else { std::cmp::Ordering::Greater };
        }
        
        let a_time = a["modTime"].as_u64().unwrap_or(0);
        let b_time = b["modTime"].as_u64().unwrap_or(0);
        b_time.cmp(&a_time)
    });

    Ok(entries)
}

/// Parse versioned filename to extract original name and version timestamp
fn parse_version_filename(name: &str) -> (String, Option<String>) {
    // Pattern: filename~YYYYMMDD-HHMMSS.ext or filename~YYYYMMDD-HHMMSS
    // Example: document~20231215-143022.pdf -> (document.pdf, 2023-12-15 14:30:22)
    
    if let Some(tilde_pos) = name.rfind('~') {
        let before_tilde = &name[..tilde_pos];
        let after_tilde = &name[tilde_pos + 1..];
        
        // Check if after_tilde matches version pattern
        let version_part: String;
        let extension: &str;
        
        if let Some(dot_pos) = after_tilde.find('.') {
            version_part = after_tilde[..dot_pos].to_string();
            extension = &after_tilde[dot_pos..];
        } else {
            version_part = after_tilde.to_string();
            extension = "";
        }
        
        // Validate version format: YYYYMMDD-HHMMSS (15 chars)
        if version_part.len() == 15 && version_part.chars().nth(8) == Some('-') {
            let original = format!("{}{}", before_tilde, extension);
            
            // Format the timestamp nicely
            let formatted = format!(
                "{}-{}-{} {}:{}:{}",
                &version_part[0..4],   // Year
                &version_part[4..6],   // Month
                &version_part[6..8],   // Day
                &version_part[9..11],  // Hour
                &version_part[11..13], // Minute
                &version_part[13..15]  // Second
            );
            
            return (original, Some(formatted));
        }
    }
    
    (name.to_string(), None)
}

/// Restore a versioned file to its original location
#[tauri::command]
pub async fn restore_version(
    folder_path: String,
    version_path: String,
    original_name: String,
    overwrite: bool,
) -> Result<(), SyncthingError> {
    use std::path::Path;
    use std::fs;

    let source = Path::new(&folder_path).join(".stversions").join(&version_path);
    let dest = Path::new(&folder_path).join(&original_name);

    if !source.exists() {
        return Err(SyncthingError::ProcessError("Version file not found".to_string()));
    }

    if dest.exists() && !overwrite {
        return Err(SyncthingError::ProcessError(
            "Destination file exists. Set overwrite=true to replace.".to_string()
        ));
    }

    // Create parent directories if needed
    if let Some(parent) = dest.parent() {
        fs::create_dir_all(parent)
            .map_err(|e| SyncthingError::ProcessError(format!("Failed to create directories: {}", e)))?;
    }

    // Copy the version file to the original location
    fs::copy(&source, &dest)
        .map_err(|e| SyncthingError::ProcessError(format!("Failed to restore file: {}", e)))?;

    Ok(())
}

// ============================================================================
// Tray Status Update
// ============================================================================

/// Update the system tray tooltip with current status
#[tauri::command]
pub async fn update_tray_status(
    app: tauri::AppHandle,
    _status: String,
    tooltip: String,
) -> Result<(), SyncthingError> {
    // Update the tray tooltip
    if let Some(tray) = app.tray_by_id("main") {
        let _ = tray.set_tooltip(Some(&tooltip));
    }
    
    // Note: Tauri v2 menu items are immutable after creation,
    // so we update via the tooltip instead
    
    Ok(())
}
</file>

<file path="src-tauri/src/lib.rs">
use serde::{Deserialize, Serialize};
use std::fs;
use std::sync::Mutex;
use tauri::Manager;
use tauri_plugin_shell::process::CommandChild;

pub mod commands;

#[derive(Debug, Clone)]
pub struct SyncthingConfig {
    pub api_key: String,
    pub port: u16,
    pub host: String,
}

impl SyncthingConfig {
    /// Try to read API key from Syncthing's config file
    fn read_api_key() -> Option<String> {
        // Try common config locations
        let home = std::env::var("HOME").ok()?;
        let paths = [
            format!("{}/.local/state/syncthing/config.xml", home),
            format!("{}/.config/syncthing/config.xml", home),
        ];
        
        for path in &paths {
            if let Ok(content) = fs::read_to_string(path) {
                // Simple XML parsing for apikey
                if let Some(start) = content.find("<apikey>") {
                    if let Some(end) = content[start..].find("</apikey>") {
                        let key = &content[start + 8..start + end];
                        if !key.is_empty() {
                            return Some(key.to_string());
                        }
                    }
                }
            }
        }
        None
    }
}

impl Default for SyncthingConfig {
    fn default() -> Self {
        Self {
            api_key: Self::read_api_key().unwrap_or_else(|| "no-api-key".to_string()),
            port: 8384,
            host: "127.0.0.1".to_string(),
        }
    }
}

pub struct SyncthingState {
    pub config: SyncthingConfig,
    pub sidecar_child: Mutex<Option<CommandChild>>,
}

impl Default for SyncthingState {
    fn default() -> Self {
        Self {
            config: SyncthingConfig::default(),
            sidecar_child: Mutex::new(None),
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub enum SyncthingError {
    NotRunning,
    HttpError(String),
    ParseError(String),
    ProcessError(String),
}

impl std::fmt::Display for SyncthingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SyncthingError::NotRunning => write!(f, "Syncthing is not running"),
            SyncthingError::HttpError(e) => write!(f, "HTTP error: {}", e),
            SyncthingError::ParseError(e) => write!(f, "Parse error: {}", e),
            SyncthingError::ProcessError(e) => write!(f, "Process error: {}", e),
        }
    }
}

impl std::error::Error for SyncthingError {}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_opener::init())
        .plugin(tauri_plugin_notification::init())
        .plugin(tauri_plugin_dialog::init())
        .plugin(tauri_plugin_shell::init())
        .manage(SyncthingState::default())
        .setup(|app| {
            // Set up tray menu
            use tauri::menu::{MenuBuilder, MenuItemBuilder, PredefinedMenuItem};
            use tauri::tray::TrayIconBuilder;

            let status = MenuItemBuilder::with_id("status", "Status: Checking...")
                .enabled(false)
                .build(app)?;
            let separator1 = PredefinedMenuItem::separator(app)?;
            let show = MenuItemBuilder::with_id("show", "Show Window").build(app)?;
            let hide = MenuItemBuilder::with_id("hide", "Hide to Tray").build(app)?;
            let separator2 = PredefinedMenuItem::separator(app)?;
            let open_syncthing = MenuItemBuilder::with_id("open_syncthing", "Open Syncthing Web UI").build(app)?;
            let separator3 = PredefinedMenuItem::separator(app)?;
            let quit = MenuItemBuilder::with_id("quit", "Quit Eigen").build(app)?;

            let menu = MenuBuilder::new(app)
                .item(&status)
                .item(&separator1)
                .item(&show)
                .item(&hide)
                .item(&separator2)
                .item(&open_syncthing)
                .item(&separator3)
                .item(&quit)
                .build()?;

            let _tray = TrayIconBuilder::with_id("main")
                .icon(app.default_window_icon().unwrap().clone())
                .menu(&menu)
                .tooltip("Eigen - Syncthing Manager")
                .on_menu_event(|app, event| {
                    match event.id().as_ref() {
                        "show" => {
                            if let Some(window) = app.get_webview_window("main") {
                                let _ = window.show();
                                let _ = window.unminimize();
                                let _ = window.set_focus();
                            }
                        }
                        "hide" => {
                            if let Some(window) = app.get_webview_window("main") {
                                let _ = window.hide();
                            }
                        }
                        "open_syncthing" => {
                            // Open Syncthing web UI in browser
                            let _ = open::that("http://127.0.0.1:8384");
                        }
                        "quit" => {
                            // Stop syncthing sidecar before quitting
                            let state = app.state::<SyncthingState>();
                            if let Ok(mut child_guard) = state.sidecar_child.lock() {
                                if let Some(child) = child_guard.take() {
                                    let _ = child.kill();
                                }
                            }
                            app.exit(0);
                        }
                        _ => {}
                    }
                })
                .on_tray_icon_event(|tray, event| {
                    use tauri::tray::TrayIconEvent;
                    if let TrayIconEvent::Click { button: tauri::tray::MouseButton::Left, .. } = event {
                        let app = tray.app_handle();
                        if let Some(window) = app.get_webview_window("main") {
                            // Toggle window visibility
                            if window.is_visible().unwrap_or(false) {
                                let _ = window.hide();
                            } else {
                                let _ = window.show();
                                let _ = window.unminimize();
                                let _ = window.set_focus();
                            }
                        }
                    }
                })
                .build(app)?;

            // Handle window close to minimize to tray instead
            if let Some(window) = app.get_webview_window("main") {
                let window_clone = window.clone();
                window.on_window_event(move |event| {
                    if let tauri::WindowEvent::CloseRequested { api, .. } = event {
                        // Prevent the window from actually closing
                        api.prevent_close();
                        // Just hide it instead
                        let _ = window_clone.hide();
                    }
                });
            }

            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            commands::check_syncthing_installation,
            commands::start_syncthing_sidecar,
            commands::stop_syncthing_sidecar,
            commands::get_system_status,
            commands::get_connections,
            commands::get_config,
            commands::update_options,
            commands::get_folder_status,
            commands::pause_folder,
            commands::resume_folder,
            commands::rescan_folder,
            commands::get_api_config,
            commands::get_device_id,
            commands::add_device,
            commands::remove_device,
            commands::add_folder,
            commands::remove_folder,
            commands::share_folder,
            // Advanced folder configuration
            commands::add_folder_advanced,
            commands::update_folder_config,
            commands::get_folder_config,
            // Ignore patterns
            commands::get_folder_ignores,
            commands::set_folder_ignores,
            // System logs
            commands::get_system_logs,
            // Event API
            commands::get_events,
            // Advanced device settings
            commands::add_device_advanced,
            commands::update_device_config,
            commands::get_device_config,
            commands::pause_device,
            commands::resume_device,
            // Folder sharing
            commands::unshare_folder,
            // System management
            commands::restart_syncthing,
            // File browser
            commands::open_folder_in_explorer,
            commands::browse_folder,
            // Conflict resolution
            commands::scan_for_conflicts,
            commands::delete_conflict_file,
            commands::resolve_conflict_keep_conflict,
            // File versioning
            commands::browse_versions,
            commands::restore_version,
            // Tray
            commands::update_tray_status,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
</file>

<file path="src-tauri/src/main.rs">
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
    eigen_lib::run()
}
</file>

<file path="src-tauri/.gitignore">
# Generated by Cargo
# will have compiled files and executables
/target/

# Generated by Tauri
# will have schema files for capabilities auto-completion
/gen/schemas
</file>

<file path="src-tauri/build.rs">
fn main() {
    tauri_build::build()
}
</file>

<file path="src-tauri/Cargo.toml">
[package]
name = "eigen"
version = "0.1.0"
description = "Eigen - A Modern Syncthing Manager"
authors = ["Eigen Team"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
# The `_lib` suffix may seem redundant but it is necessary
# to make the lib name unique and wouldn't conflict with the bin name.
# This seems to be only an issue on Windows, see https://github.com/rust-lang/cargo/issues/8519
name = "eigen_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2", features = [] }

[dependencies]
tauri = { version = "2", features = ["tray-icon"] }
tauri-plugin-opener = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
reqwest = { version = "0.12", features = ["json"] }
tokio = { version = "1", features = ["full"] }
rand = "0.8"
uuid = { version = "1", features = ["v4"] }
log = "0.4"
env_logger = "0.11"
thiserror = "1"
open = "5"
tauri-plugin-notification = "2.3.3"
tauri-plugin-dialog = "2.4.2"
tauri-plugin-shell = "2.3.3"
</file>

<file path="src-tauri/tauri.conf.json">
{
  "$schema": "https://schema.tauri.app/config/2",
  "productName": "Eigen",
  "version": "0.1.0",
  "identifier": "com.eigen.sync",
  "build": {
    "beforeDevCommand": "pnpm dev",
    "devUrl": "http://localhost:3000",
    "beforeBuildCommand": "pnpm build",
    "frontendDist": "../out"
  },
  "app": {
    "windows": [
      {
        "title": "Eigen - Syncthing Manager",
        "width": 1200,
        "height": 800,
        "minWidth": 800,
        "minHeight": 600,
        "resizable": true,
        "fullscreen": false,
        "transparent": false
      }
    ],
    "security": {
      "csp": null
    },
    "trayIcon": {
      "iconPath": "icons/tray_icon.png",
      "iconAsTemplate": false,
      "title": "Eigen",
      "tooltip": "Eigen - Syncthing Manager"
    }
  },
  "bundle": {
    "active": true,
    "targets": "all",
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ],
    "externalBin": [
      "binaries/syncthing"
    ]
  }
}
</file>

<file path="next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />
/// <reference path="./out/types/routes.d.ts" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
</file>

<file path="next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {
	output: 'export',
	distDir: 'out',
	images: {
		unoptimized: true,
	},
	assetPrefix: process.env.NODE_ENV === 'production' ? '' : undefined,
	// Enable Web Workers with webpack 5
	webpack: (config) => {
		config.resolve.alias = {
			...config.resolve.alias,
			sharp$: false,
			'onnxruntime-node$': false,
		};
		return config;
	},
};

export default nextConfig;
</file>

<file path="package.json">
{
  "name": "eigen",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "next dev --turbopack --port 3000",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "tauri": "tauri",
    "download:syncthing": "node scripts/download-syncthing.js",
    "prebuild": "node scripts/download-syncthing.js"
  },
  "dependencies": {
    "@tanstack/react-query": "^5.60.0",
    "@tauri-apps/api": "^2",
    "@tauri-apps/plugin-dialog": "^2.4.2",
    "@tauri-apps/plugin-notification": "^2.3.3",
    "@tauri-apps/plugin-opener": "^2",
    "@tauri-apps/plugin-shell": "^2.3.3",
    "@xenova/transformers": "^2.17.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "framer-motion": "^12.23.24",
    "idb": "^8.0.3",
    "lucide-react": "^0.460.0",
    "next": "^15.1.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "sonner": "^1.7.0",
    "tailwind-merge": "^2.5.5",
    "zod": "^3.23.8",
    "zustand": "^5.0.1"
  },
  "devDependencies": {
    "@tauri-apps/cli": "^2",
    "@types/node": "^22.10.1",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@types/three": "^0.170.0",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.16.0",
    "eslint-config-next": "^15.1.0",
    "postcss": "^8.4.49",
    "tailwindcss": "^3.4.16",
    "typescript": "~5.8.3"
  }
}
</file>

<file path="postcss.config.cjs">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="tailwind.config.cjs">
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))"
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))"
        },
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))"
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))"
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))"
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))"
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))"
        },
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)"
      },
    },
  },
  plugins: [],
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "target": "ES2017",
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "next-env.d.ts",
    "src/types/**/*.d.ts",
    "out/types/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "src-tauri"
  ]
}
</file>

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path=".gitignore">
# Dependencies
node_modules/

# Logs
*.log
npm-debug.log*
yarn-debug.log*
pnpm-debug.log*

# Build outputs
.next/
out/
dist/
dist-ssr/
build/

# Tauri / Rust
target/
gen/schemas/
*.rs.bk

# Environment
.env
.env.local
*.local

# Editor
.idea/
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Cache
.cache/
.eslintcache

# Testing
coverage/
.nyc_output/
</file>

<file path="README.md">
# Eigen

## Features## Recommended IDE Setup

-  **Native Performance** - Built with Rust/Tauri for blazing fast performance- [VS Code](https://code.visualstudio.com/) + [Tauri](https://marketplace.visualstudio.com/items?itemName=tauri-apps.tauri-vscode) + [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer)

-  **Modern UI** - Beautiful glassmorphism design with dark theme
-  **3D Network Visualization** - Interactive network topology using React Three Fiber
-  **Real-time Updates** - Live sync status with TanStack Query polling
-  **Secure** - API keys managed internally by Rust backend
-  **Type-Safe** - End-to-end type safety with TypeScript and Zod

## Tech Stack

### Frontend
- **Next.js 15** - React framework with static export
- **Tailwind CSS** - Utility-first styling
- **TanStack Query** - Server state management
- **Zustand** - Client state management
- **React Three Fiber** - 3D visualizations
- **Lucide Icons** - Beautiful icons

### Backend
- **Tauri v2** - Rust-based desktop framework
- **Reqwest** - HTTP client for Syncthing API
- **Tokio** - Async runtime
- **Serde** - Serialization/deserialization

## Prerequisites

- [Node.js](https://nodejs.org/) (v18+)
- [pnpm](https://pnpm.io/) (v8+)
- [Rust](https://www.rust-lang.org/tools/install)
- [Syncthing](https://syncthing.net/) installed and accessible in PATH

### Linux Dependencies (Ubuntu/Debian)

```bash
sudo apt update
sudo apt install -y libwebkit2gtk-4.1-dev libgtk-3-dev libayatana-appindicator3-dev librsvg2-dev
```

## Development

### Install Dependencies

```bash
pnpm install
```

### Run Development Server

```bash
pnpm tauri dev
```

### Build for Production

```bash
pnpm tauri build
```

## Project Structure

```
eigen/
 src/                      # Next.js frontend
    app/                  # App router pages
    components/           # React components
       ui/              # shadcn/ui components
       network-graph.tsx # 3D network visualization
       folder-list.tsx   # Folder management
       device-list.tsx   # Device management
       ...
    hooks/               # Custom React hooks
    lib/                 # Utility functions
    store/               # Zustand stores
 src-tauri/               # Rust backend
    src/
       lib.rs           # Tauri commands
    Cargo.toml           # Rust dependencies
    tauri.conf.json      # Tauri configuration
 package.json
```

## Architecture

Eigen follows a "Thin Client" architecture:

1. **Frontend (Next.js SSG)**: Pure UI rendering and visualization
2. **Backend (Rust/Tauri)**: Manages Syncthing process, proxies API requests, handles native features

### Data Flow

```
User Action  React Component  TanStack Query  Tauri IPC  Rust Backend  Syncthing REST API
                                              
User UI  React Component  TanStack Query  Tauri IPC  Rust Backend  Syncthing Response
```

## Features

### Dashboard
- Real-time sync status
- Network topology visualization
- Upload/download statistics
- Folder and device overview

### Folders
- View all synced folders
- Pause/resume sync
- Force rescan
- Sync status indicators

### Devices
- Connected device list
- Connection status
- Device information

## License

MIT
</file>

</files>
